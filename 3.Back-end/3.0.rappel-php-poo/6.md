---
title: 6. Interfaces, traits & namespaces
layout: home
nav_order: 6
parent: 3.0. Rappel PHP & POO
permalink: /interfaces-traits-namespaces/
---

# üìò Chapitre 3.0.6 ‚Äî Interfaces & traits, `::class`, organisation par namespaces

## üìí Glossaire minute
- **Interface** : contrat (m√©thodes sans impl√©mentation) que des classes s‚Äôengagent √† respecter (`implements`).  
- **Trait** : bloc de **r√©utilisation de code** (m√©thodes/propri√©t√©s) inject√© dans une classe (`use`).  
- **Namespace** : espace de nommage pour organiser et **√©viter les collisions** (`namespace App\Domain;`).  
- **FQCN** : *Fully Qualified Class Name* ‚Äî nom complet incluant le namespace (`App\Domain\Article`).  
- **`::class`** : constante retournant le **FQCN** de la classe (`Article::class`).  
- **PSR-4** : convention d‚Äô**autoloading** mappant un pr√©fixe de namespace vers un dossier (`"App\\": "src/"`).

---

## üéØ Objectif p√©dagogique
Savoir :
1) **Mod√©liser par contrat** avec des **interfaces**,  
2) **Factoriser** du comportement avec des **traits**,  
3) G√©rer des **r√©f√©rences de classes** via `::class`,  
4) **Structurer** le code proprement avec des **namespaces** et l‚Äô**autoload PSR-4** de Composer.

---

## üß† D√©finition th√©orique (avec mini-exemples)

### 1) Interfaces : contrat & polymorphisme
```php
<?php
declare(strict_types=1);

interface Logger {
  public function info(string $msg): void;
}

class StdoutLogger implements Logger {
  public function info(string $msg): void { echo "[INFO] $msg" . PHP_EOL; }
}

class NullLogger implements Logger {
  public function info(string $msg): void { /* no-op */ }
}

function run(Logger $logger): void {
  $logger->info("D√©marrage‚Ä¶");
}

run(new StdoutLogger());  // respecte le contrat Logger
````

> Tapez vos **d√©pendances sur les interfaces**, pas sur des classes concr√®tes.

### 2) Traits : r√©utilisation horizontale

```php
trait Slugify {
  protected function slugify(string $value): string {
    $s = strtolower($value);
    $s = preg_replace('/[^a-z0-9]+/i', '-', $s) ?? '';
    return trim($s, '-');
  }
}

class Article {
  use Slugify;
  public function makeSlug(string $title): string { return $this->slugify($title); }
}
```

**Conflits de traits** (r√©solution avec `insteadof` / `as`) :

```php
trait A { public function ping(){ echo 'A'; } }
trait B { public function ping(){ echo 'B'; } }

class X {
  use A, B { A::ping insteadof B; B::ping as pingB; }
}
(new X())->ping();  // A
```

### 3) `::class` : obtenir le FQCN (mapping, r√©flexion)

```php
class CreateArticleHandler {}
$handlers = [
  'create-article' => CreateArticleHandler::class, // "CreateArticleHandler"
];
```

### 4) Namespaces & `use`

```php
<?php
declare(strict_types=1);

namespace App\Domain;

class Article { /* ‚Ä¶ */ }

// Fichier consommateur :
namespace App;

use App\Domain\Article;

$a = new Article();
```

### 5) PSR-4 (Composer)

`composer.json` :

```json
{
  "autoload": {
    "psr-4": { "App\\": "src/" }
  }
}
```

Puis :

```bash
composer dump-autoload
```

---

## üîç Exemple fil rouge ‚Äî Contrats + impl√©mentations + autoload

**Objectif** : pr√©parer l‚Äôinfrastructure pour le futur **seed JSON d‚Äôarticles** (C3.0.7‚Äì3.0.9) en d√©finissant :

* une **interface** `Sluggable`,
* un **trait** `Slugify`,
* une entit√© `Article` **qui impl√©mente** `Sluggable`,
* un **contrat de d√©p√¥t** `ArticleRepositoryInterface`,
* une **impl√©mentation JSON** `JsonArticleRepository`,
* un script `bin/seed.php` qui assemble le tout via **PSR-4**.

### Arborescence

```
c3-php/
‚îú‚îÄ‚îÄ composer.json
‚îú‚îÄ‚îÄ bin/
‚îÇ   ‚îî‚îÄ‚îÄ seed.php
‚îî‚îÄ‚îÄ src/
    ‚îú‚îÄ‚îÄ Domain/
    ‚îÇ   ‚îú‚îÄ‚îÄ Contracts/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Sluggable.php
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ArticleRepositoryInterface.php
    ‚îÇ   ‚îî‚îÄ‚îÄ Article.php
    ‚îú‚îÄ‚îÄ Infrastructure/
    ‚îÇ   ‚îî‚îÄ‚îÄ JsonArticleRepository.php
    ‚îî‚îÄ‚îÄ Support/
        ‚îî‚îÄ‚îÄ Traits/
            ‚îî‚îÄ‚îÄ Slugify.php
```

### 1) `composer.json` (PSR-4)

```json
{
  "name": "solicode/c3-php",
  "type": "project",
  "require": {},
  "autoload": {
    "psr-4": { "App\\": "src/" }
  }
}
```

### 2) `src/Domain/Contracts/Sluggable.php`

```php
<?php
declare(strict_types=1);

namespace App\Domain\Contracts;

interface Sluggable {
  public function slug(): string;
  public function title(): string;
}
```

### 3) `src/Support/Traits/Slugify.php`

```php
<?php
declare(strict_types=1);

namespace App\Support\Traits;

trait Slugify {
  protected static function slugify(string $value): string {
    $s = strtolower($value);
    $s = preg_replace('/[^a-z0-9]+/i', '-', $s) ?? '';
    return trim($s, '-');
  }
}
```

### 4) `src/Domain/Article.php`

```php
<?php
declare(strict_types=1);

namespace App\Domain;

use App\Domain\Contracts\Sluggable;
use App\Support\Traits\Slugify;

final class Article implements Sluggable {
  use Slugify;

  public function __construct(
    public readonly int $id,
    private string $title,
    private string $slug,
    private array $tags = [],
  ) {}

  public static function fromTitle(int $id, string $title, array $tags = []): self {
    return new self($id, $title, self::slugify($title), $tags);
  }

  public function title(): string { return $this->title; }
  public function slug(): string { return $this->slug; }
  public function tags(): array { return $this->tags; }

  public function toArray(): array {
    return [
      'id' => $this->id,
      'title' => $this->title(),
      'slug' => $this->slug(),
      'tags' => $this->tags(),
    ];
  }
}
```

### 5) `src/Domain/Contracts/ArticleRepositoryInterface.php`

```php
<?php
declare(strict_types=1);

namespace App\Domain\Contracts;

use App\Domain\Article;

interface ArticleRepositoryInterface {
  /** @return list<Article> */
  public function all(): array;
  public function save(Article $article): void;
}
```

### 6) `src/Infrastructure/JsonArticleRepository.php`

```php
<?php
declare(strict_types=1);

namespace App\Infrastructure;

use App\Domain\Article;
use App\Domain\Contracts\ArticleRepositoryInterface;
use RuntimeException;

final class JsonArticleRepository implements ArticleRepositoryInterface {
  public function __construct(private string $path) {}

  /** @return list<Article> */
  public function all(): array {
    if (!is_file($this->path)) return [];
    $raw = file_get_contents($this->path);
    if ($raw === false) throw new RuntimeException("Lecture impossible: {$this->path}");
    /** @var array<int,array{id:int,title:string,slug:string,tags:array}> $rows */
    $rows = json_decode($raw, true) ?: [];
    return array_map(
      fn(array $r) => new Article($r['id'], $r['title'], $r['slug'], $r['tags'] ?? []),
      $rows
    );
  }

  public function save(Article $article): void {
    $rows = array_map(fn(Article $a) => $a->toArray(), $this->all());
    $rows[] = $article->toArray();
    $dir = dirname($this->path);
    if (!is_dir($dir)) mkdir($dir, 0777, true);
    if (false === file_put_contents($this->path, json_encode($rows, JSON_PRETTY_PRINT))) {
      throw new RuntimeException("√âcriture impossible: {$this->path}");
    }
  }
}
```

### 7) `bin/seed.php`

```php
#!/usr/bin/env php
<?php
declare(strict_types=1);

require __DIR__ . '/../vendor/autoload.php';

use App\Domain\Article;
use App\Domain\Contracts\ArticleRepositoryInterface;
use App\Infrastructure\JsonArticleRepository;

$repoMap = [
  ArticleRepositoryInterface::class => new JsonArticleRepository(__DIR__ . '/../storage/seeds/articles.seed.json'),
];

$repo = $repoMap[ArticleRepositoryInterface::class];

$articles = [
  Article::fromTitle(1, 'Interfaces & traits en PHP', ['php', 'poo']),
  Article::fromTitle(2, 'Organiser avec namespaces & PSR-4', ['php', 'autoload']),
];

foreach ($articles as $a) {
  $repo->save($a);
}

echo "[OK] Seed enregistr√© dans storage/seeds/articles.seed.json" . PHP_EOL;
```

---

## üõ† Tutoriel pratique

### √âtape 1 ‚Äî Initialiser & autoload

```bash
cd c3-php
composer init -n
# √âditez composer.json pour ajouter l'autoload PSR-4 (cf. plus haut)
composer dump-autoload
```

### √âtape 2 ‚Äî Cr√©er les fichiers (selon l‚Äôarborescence)

Collez le code fourni dans chaque fichier.

### √âtape 3 ‚Äî Ex√©cuter le seed

```bash
php bin/seed.php
# V√©rifiez la cr√©ation/maj de storage/seeds/articles.seed.json
```

### √âtape 4 ‚Äî Challenge (N1+)

* Ajoutez une seconde impl√©mentation du d√©p√¥t (`MemoryArticleRepository`) et injectez-la via la **carte `::class`**.
* G√©rez l‚Äô**unicit√© des slugs** dans le d√©p√¥t (lancer `DomainException` si doublon).
* Cr√©ez un **trait `Timestamps`** (`createdAt`, `updatedAt`) et utilisez-le dans `Article`.

---

## ‚úÖ Bonnes pratiques

* **D√©pendre des interfaces**, choisir l‚Äôimpl√©mentation **√† la fronti√®re** (composition).
* **Traits** : limiter aux **comportements purs** (peu d‚Äô√©tat), documenter les **pr√©-requis**.
* `::class` : pratique pour **mappers**, **usines**, **r√©flexion**.
* **Namespaces** : un **dossier = un namespace** (PSR-4), imports clairs (`use`).
* **Composer** : reg√©n√©rer l‚Äôautoload apr√®s ajout de classes (`composer dump-autoload`).

---

## üßæ R√©sum√©

* **Interfaces** = contrats ; **traits** = r√©utilisation de code ; **namespaces** = organisation & isolation.
* `::class` fournit des **r√©f√©rences s√ªres** au FQCN.
* L‚Äô**autoload PSR-4** structure votre projet et pr√©pare la mont√©e vers **Laravel**.

**Livrable attendu** :

* Projet PSR-4 fonctionnel (`composer.json` + `src/‚Ä¶`),
* Impl√©mentation `Article` (interface + trait),
* D√©p√¥t JSON op√©rationnel,
* Script `bin/seed.php` qui √©crit dans `storage/seeds/articles.seed.json`.

