---
title: 2. Fonctions & tableaux
layout: home
nav_order: 2
parent: 3.0. Rappel PHP & POO
permalink: /php-poo/fonctions-tableaux/
code: 3.0.2
competence: C3
autoformation: "C3.0"
ua: "3.0.U2"
duree_h: 1.5
objectif: "Écrire des fonctions typées et utiliser closures + helpers array_* pour filtrer, mapper, réduire et trier."
notions_nouvelles: ["Closure", "Arrow function", "array_map", "array_filter", "array_reduce", "array_column", "usort"]
fil_rouge: "Traitement des listes d’articles (Top, stats) pour le Blog"
livrable_chapitre: "Mini-rapport console: Top3 (views), répartition par auteur, fréquence des tags"
alimentation_prototype: "Calculs côté client/outil pour des vues triées (N2)"
alimentation_miniprojet: "Pipelines data réutilisables dans génération de seeds & API (N3)"
---


# 📘  3.0.2 - Fonctions, closures & manipulation de tableaux

## 📒 Glossaire minute
- **Fonction** : bloc réutilisable avec **paramètres typés** et **valeur de retour**.
- **Closure (fonction anonyme)** : fonction **sans nom**, souvent passée en **callback**.
- **Arrow function** : syntaxe courte `fn($x) => ...`, capture **automatique par valeur** des variables du scope.
- **Callback** : fonction passée comme **argument** à une autre fonction.
- **Helpers `array_*`** : utilitaires pour transformer/filtrer/agréger (`array_map`, `array_filter`, `array_reduce`, `array_column`, `array_keys`, `array_values`, `in_array`, `array_merge`, `usort`).

---

## 🎯 Objectif pédagogique
Écrire des **fonctions typées**, utiliser **closures/arrow functions**, et maîtriser les **helpers `array_*`** pour transformer, filtrer, agréger et trier des listes (ex. articles de blog) de façon **claire** et **robuste**.

---

## 🧠 Définition théorique (avec mini-exemples)

### 1) Fonctions typées (params, retour, valeurs par défaut, variadics)
```php
<?php
declare(strict_types=1);

function prixTTC(float $ht, float $taux = 0.2): float {
    return $ht * (1 + $taux);
}

function somme(int ...$nums): int { // variadics
    return array_sum($nums);
}

echo prixTTC(100.0); // 120
echo somme(1,2,3,4); // 10
````

### 2) Closures & arrow functions

```php
<?php
declare(strict_types=1);

$tax = 0.2;

// Closure (capture explicite via "use")
$ttc = function (float $ht) use ($tax): float {
    return $ht * (1 + $tax);
};

// Arrow function (capture auto par valeur)
$ttc2 = fn(float $ht): float => $ht * (1 + $tax);
```

### 3) `array_map`, `array_filter`, `array_reduce` (pipeline)

```php
<?php
declare(strict_types=1);

$nums = [1,2,3,4,5];

$squared = array_map(fn(int $n) => $n*$n, $nums);              // [1,4,9,16,25]
$even    = array_filter($nums, fn(int $n) => $n % 2 === 0);    // [2,4]
$total   = array_reduce($nums, fn(int $acc, int $n) => $acc + $n, 0); // 15
```

### 4) `array_column`, tri et utilitaires

```php
<?php
declare(strict_types=1);

$articles = [
  ['id'=>1,'title'=>'Intro Laravel','views'=>120,'author'=>'Amina','published'=>true],
  ['id'=>2,'title'=>'PHP 8 en pratique','views'=>300,'author'=>'Yassine','published'=>true],
  ['id'=>3,'title'=>'Composer & Autoload','views'=>90,'author'=>'Amina','published'=>false],
];

$titles = array_column($articles, 'title'); // ['Intro Laravel', 'PHP 8 en pratique', 'Composer & Autoload']

// Tri décroissant par "views"
usort($articles, fn($a, $b) => $b['views'] <=> $a['views']);

// Vérifs clés/valeurs
$hasViewsKey = array_key_exists('views', $articles[0]); // true
$isPublished = $articles[0]['published'] ?? false;       // coalescence (vu en 3.0.1)
```

---

## 🛠️ Tutoriel guidé (pas à pas)

### Jeu de données (à copier tel quel)

```php
<?php
declare(strict_types=1);

$articles = [
  ['id'=>1,'title'=>'Intro Laravel','category'=>'php','views'=>120,'author'=>'Amina','published'=>true,  'tags'=>['php','laravel']],
  ['id'=>2,'title'=>'PHP 8 en pratique','category'=>'php','views'=>300,'author'=>'Yassine','published'=>true,  'tags'=>['php']],
  ['id'=>3,'title'=>'Composer & Autoload','category'=>'outils','views'=>90,'author'=>'Amina','published'=>false, 'tags'=>['composer','php']],
  ['id'=>4,'title'=>'Validation FormRequest','category'=>'laravel','views'=>210,'author'=>'Sara','published'=>true,  'tags'=>['laravel','validation']],
];
```

### Étape 1 — Utilitaire `slugify(string): string`

```php
<?php
declare(strict_types=1);

function slugify(string $title): string {
    $slug = strtolower($title);
    $slug = preg_replace('/[^a-z0-9]+/i', '-', $slug);
    return trim($slug, '-');
}
```

### Étape 2 — Filtrer les articles publiés

```php
<?php
$published = array_values(
  array_filter($articles, fn(array $a) => $a['published'] ?? false)
);
```

### Étape 3 — Mapper vers un format léger (id, title, slug, views)

```php
<?php
$light = array_map(
  fn(array $a) => [
    'id'    => $a['id'],
    'title' => $a['title'],
    'slug'  => slugify($a['title']),
    'views' => $a['views'],
  ],
  $published
);
```

### Étape 4 — Top 3 par vues

```php
<?php
$top = $light;
usort($top, fn($a, $b) => $b['views'] <=> $a['views']);
$top3 = array_slice($top, 0, 3);
```

### Étape 5 — Agréger : nombre d’articles par auteur

```php
<?php
$byAuthor = array_reduce(
  $published,
  function(array $acc, array $a): array {
      $author = $a['author'];
      $acc[$author] = ($acc[$author] ?? 0) + 1;
      return $acc;
  },
  []
);
```

### Étape 6 — Fréquence des tags (flatten + reduce)

```php
<?php
$allTags = array_merge(...array_map(fn($a) => $a['tags'], $published));

$tagFreq = array_reduce(
  $allTags,
  function(array $acc, string $tag): array {
      $acc[$tag] = ($acc[$tag] ?? 0) + 1;
      return $acc;
  },
  []
);
```

### Étape 7 — Afficher un mini-rapport

```php
<?php
echo "Top 3 (views):\n";
foreach ($top3 as $a) {
  echo "- {$a['title']} ({$a['views']} vues) — {$a['slug']}\n";
}

echo "\nPar auteur:\n";
foreach ($byAuthor as $author => $count) {
  echo "- $author: $count article(s)\n";
}

echo "\nTags:\n";
foreach ($tagFreq as $tag => $count) {
  echo "- $tag: $count\n";
}
```

---

## 🧪 Exercice guidé (livrable N1)

> **But** : produire, à partir de `$articles`, un tableau **normalisé** prêt pour JSON :
>
> ```php
> [
>   ['id'=>1,'slug'=>'intro-laravel','views'=>120,'author'=>'Amina','category'=>'php'],
>   ...
> ]
> ```
>
> **Exigences**
>
> 1. Garder uniquement `published===true` via **`array_filter`**.
> 2. Normaliser avec **`array_map`** (slug du `title`, champs : `id/slug/views/author/category`).
> 3. **Trier** par vues **desc** avec `usort`.
> 4. Calculer un **résumé** :
>
>    ```php
>    ['count'=>..., 'views_sum'=>..., 'by_category'=>['php'=>..., 'laravel'=>..., ...]]
>    ```
> 5. Afficher le résultat avec `print_r(...)`.

### (Corrigé indicatif)

```php
<?php
declare(strict_types=1);

$published = array_values(array_filter($articles, fn($a) => $a['published'] ?? false));

$normalized = array_map(
  fn($a) => [
    'id'       => $a['id'],
    'slug'     => slugify($a['title']),
    'views'    => $a['views'],
    'author'   => $a['author'],
    'category' => $a['category'],
  ],
  $published
);

usort($normalized, fn($x, $y) => $y['views'] <=> $x['views']);

$summary = array_reduce(
  $published,
  function(array $acc, array $a): array {
      $acc['count']      = ($acc['count'] ?? 0) + 1;
      $acc['views_sum']  = ($acc['views_sum'] ?? 0) + $a['views'];
      $cat = $a['category'];
      $acc['by_category'][$cat] = ($acc['by_category'][$cat] ?? 0) + 1;
      return $acc;
  },
  ['count'=>0, 'views_sum'=>0, 'by_category'=>[]]
);

print_r($normalized);
print_r($summary);
```

---

## ⚠️ Erreurs fréquentes

* **Oublier le type de retour** d’une fonction → comportements implicites et bugs.
* Confondre **`isset($a['x'])`** (faux si `null`) avec **`array_key_exists('x',$a)`** (vrai même si `null`).
* Oublier la **valeur initiale** dans `array_reduce` (sinon `$acc` commence à `null`).
* **Muter** le tableau d’origine pendant un `foreach` (préférez retourner une **nouvelle** structure).
* Utiliser `array_merge` là où l’**unpacking** `...` est plus lisible pour fusionner des **listes**.

---

## 🧾 Résumé

* **Fonctions typées** + **closures** = code plus **lisible** et **sûr**.
* Le pipeline **filter → map → sort → reduce** est un **standard** pour traiter des listes.
* Prépare directement la **génération de seeds JSON** (C3.0.8) et la **normalisation des réponses API** (C3.3).

---

## 🔗 Aller plus loin (optionnel)

* Implémentez `groupBy(array $items, callable $keyFn): array` avec `array_reduce`.
* Ajoutez une option CLI `--limit=3` pour ne montrer que les **N** premiers résultats (prépare le chapitre CLI).