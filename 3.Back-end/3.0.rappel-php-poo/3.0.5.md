---
title: 5. Encapsulation
layout: home
nav_order: 5
parent: 3.0. Rappel PHP & POO
permalink: /php-poo//encapsulation-visibilite/
---

# 📘  3.0.5 - Encapsulation & visibilité

## 📒 Glossaire minute
- **Encapsulation** : protéger l’état interne d’une classe via une **API publique minimale** (getters/méthodes métier), et effectuer la **validation** à l’entrée.  
- **Visibilité** :
  - `public` : accessible partout,
  - `protected` : accessible dans la classe **et** ses **sous-classes**,
  - `private` : accessible **uniquement** dans la classe.  
- **`readonly` (PHP ≥ 8.1)** : propriété **assignable une seule fois** (souvent au constructeur) → **immuable** ensuite.  
- **`static`** : membre partagé par **toutes les instances** de la classe. À utiliser **avec parcimonie** (état global).

---

## 🎯 Objectif pédagogique
Savoir **concevoir des classes robustes** :
- choisir la **bonne visibilité** pour chaque membre,
- garantir les invariants via **encapsulation**,
- utiliser `readonly` pour l’**immutabilité** des identifiants,
- employer `static` à bon escient (compteurs, usines, utilitaires).

---

## 🧠 Définition théorique (avec mini-exemples)

### 1) Encapsulation & visibilité
```php
<?php
declare(strict_types=1);

class User {
  private string $name;          // caché au monde extérieur
  protected array $roles = [];   // visible par les sous-classes
  public function __construct(string $name) { $this->setName($name); }

  public function name(): string { return $this->name; }

  public function setName(string $name): void {
    $name = trim($name);
    if ($name === '') throw new InvalidArgumentException("Nom requis.");
    $this->name = $name;
  }

  public function addRole(string $role): void {
    if ($role === '') throw new InvalidArgumentException("Role vide.");
    $this->roles[] = $role;
  }

  public function roles(): array { return $this->roles; }
}

$u = new User('Amina');
$u->addRole('author');
// $u->name = 'X';         // ❌ Erreur : propriété privée
// echo $u->roles[0];      // ❌ Erreur : propriété protégée
echo $u->name();           // ✅ OK via API publique
````

### 2) `readonly` : immutabilité des identifiants

```php
class ArticleId {
  public function __construct(public readonly int $value) {
    if ($value <= 0) throw new InvalidArgumentException("Id > 0 requis.");
  }
}

$id = new ArticleId(10);
// $id->value = 12; // ❌ Fatal Error: Cannot modify readonly property
```

### 3) `static` : membres partagés & usines

```php
class Counter {
  private static int $count = 0;       // partagé par toutes les instances
  public function __construct() { self::$count++; }
  public static function count(): int { return self::$count; } // méthode de classe
}

new Counter(); new Counter();
echo Counter::count(); // 2
```

> ⚠️ **Anti-pattern** : abuser d’un **état `static` mutable** complique les tests et introduit des effets de bord. Préférez des **services injectés**. Gardez `static` pour : **constantes**, **utilitaires purs**, **compteurs simples**, ou **usines** (`from...()`).

### 4) `self::` vs `static::` (Late Static Bindings)

```php
class Base {
  public static function who(): string { return 'Base'; }
  public static function make(): static { return new static(); } // LSB
  public function type(): string { return static::who(); }       // LSB
}

class Child extends Base {
  public static function who(): string { return 'Child'; }
}

echo (new Child())->type();            // "Child"
var_dump(Child::make() instanceof Child); // true
```

---

## 🔍 Exemple fil rouge (classe `Article` robuste)

On encapsule l’état d’un article (titre, slug, tags), avec :

* `id` **readonly**,
* titre **privé** et validé via `setTitle()`,
* `slug` dérivé du titre,
* `static` **compteur** + **usine** `fromTitle()`.

```php
<?php
declare(strict_types=1);

class Article {
  public readonly int $id;          // immuable après construction
  private string $title;            // encapsulé
  private string $slug;             // dérivé
  private array $tags = [];         // encapsulé

  private static int $count = 0;    // partagé

  public function __construct(int $id, string $title, array $tags = []) {
    if ($id <= 0) throw new InvalidArgumentException("id > 0 requis.");
    $this->id = $id;
    $this->setTitle($title);
    $this->tags = $tags;
    self::$count++;
  }

  /** Usine avec LSB : retournera la sous-classe correcte si appelée depuis elle */
  public static function fromTitle(int $id, string $title): static {
    return new static($id, $title);
  }

  /** Getters (API publique minimale) */
  public function title(): string { return $this->title; }
  public function slug(): string { return $this->slug; }
  public function tags(): array { return $this->tags; }

  /** Setter encapsulant validation + mise à jour du slug */
  public function setTitle(string $title): void {
    $title = trim($title);
    if ($title === '') throw new InvalidArgumentException("Titre requis.");
    $this->title = $title;
    $this->slug  = static::slugify($title);
  }

  public function addTag(string $tag): void {
    $t = trim($tag);
    if ($t === '') throw new InvalidArgumentException("Tag vide.");
    $this->tags[] = $t;
  }

  public static function count(): int { return self::$count; }

  /** Protégé : surcharge possible côté sous-classe */
  protected static function slugify(string $value): string {
    $s = strtolower($value);
    $s = preg_replace('/[^a-z0-9]+/i', '-', $s) ?? '';
    return trim($s, '-');
  }
}

/** Sous-classe : spécialisation via `protected` et LSB */
class FeaturedArticle extends Article {
  protected static function slugify(string $value): string {
    return 'featured-' . parent::slugify($value);
  }
}

// Démo
$a = Article::fromTitle(1, 'Encapsulation & visibilité en PHP');
$b = FeaturedArticle::fromTitle(2, 'Lire moins, comprendre plus');
$b->addTag('best');

echo $a->slug() . PHP_EOL; // "encapsulation-visibilite-en-php"
echo $b->slug() . PHP_EOL; // "featured-lire-moins-comprendre-plus"
echo Article::count() . PHP_EOL; // 2
```

---

## 🛠 Tutoriel pratique

**Arborescence :**

```
c3-php/chap-3-0-5/
└── encapsulation.php
```

### Étape 1 — Implémenter `encapsulation.php`

* Copiez le code de l’**exemple fil rouge** ci-dessus.
* Ajoutez un test : essayez de modifier `$a->id` après construction → **erreur `readonly`** attendue.

### Étape 2 — Exécuter

```bash
php c3-php/chap-3-0-5/encapsulation.php
```

### Étape 3 — Mini-adaptation fil rouge

* Ajoutez une méthode publique `toArray(): array` dans `Article` pour préparer l’**export JSON** (id, title, slug, tags).
* Créez un petit script qui **génère** un tableau de 3 articles via `fromTitle()` et **l’affiche** avec `print_r()` (préparation au chapitre JSON).

### Étape 4 — Challenge (N1+)

* Ajoutez une **contrainte d’unicité** du `slug` via un dépôt en mémoire :
  `ArticleRepository::save(Article $a)` lève `DomainException` si le `slug` existe déjà.
* Remplacez `self::$count` par une **statistique** maintenue dans le dépôt (pour éviter l’état `static` global).

---

## ✅ Bonnes pratiques

* **Par défaut, mettez `private`** aux propriétés ; exposez une **API claire**.
* Faites la **validation** dans les **constructeurs** et **mutateurs** (setters/méthodes métier).
* Utilisez **`readonly`** pour les identifiants et valeurs immuables.
* Limitez `static` (préférez **constantes** et **méthodes pures**).
* Pour l’héritage, **préférez la composition** ; si héritage, exploitez `protected` et LSB avec parcimonie.

---

## 🧾 Résumé

* `public`/`protected`/`private` contrôlent l’**accès** ; l’**encapsulation** protège vos invariants.
* `readonly` **verrouille** l’état après initialisation.
* `static` = **état partagé** : utile mais délicat (tests/effets de bord).
* LSB (`static::`) permet des **usines** qui respectent les sous-classes.

**Livrable attendu** : `encapsulation.php` fonctionnel, démontrant

* encapsulation + visibilité,
* propriété `readonly`,
* compteur/usine `static`,
* (option) surcharge `slugify()` en sous-classe,
* export `toArray()` prêt pour le JSON.

