---
title: 3. Exceptions
layout: home
nav_order: 3
parent: 3.0. Rappel PHP & POO
permalink: /php-poo/exceptions/
code: 3.0.3
competence: C3
autoformation: "C3.0"
ua: "3.0.U1"
duree_h: 1.5
objectif: "D√©tecter, intercepter et traiter proprement les erreurs (try/catch/finally, JSON_THROW_ON_ERROR, codes de sortie)."
notions_nouvelles: ["Throwable", "try/catch/finally", "JsonException", "JSON_THROW_ON_ERROR", "Code de sortie CLI"]
fil_rouge: "Robustesse des outils de seed (lecture JSON, validation minimale)"
livrable_chapitre: "`exceptions.php` + JSON de test + sorties STDOUT/STDERR avec exit code 0/1"
alimentation_prototype: "Messages d‚Äôerreurs clairs lors de la g√©n√©ration/lecture des donn√©es (N2)"
alimentation_miniprojet: "Gestion d‚Äôerreurs coh√©rente dans les scripts d‚Äôimport/seed (N3)"
---


# üìò  3.0.3 - Exceptions & gestion d‚Äôerreurs

## üìí Glossaire minute
- **Exception** : objet signalant une situation anormale que l‚Äôon peut **intercepter** et **traiter**.  
- **`Throwable`** : interface m√®re de **`Exception`** et **`Error`** (PHP 7+).  
- **`try` / `catch` / `finally`** : bloc d‚Äôex√©cution avec interception et √©tape finale garantie.  
- **Exceptions standard** : `RuntimeException`, `InvalidArgumentException`, `DomainException`, `JsonException`‚Ä¶  
- **Propagation / rethrow** : relancer l‚Äôexception apr√®s ajout de contexte.

---

## üéØ Objectif p√©dagogique
Savoir **d√©tecter**, **intercepter** et **traiter** proprement les erreurs en PHP moderne :
- utiliser `try/catch/finally`,  
- distinguer **`Exception`** vs **`Error`** (et quand **attraper `Throwable`**),  
- cr√©er des **exceptions m√©tier**,  
- s√©curiser **I/O fichiers** et **JSON** (avec `JSON_THROW_ON_ERROR`),  
- produire des **messages clairs** et des **codes de sortie** pour les scripts CLI.

---

## üß† D√©finition th√©orique (avec mini-exemples)

### 1) Hi√©rarchie & principes
```php
// Throwable (interface)
// ‚îú‚îÄ Error (type fatals, ex. TypeError)
// ‚îî‚îÄ Exception (toutes les exceptions classiques)
````

* On **attrape en priorit√©** des exceptions **sp√©cifiques**, puis plus g√©n√©rales.
* `Throwable` s‚Äôutilise surtout au **plus haut niveau** (ex. entr√©e d‚Äôun script CLI) pour √©viter un crash non contr√¥l√©.

### 2) `try` / `catch` / `finally`

```php
<?php
declare(strict_types=1);

function riskyDivide(int $a, int $b): float {
  if ($b === 0) {
    throw new InvalidArgumentException('Division par z√©ro interdite.');
  }
  return $a / $b;
}

try {
  echo riskyDivide(10, 0);
} catch (InvalidArgumentException $e) {
  echo "[WARN] " . $e->getMessage() . PHP_EOL;
} finally {
  echo "Toujours ex√©cut√© (lib√©ration de ressources, etc.)." . PHP_EOL;
}
```

### 3) Multi-catch & ordre des `catch`

```php
try {
  // ...
} catch (JsonException|InvalidArgumentException $e) {
  // traitement commun (ex. message + journalisation)
} catch (Exception $e) {
  // filet de s√©curit√© pour autres exceptions
}
```

> Placez les **catch sp√©cifiques avant** les g√©n√©riques.

### 4) Rethrow (ajout de contexte)

```php
function loadConfig(string $path): array {
  try {
    $json = file_get_contents($path);
    if ($json === false) {
      throw new RuntimeException("Lecture impossible: $path");
    }
    return json_decode($json, true, 512, JSON_THROW_ON_ERROR);
  } catch (JsonException $e) {
    throw new RuntimeException("JSON invalide dans $path", previous: $e);
  }
}
```

### 5) Conversions d‚Äôerreurs en exceptions (bonus)

```php
// Optionnel : convertir warnings/notice en ErrorException
set_error_handler(function (int $severity, string $message, string $file, int $line) {
  throw new ErrorException($message, 0, $severity, $file, $line);
});
```

---

## üîç Exemple fil rouge (seed JSON Articles)

Objectif : **charger** un fichier JSON d‚Äôarticles, **valider** quelques champs et **g√©rer les erreurs** proprement pour r√©utiliser ce code dans l‚Äôoutil `seed:articles`.

```php
<?php
declare(strict_types=1);

/** Valide un article minimal (titre + slug). */
function validateArticle(array $a): void {
  if (!isset($a['title']) || !is_string($a['title']) || $a['title'] === '') {
    throw new DomainException("Article invalide: 'title' requis.");
  }
  if (!isset($a['slug']) || !is_string($a['slug']) || $a['slug'] === '') {
    throw new DomainException("Article invalide: 'slug' requis.");
  }
}

/** Charge et d√©code un JSON en tableau associatif avec gestion d‚Äôerreurs. */
function loadJson(string $path): array {
  $raw = @file_get_contents($path);
  if ($raw === false) {
    throw new RuntimeException("Fichier introuvable ou illisible: $path");
  }

  try {
    /** @var array $data */
    $data = json_decode($raw, true, 512, JSON_THROW_ON_ERROR);
  } catch (JsonException $je) {
    throw new RuntimeException("JSON invalide: $path", previous: $je);
  }

  if (!is_array($data)) {
    throw new UnexpectedValueException("Le JSON doit contenir un tableau racine.");
  }
  return $data;
}

/** Point d‚Äôentr√©e CLI : attraper TOUT et retourner un code de sortie propre. */
function main(array $argv): int {
  $path = $argv[1] ?? 'storage/seeds/articles.input.json';

  $articles = loadJson($path);              // peut lever RuntimeException
  foreach ($articles as $i => $a) {
    validateArticle($a);                    // peut lever DomainException
  }

  echo "[OK] $path: " . count($articles) . " article(s) valides." . PHP_EOL;
  return 0;
}

try {
  exit(main($argv));
} catch (Throwable $e) {
  // Filet de s√©curit√© : message clair vers STDERR + code de sortie != 0
  fwrite(STDERR, "[ERR] " . $e->getMessage() . PHP_EOL);
  // Optionnel : contexte dev
  if ($e->getPrevious()) {
    fwrite(STDERR, "Cause: " . get_class($e->getPrevious()) . " ‚Äî " . $e->getPrevious()->getMessage() . PHP_EOL);
  }
  exit(1);
}
```

Points cl√©s :

* `loadJson()` isole les **I/O** et **d√©codage** JSON (avec `JSON_THROW_ON_ERROR`).
* `validateArticle()` concentre la **validation m√©tier** minimale.
* `main()` s√©pare la **logique** du **lancement CLI**.
* Bloc final `catch (Throwable $e)` √©vite les **crashs bruts** et garantit un **code de sortie**.

---

## üõ† Tutoriel pratique

**Arborescence :**

```
c3-php/chap-3-0-3/
‚îú‚îÄ‚îÄ exceptions.php
‚îî‚îÄ‚îÄ storage/seeds/articles.input.json
```

### √âtape 1 ‚Äî Pr√©parer un JSON de test

Cr√©ez `storage/seeds/articles.input.json` :

```json
[
  { "title": "Hello Exceptions", "slug": "hello-exceptions" },
  { "title": "", "slug": "invalide" }, 
  { "title": "Mauvais JSON"  // <- supprimez la virgule pour provoquer une erreur JSON
]
```

### √âtape 2 ‚Äî Impl√©menter `exceptions.php`

Collez le script **fil rouge** ci-dessus.

### √âtape 3 ‚Äî Ex√©cuter et observer

```bash
php c3-php/chap-3-0-3/exceptions.php storage/seeds/articles.input.json
# Corrigez le JSON puis relancez pour voir le message [OK] et le code de sortie 0.
```

### √âtape 4 ‚Äî Challenge (N1+)

* Ajoutez une **exception personnalis√©e** `class SeedException extends RuntimeException {}`
  et utilisez-la √† la place de `RuntimeException` pour les erreurs I/O.
* Journalisez les erreurs dans `storage/logs/seed.log` via `error_log($message, 3, 'storage/logs/seed.log');`.

---

## üßæ R√©sum√©

* **Attraper sp√©cifique d‚Äôabord**, g√©n√©rique ensuite ; `Throwable` uniquement au **plus haut niveau**.
* `JSON_THROW_ON_ERROR` + `JsonException` = **d√©codage s√ªr**.
* **Valider t√¥t** et **lancer des exceptions parlantes** (`DomainException`, `InvalidArgumentException`, etc.).
* **Toujours** retourner un **code de sortie** explicite en CLI (0 succ√®s, ‚â†0 erreur).

**Livrable attendu** :

* `exceptions.php` (ex√©cutable) avec gestion **`try/catch (Throwable)`** au top-level,
* un JSON de test,
* sorties **STDOUT/STDERR** et **codes de sortie** corrects (0 / 1).

