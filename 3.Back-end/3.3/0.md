---
title: 3.3.0 Introduction — Sécurité minimale, Auth & erreurs
layout: home
nav_order: 0
parent: 3. Back-end
permalink: /c3-3-securite-auth-erreurs/introduction/
---

# 📘 Chapitre 3.3.0 — Introduction

## 📒 Glossaire minute

- **Auth (Authentification)** : reconnaître **qui** est l’utilisateur (session/cookie).
- **Autorisation (Policy/Gate)** : décider **ce que** l’utilisateur **a le droit** de faire.
- **Middleware** : filtre exécuté avant/après une requête (ex. `auth`, `throttle`, CORS).
- **Throttle / Rate limit** : limite le **nombre** de requêtes par période.
- **CORS** : autorise/refuse l’accès cross-origin (ex. App Mobile → API).
- **`Handler` d’exceptions** : point central de formatage des **erreurs**.
- **Monolog / Channel** : système de **logs** (fichiers journaux) avec niveaux (`info`, `warning`, `error`).
- **401 / 403 / 404** : non authentifié / non autorisé / ressource introuvable.

## 🎯 Objectif pédagogique

À la fin du chapitre, vous saurez :

- activer une **authentification minimale** (session) et protéger des routes avec `auth`,
- créer et brancher une **Policy** sur `Article` (`viewAny`, `create`, `update`, `delete`),
- configurer **throttle** (limitation) et **CORS** pour l’API,
- **standardiser** la **réponse d’erreur JSON** (API) via le `Handler`,
- configurer des **logs** en rotation quotidienne et journaliser des événements.

## 🧠 Définition théorique

La sécurité minimale côté Laravel repose sur 3 couches complémentaires :

1) **Accès**  
   - *Authentification* (session par cookie) protège les zones privées (ex. `/dashboard`).  
   - *Autorisation* (Policy) précise, **au niveau métier**, qui peut faire quoi (ex. “un auteur ne peut modifier **que ses** articles”).

2) **Robustesse API**  
   - *Throttle* freine les abus.  
   - *CORS* ouvre le **domaine API** à des clients de confiance (future app Mobile).  
   - *Réponses d’erreurs cohérentes* (JSON) permettent au client d’afficher des messages clairs.

3) **Observabilité**  
   - *Logs* (niveau, canal, rotation) tracent les événements pour diagnostiquer vite.

## 🔍 Exemple appliqué au fil rouge

- **Web (session)** : *Dashboard auteur* (`/dashboard`) réservé aux utilisateurs connectés.  
- **Policy `Article`** : un auteur peut **éditer/supprimer** **ses** articles, pas ceux des autres.  
- **API v1** : `/api/articles` GET public, mais POST/PUT/DELETE protégés (on y vient plus tard).  
- **Erreur JSON uniforme** :
  ```json
  {
    "ok": false,
    "error": { "code": "FORBIDDEN", "message": "Action non autorisée." }
  }
````

## 🛠 Tutoriel pratique

> Prérequis : projet **blog-laravel** des autoformations C3.1–C3.2 (Articles CRUD + API GET).

**Arborescence (extrait)**

```
blog-laravel/
├─ app/
│  ├─ Exceptions/Handler.php
│  ├─ Http/Controllers/AuthController.php
│  ├─ Policies/ArticlePolicy.php
│  └─ Providers/{AuthServiceProvider.php,RouteServiceProvider.php}
├─ config/{cors.php,logging.php}
├─ database/seeders/UserSeeder.php
├─ resources/views/{auth/login.blade.php,dashboard.blade.php}
├─ routes/{web.php,api.php}
└─ .env
```

### Étape 1 — Créer un utilisateur auteur (Seeder)

```php
// database/seeders/UserSeeder.php
<?php

namespace Database\Seeders;

use App\Models\User;
use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\Hash;

class UserSeeder extends Seeder
{
    public function run(): void
    {
        User::updateOrCreate(
            ['email' => 'auteur@example.com'],
            ['name' => 'Auteur Démo', 'password' => Hash::make('password')]
        );
    }
}
```

```bash
php artisan db:seed --class=UserSeeder
```

### Étape 2 — Authentification minimale (session)

**Routes & contrôleur**

```php
// routes/web.php
use App\Http\Controllers\AuthController;
use Illuminate\Support\Facades\Route;

Route::get('/login', [AuthController::class, 'loginForm'])->name('login');
Route::post('/login', [AuthController::class, 'login'])->name('login.post');
Route::post('/logout', [AuthController::class, 'logout'])->name('logout');

Route::middleware('auth')->group(function () {
    Route::view('/dashboard', 'dashboard')->name('dashboard');
    // Ex.: routes d’admin articles protégées ici
});
```

```php
// app/Http/Controllers/AuthController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

class AuthController extends Controller
{
    public function loginForm()
    {
        return view('auth.login');
    }

    public function login(Request $request)
    {
        $credentials = $request->validate([
            'email'    => ['required','email'],
            'password' => ['required'],
        ]);

        if (Auth::attempt($credentials, remember: true)) {
            $request->session()->regenerate();
            return redirect()->intended(route('dashboard'));
        }

        return back()->withErrors(['email' => 'Identifiants invalides.']);
    }

    public function logout(Request $request)
    {
        Auth::logout();
        $request->session()->invalidate();
        $request->session()->regenerateToken();
        return redirect('/login');
    }
}
```

**Vue de connexion**

```html
<!-- resources/views/auth/login.blade.php -->
<!doctype html>
<html lang="fr">
  <body>
    <h1>Connexion</h1>
    @if ($errors->any())
      <div>{{ $errors->first() }}</div>
    @endif
    <form method="POST" action="{{ route('login.post') }}">
      @csrf
      <label>Email <input type="email" name="email" required></label>
      <label>Mot de passe <input type="password" name="password" required></label>
      <button type="submit">Se connecter</button>
    </form>
  </body>
</html>
```

```html
<!-- resources/views/dashboard.blade.php -->
<h1>Dashboard auteur</h1>
<form method="POST" action="{{ route('logout') }}">@csrf<button>Se déconnecter</button></form>
```

### Étape 3 — Policy `Article` (autorisation)

```bash
php artisan make:policy ArticlePolicy --model=App\\Models\\Article
```

```php
// app/Policies/ArticlePolicy.php
<?php

namespace App\Policies;

use App\Models\Article;
use App\Models\User;

class ArticlePolicy
{
    public function viewAny(?User $user): bool { return true; }

    public function create(User $user): bool { return true; }

    public function update(User $user, Article $article): bool
    {
        return $article->user_id === $user->id;
    }

    public function delete(User $user, Article $article): bool
    {
        return $article->user_id === $user->id;
    }
}
```

```php
// app/Providers/AuthServiceProvider.php
protected $policies = [
    \App\Models\Article::class => \App\Policies\ArticlePolicy::class,
];
```

**Usage dans un contrôleur**

```php
// app/Http/Controllers/ArticleController.php (extrait)
public function edit(Article $article)
{
    $this->authorize('update', $article);
    // ...
}
public function destroy(Article $article)
{
    $this->authorize('delete', $article);
    // ...
}
```

### Étape 4 — Throttle & CORS (API)

**Limiter le débit API**

```php
// app/Providers/RouteServiceProvider.php (boot)
use Illuminate\Cache\RateLimiting\Limit;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\RateLimiter;

RateLimiter::for('api', function (Request $request) {
    return Limit::perMinute(60)->by($request->user()?->id ?: $request->ip());
});
```

```php
// routes/api.php
use Illuminate\Support\Facades\Route;

Route::middleware(['throttle:api'])->group(function () {
    Route::get('/articles', /* ... */);
    Route::get('/articles/{id}', /* ... */);
});
```

**Configurer CORS (ouvrir l’API au client Mobile/local)**

```php
// config/cors.php (extraits à ajuster)
'paths' => ['api/*'],
'allowed_origins' => ['http://localhost:3000','http://10.0.2.2:3000','*'], // adapter si besoin
'allowed_methods' => ['*'],
'allowed_headers' => ['*'],
'supports_credentials' => false,
```

### Étape 5 — Format d’erreur JSON uniforme (Handler)

```php
// app/Exceptions/Handler.php (extrait)
use Illuminate\Auth\AuthenticationException;
use Illuminate\Auth\Access\AuthorizationException;
use Illuminate\Database\Eloquent\ModelNotFoundException;
use Illuminate\Validation\ValidationException;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;

protected function shouldReturnJson($request, \Throwable $e): bool
{
    return $request->is('api/*') || $request->expectsJson();
}

public function render($request, \Throwable $e)
{
    if ($this->shouldReturnJson($request, $e)) {
        $payload = fn(string $code, string $message, $details = null) => [
            'ok' => false,
            'error' => ['code' => $code, 'message' => $message, 'details' => $details],
        ];

        if ($e instanceof ValidationException) {
            return response()->json($payload('VALIDATION_ERROR', 'Données invalides.', $e->errors()), 422);
        }
        if ($e instanceof AuthenticationException) {
            return response()->json($payload('UNAUTHENTICATED', 'Authentification requise.'), 401);
        }
        if ($e instanceof AuthorizationException) {
            return response()->json($payload('FORBIDDEN', 'Action non autorisée.'), 403);
        }
        if ($e instanceof ModelNotFoundException || $e instanceof NotFoundHttpException) {
            return response()->json($payload('NOT_FOUND', 'Ressource introuvable.'), 404);
        }

        // Fallback
        return response()->json($payload('SERVER_ERROR', 'Erreur interne.'), 500);
    }

    return parent::render($request, $e);
}
```

### Étape 6 — Logs (rotation quotidienne) + journaliser un événement

**.env**

```env
LOG_CHANNEL=daily
LOG_LEVEL=warning
```

*(par défaut `daily` conserve 14 jours ; ajustable via `config/logging.php`)*

**Exemple de log en contrôleur**

```php
use Illuminate\Support\Facades\Log;

public function update(Request $request, Article $article)
{
    $this->authorize('update', $article);

    $validated = $request->validate([
        'title' => ['required','string','max:180'],
        'content' => ['required','string','min:50'],
    ]);

    $article->update($validated);

    Log::info('Article mis à jour', ['article_id' => $article->id, 'user_id' => $request->user()->id]);

    return redirect()->route('dashboard');
}
```

## 🧾 Résumé et points-clés

* **Session** + middleware `auth` pour protéger `/dashboard` et l’admin.
* **Policy `Article`** : règles d’accès **métier** centralisées (ex. auteur propriétaire).
* **API** plus robuste : **`throttle:api`** + **CORS** configuré.
* **Erreurs JSON** standardisées via le **`Handler`** (401/403/404/422/500).
* **Logs** en **rotation quotidienne** pour diagnostiquer rapidement.

> Prochaines étapes (C3.3) : détailler chaque brique — *Middlewares clés*, *Policy Article*, *Handler d’exceptions*, *Logs centralisés* — puis livrer le **Dashboard auteur sécurisé** + **format d’erreur JSON** uniforme pour l’API.

```
```
