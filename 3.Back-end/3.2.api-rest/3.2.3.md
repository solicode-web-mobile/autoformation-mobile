---
title: 3. Resource & Collection
layout: home
nav_order: 3
parent: 3.2. API REST
permalink: /api-rest/resource-collection/
code: 3.2.3
competence: C3
autoformation: "C3.2"
ua: "3.2.U2"
duree_h: 2
objectif: "Normaliser les r√©ponses API avec Resource et ResourceCollection."
notions_nouvelles: ["Resource", "ResourceCollection", "when()/whenLoaded()", "additional()", "preserveKeys()"]
fil_rouge: "Blog Laravel + App Mobile (format JSON stable pour consommation mobile)"
livrable_chapitre: "`ArticleResource` et `ArticleCollection` avec meta/links"
alimentation_prototype: "JSON homog√®ne exploitable par l‚ÄôUI mobile (N2)"
alimentation_miniprojet: "Contrat stable et testable pour l‚ÄôAPI du mini-projet N3"
---

# üìò  3.2.3 - `Resource` & `ResourceCollection` 

## üìí Glossaire minute

* **Resource** : classe qui **formate une entit√©** (un article) en JSON stable.
* **ResourceCollection** : classe (ou `Resource::collection(...)`) qui **formate une liste**.
* **`when()` / `whenLoaded()`** : inclure des champs **conditionnellement**.
* **`additional()` / `with()`** : ajouter **`meta`** et **`links`** au JSON.
* **`preserveKeys()`** : conserver les cl√©s de collection si n√©cessaire.

## üéØ Objectifs p√©dagogiques

* Cr√©er une **`ArticleResource`** claire, sans fuite de champs internes.
* Renvoyer une **collection pagin√©e** avec `data`, `meta`, `links` **coh√©rents**.
* G√©rer les **relations** et les **champs optionnels** proprement.

## ‚úÖ Pr√©-requis

* Routes **API** (3.2.1) et **pagination/tri/filtres** (3.2.2).
* Mod√®le `Article` (+ relation `tags` si disponible).

---

## 1) G√©n√©rer la Resource

```bash
php artisan make:resource ArticleResource
```

Structure (exemple) : `app/Http/Resources/ArticleResource.php`.

### Impl√©mentation de base

```php
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class ArticleResource extends JsonResource
{
    /**
     * Transform the resource into an array.
     * @return array<string, mixed>
     */
    public function toArray(Request $request): array
    {
        return [
            'id'            => $this->id,
            'title'         => $this->title,
            'slug'          => $this->slug,
            'excerpt'       => $this->excerpt,
            'content'       => $this->when($request->routeIs('api.articles.show'), $this->content),
            'author'        => $this->author, // ou $this->author->name si relation
            'published_at'  => $this->published_at?->toISOString(),
            // Relations charg√©es uniquement si pr√©sentes (√©vite N+1 et JSON vide)
            'tags'          => $this->whenLoaded('tags', fn () => $this->tags->pluck('name')->values()),
        ];
    }

    /**
     * Meta/links communs (fusionn√©s au top-level).
     */
    public function with(Request $request): array
    {
        return [
            'meta' => [
                'api_version' => '1.0',
                'resource'    => 'article',
            ],
        ];
    }
}
```

> Points cl√©s
>
> * **Pas de champs internes** (ex. `created_at`, `updated_at`, `user_id`) sauf si utiles c√¥t√© client.
> * **Dates ISO 8601** (`toISOString()`) pour la lisibilit√© et la compatibilit√©.
> * **`when()`** limite `content` au **show** (d√©tail) pour **all√©ger** la liste.

---

## 2) Renvoyer une collection pagin√©e coh√©rente

Chemin rapide (recommand√©) : **`ArticleResource::collection($paginator)`** + `additional(...)`.

```php
<?php

namespace App\Http\Controllers\Api;

use App\Models\Article;
use Illuminate\Http\Request;
use App\Http\Controllers\Controller;
use App\Http\Resources\ArticleResource;

class ArticleApiController extends Controller
{
    public function index(Request $request)
    {
        $q       = trim((string) $request->query('q', ''));
        $tag     = $request->query('tag');
        $sort    = $request->query('sort', '-published_at');
        $perPage = (int) $request->query('per_page', 10);

        $query = Article::query()
            ->with('tags')
            ->when($q, fn ($qq) => $qq->where(fn ($w) =>
                $w->where('title', 'like', "%$q%")
                  ->orWhere('excerpt', 'like', "%$q%")
                  ->orWhere('content', 'like', "%$q%")
            ))
            ->when($tag, fn ($qq) => $qq->whereHas('tags', fn ($tq) => $tq->where('name', $tag)));

        // Tri minimal (title, published_at) ; signe '-' = DESC
        $direction = str_starts_with($sort, '-') ? 'desc' : 'asc';
        $column    = ltrim($sort, '-');
        if (! in_array($column, ['title','published_at'], true)) {
            $column = 'published_at';
            $direction = 'desc';
        }
        $query->orderBy($column, $direction);

        $paginator = $query->paginate($perPage)->appends($request->query());

        return ArticleResource::collection($paginator)->additional([
            'meta'  => [
                'page'     => $paginator->currentPage(),
                'per_page' => $paginator->perPage(),
                'total'    => $paginator->total(),
                'sort'     => ($direction === 'desc' ? '-' : '').$column,
                'filters'  => array_filter(['q' => $q, 'tag' => $tag]),
            ],
            'links' => [
                'self' => $request->fullUrl(),
                'next' => $paginator->nextPageUrl(),
                'prev' => $paginator->previousPageUrl(),
            ],
        ]);
    }

    public function show(Request $request, Article $article)
    {
        $article->loadMissing('tags');

        return new ArticleResource($article);
    }
}
```

R√©sultat (liste) :

```json
{
  "data": [
    {
      "id": 12,
      "title": "Pagination & filtres",
      "slug": "pagination-filtres",
      "excerpt": "R√©sum√©‚Ä¶",
      "author": "Sara",
      "published_at": "2025-08-20T10:23:00Z",
      "tags": ["Laravel","MySQL"]
    }
  ],
  "meta": { "page":1, "per_page":10, "total":42, "sort":"-published_at", "filters":{"q":"eloquent"} },
  "links": { "self":".../api/articles?page=1", "next":".../api/articles?page=2", "prev": null }
}
```

---

## 3) Option : classe d√©di√©e `ArticleCollection`

Utile si vous voulez encapsuler la logique `meta/links` dans une **classe**.

```bash
php artisan make:resource ArticleCollection
```

```php
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\ResourceCollection;

class ArticleCollection extends ResourceCollection
{
    public $collects = ArticleResource::class;

    public function toArray(Request $request): array
    {
        return [
            'data' => $this->collection,
        ];
    }

    public function with(Request $request): array
    {
        $p = $this->resource; // Paginator|LengthAwarePaginator
        return [
            'meta' => [
                'page'     => method_exists($p, 'currentPage') ? $p->currentPage() : null,
                'per_page' => method_exists($p, 'perPage')     ? $p->perPage()     : null,
                'total'    => method_exists($p, 'total')       ? $p->total()       : null,
            ],
            'links' => [
                'self' => $request->fullUrl(),
                'next' => method_exists($p, 'nextPageUrl')     ? $p->nextPageUrl()     : null,
                'prev' => method_exists($p, 'previousPageUrl') ? $p->previousPageUrl() : null,
            ],
        ];
    }
}
```

Controller (index) :

```php
return (new ArticleCollection($paginator));
```

---

## 4) Champs conditionnels, includes & formats

### `when()` / `mergeWhen()`

```php
'reading_time' => $this->when($this->content, fn () =>
    max(1, (int) ceil(str_word_count(strip_tags($this->content)) / 200))
),

$this->mergeWhen($request->boolean('debug'), [
    'debug' => ['id_internal' => $this->getKey()]
]);
```

### `whenLoaded()` (relations)

```php
'comments_count' => $this->whenLoaded('comments', fn () => $this->comments->count()),
'author'         => $this->whenLoaded('author', fn () => [
    'name' => $this->author->name,
]),
```

> Charger en amont :
> `Article::with(['tags','author'])->paginate(...)`

### Format des dates

```php
'published_at' => $this->published_at?->toISOString(), // ISO 8601 (recommand√©)
```

---

## 5) Tests de structure (exemples)

```php
public function test_index_returns_normalized_collection()
{
    $resp = $this->getJson('/api/articles?page=1');
    $resp->assertOk()
         ->assertJsonStructure([
             'data' => [
                 ['id','title','slug','excerpt','author','published_at']
             ],
             'meta'  => ['page','per_page','total','sort','filters'],
             'links' => ['self','next','prev'],
         ]);
}
```

---

## üß≠ Bonnes pratiques

* **Un seul endroit** pour le formatage : `Resource` (√©vite les `->toArray()` artisanaux dans le contr√¥leur).
* **Nommez** les cl√©s de mani√®re **stable** (ex. `published_at`, pas `pubAt`).
* **Cache** c√¥t√© client possible car la **forme** du JSON ne change pas.
* **√âvitez** d‚Äôexposer des IDs/colonnes internes non n√©cessaires.

---

## üß∞ Exercices

### (N1 ‚Äì Imitation)

* Cr√©ez `ArticleResource` et exposez : `id`, `title`, `slug`, `excerpt`, `author`, `published_at`, `tags[]`.
* Branchez `ArticleResource::collection($paginator)` et ajoutez `meta/links` via `additional()`.

### (N2 ‚Äì Adaptation)

* Ajoutez `reading_time` (200 mots/min).
* N‚Äôexposez `content` **que** sur `show`.
* Ajoutez `?include=author,tags` pour charger conditionnellement `author` et `tags` (c√¥t√© contr√¥leur : parsez `include` et faites des `with()` dynamiques).

### (N3 ‚Äì Transposition)

* Cr√©ez `UserResource` + `UserCollection` et normalisez `/api/users`.
* Mettez en place des **tests** qui verrouillent la **forme JSON** (structure + types).

---

## üßæ R√©sum√©

* **`Resource`** normalise **une entit√©**, **`ResourceCollection`** normalise **une liste**.
* Utilisez `when()`/`whenLoaded()` pour garder un JSON **l√©ger** et **pertinent**.
* Renvoyez **toujours** `data` + `meta` + `links` pour les listes pagin√©es.
* Le **contrat** devient **pr√©visible** et **facile √† consommer** c√¥t√© Mobile.
