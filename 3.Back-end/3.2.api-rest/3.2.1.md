---
title: 1. Routes API & JSON
layout: home
nav_order: 1
parent: 3.2. API REST
permalink: /api-rest/routes-json/
---

# üìò  3.2.1 - Routes API & JSON

## üìí Glossaire minute
- **Endpoint** : URL d‚Äôune ressource (ex. `GET /api/articles`).
- **Verbe HTTP** : `GET`, `POST`, `PUT/PATCH`, `DELETE`.
- **Code HTTP** : statut de la r√©ponse (`200` OK, `201` Created, `204` No Content, `404` Not Found, `422` Unprocessable Content‚Ä¶).
- **Header** : m√©tadonn√©e de la r√©ponse (ex. `Content-Type: application/json`, `Location: /api/articles/{slug}`).
- **Envelope JSON** : structure r√©guli√®re des r√©ponses, ex. `{ data, meta, error }`.

---

## üéØ Objectifs p√©dagogiques
√Ä la fin du chapitre, vous saurez :
1. D√©clarer des **routes API** dans `routes/api.php` (nommage coh√©rent).  
2. Retourner des **r√©ponses JSON** correctes (contenu + **codes HTTP**).  
3. Esquisser une **envelope** uniforme de r√©ponse (succ√®s/erreur) ‚Äî la **normalisation fine** avec `Resource/Collection` viendra au chap. **3.2.3**.  

---

## üß± Pr√©-requis
- Mod√®le **Article** + migration/seed/`slug` (chap. **3.1.5**).  
- Serveur dev : `php artisan serve` (les routes API sont pr√©fix√©es automatiquement par `/api`).  
- Outil d‚Äôappel HTTP (curl, HTTPie, Postman/Insomnia).

---

## üõ†Ô∏è Tutoriel guid√© (pas √† pas)

### 1) D√©clarer les routes API
`routes/api.php`
```php
<?php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\Api\ArticleController;

// Regroupe sous /api/articles (prefixe /api implicite via RouteServiceProvider)
Route::apiResource('articles', ArticleController::class)
    ->names('api.articles');
// Gr√¢ce √† getRouteKeyName() = 'slug' dans le mod√®le, {article} r√©sout par le slug.
````

> V√©rifier :
>
> ```bash
> php artisan route:list --path=api
> ```

---

### 2) G√©n√©rer le contr√¥leur API

```bash
php artisan make:controller Api/ArticleController --api
```

`app/Http/Controllers/Api/ArticleController.php`

```php
<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Models\Article;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\Validation\ValidationException;
use Symfony\Component\HttpFoundation\Response as Http;

class ArticleController extends Controller
{
    // ------- Helpers de r√©ponse (v1 minimal avant Resources 3.2.3) -------
    private function ok(mixed $data, array $meta = [], int $status = Http::HTTP_OK): JsonResponse
    {
        return response()->json(['data' => $data, 'meta' => (object)$meta], $status);
    }

    private function created(mixed $data, string $location): JsonResponse
    {
        return response()
            ->json(['data' => $data, 'meta' => (object)[]], Http::HTTP_CREATED)
            ->header('Location', $location);
    }

    private function error(int $status, string $message, array $details = []): JsonResponse
    {
        return response()->json([
            'error' => ['code' => $status, 'message' => $message, 'details' => (object)$details]
        ], $status);
    }
    // ---------------------------------------------------------------------

    // GET /api/articles
    public function index(Request $request): JsonResponse
    {
        // v1 minimal : liste des 10 derniers publi√©s (pagination/filters au chap. 3.2.2)
        $items = Article::query()
            ->where('published', true)
            ->latest('id')
            ->limit(10)
            ->get(['id', 'title', 'slug', 'views', 'published', 'created_at']);

        return $this->ok($items, [
            'count' => $items->count(),
            'hint'  => 'Pagination & filtres arrivent au chap. 3.2.2',
        ]);
    }

    // GET /api/articles/{article} (binding par slug)
    public function show(Article $article): JsonResponse
    {
        if (! $article->published) {
            // 404 pour ne pas r√©v√©ler les non-publi√©s
            return $this->error(Http::HTTP_NOT_FOUND, 'Article introuvable');
        }
        return $this->ok([
            'id'        => $article->id,
            'title'     => $article->title,
            'slug'      => $article->slug,
            'excerpt'   => $article->excerpt,
            'views'     => $article->views,
            'published' => (bool) $article->published,
            'createdAt' => $article->created_at?->toISOString(),
        ]);
    }

    // POST /api/articles
    public function store(Request $request): JsonResponse
    {
        try {
            $data = $request->validate([
                'title'     => ['required', 'string', 'max:255'],
                'excerpt'   => ['nullable', 'string'],
                'views'     => ['nullable', 'integer', 'min:0'],
                'published' => ['nullable', 'boolean'],
            ]);
        } catch (ValidationException $e) {
            // 422 - structure minimale (unifi√©e au chap. 3.3.x via Handler)
            return $this->error(Http::HTTP_UNPROCESSABLE_ENTITY, 'Validation error', $e->errors());
        }

        $article = new Article();
        $article->fill([
            'title'     => $data['title'],
            'excerpt'   => $data['excerpt'] ?? null,
            'views'     => $data['views'] ?? 0,
            'published' => $data['published'] ?? true,
        ]);
        // slug auto simple (√† am√©liorer si doublons)
        $article->slug = \Str::slug($article->title);
        $article->save();

        return $this->created(
            [
                'id'    => $article->id,
                'title' => $article->title,
                'slug'  => $article->slug,
            ],
            route('api.articles.show', $article) // Location header
        );
    }

    // PUT/PATCH /api/articles/{article}
    public function update(Request $request, Article $article): JsonResponse
    {
        try {
            $data = $request->validate([
                'title'     => ['sometimes', 'string', 'max:255'],
                'excerpt'   => ['sometimes', 'nullable', 'string'],
                'views'     => ['sometimes', 'integer', 'min:0'],
                'published' => ['sometimes', 'boolean'],
            ]);
        } catch (ValidationException $e) {
            return $this->error(Http::HTTP_UNPROCESSABLE_ENTITY, 'Validation error', $e->errors());
        }

        $article->fill($data);
        if (array_key_exists('title', $data)) {
            $article->slug = \Str::slug($article->title);
        }
        $article->save();

        return $this->ok(['id' => $article->id, 'slug' => $article->slug]);
    }

    // DELETE /api/articles/{article}
    public function destroy(Article $article): JsonResponse
    {
        $article->delete();

        // 204 No Content : pas de body
        return response()->json(null, Http::HTTP_NO_CONTENT);
    }
}
```

---

### 3) Exemples d‚Äôappels (curl)

**Lister** (200 OK)

```bash
curl -s http://localhost:8000/api/articles \
  -H "Accept: application/json"
```

**D√©tail** (200 OK)

```bash
curl -s http://localhost:8000/api/articles/intro-laravel \
  -H "Accept: application/json"
```

**Cr√©er** (201 Created + `Location`)

```bash
curl -i -X POST http://localhost:8000/api/articles \
  -H "Accept: application/json" -H "Content-Type: application/json" \
  -d '{"title":"Nouveaut√©s Laravel","excerpt":"Tour rapide","published":true}'
```

**Mettre √† jour** (200 OK)

```bash
curl -s -X PATCH http://localhost:8000/api/articles/intro-laravel \
  -H "Accept: application/json" -H "Content-Type: application/json" \
  -d '{"views": 250}'
```

**Supprimer** (204 No Content)

```bash
curl -i -X DELETE http://localhost:8000/api/articles/intro-laravel \
  -H "Accept: application/json"
```

---

## üì¶ Structure JSON attendue (v1 minimale)

### Succ√®s (liste)

```json
{
  "data": [
    { "id": 4, "title": "Validation FormRequest", "slug": "validation-formrequest", "views": 210, "published": true, "created_at": "..." }
  ],
  "meta": { "count": 1, "hint": "Pagination & filtres arrivent au chap. 3.2.2" }
}
```

### Succ√®s (cr√©ation)

```json
{
  "data": { "id": 7, "title": "Nouveaut√©s Laravel", "slug": "nouveautes-laravel" },
  "meta": {}
}
```

`Location: /api/articles/nouveautes-laravel`

### Erreur 404

```json
{
  "error": { "code": 404, "message": "Article introuvable", "details": {} }
}
```

### Erreur 422 (validation)

```json
{
  "error": {
    "code": 422,
    "message": "Validation error",
    "details": { "title": ["The title field is required."] }
  }
}
```

> ‚ÑπÔ∏è Au **chap. 3.2.3**, on remplace les tableaux bruts par des **Resources/Collections** pour une normalisation propre.
> Au **chap. 3.3.x**, on **unifie** les erreurs via le **Handler** (exceptions, logs).

---

## üß™ Exercice guid√© (livrable N1)

> **But** : ajouter un endpoint **`HEAD /api/articles/{slug}`** qui renvoie `200` si l‚Äôarticle publi√© existe, sinon `404`, **sans body**.
>
> **Exigences**
>
> 1. D√©clarer la route `Route::head('articles/{article}', ...)`.
> 2. Utiliser le **binding** par slug (`Article $article`).
> 3. Retourner `204` si non publi√© (ou `404` selon votre politique ‚Äî justifiez votre choix).
> 4. Ajouter le header `Cache-Control: no-store`.

---

## ‚úÖ Crit√®res de r√©ussite

* Les endpoints CRUD renvoient les **codes** appropri√©s (`200/201/204/404/422`).
* Les **headers** essentiels sont pr√©sents (`Content-Type: application/json`, `Location` apr√®s POST).
* Les r√©ponses pr√©sentent une **envelope** r√©guli√®re `{ data/meta | error }`.
* Les appels `curl` fonctionnent localement.

---

## ‚ö†Ô∏è Erreurs fr√©quentes

* R√©pondre `200` apr√®s une cr√©ation ‚Üí pr√©f√©rez **`201 Created` + `Location`**.
* Retourner un body avec **`204 No Content`**.
* Ne pas d√©finir `Accept: application/json` lors des tests ‚Üí r√©ponses HTML inattendues.
* Exposer des articles **non publi√©s** par inadvertance (filtrez ou renvoyez `404`).

---

## üßæ R√©sum√©

Vous avez pos√© les bases d‚Äôune **API REST** : **routes**, **codes HTTP** corrects, **envelope JSON** minimale. Prochaine √©tape : **3.2.2 ‚Äî Pagination & filtres** (query `page`, `q`, `sort`, etc.), puis **3.2.3 ‚Äî Resource/ResourceCollection** pour une normalisation propre.
