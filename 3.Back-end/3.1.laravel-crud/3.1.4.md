---
title: 4. Validation
layout: home
nav_order: 4
parent: 3.1. CRUD avec Laravel
permalink: /laravel-crud/validation-formrequest/
---

# ğŸ“˜  3.1.4 - Validation avec **FormRequest**

## ğŸ“’ Glossaire minute

* **FormRequest** : classe dÃ©diÃ©e qui **encapsule la validation** et lâ€™autorisation dâ€™une requÃªte.
* **`rules()`** : renvoie les **rÃ¨gles** de validation.
* **`messages()`** : **messages personnalisÃ©s** dâ€™erreur.
* **`attributes()`** : alias lisibles pour les **noms de champs**.
* **`validated()`** : donnÃ©es **nettoyÃ©es** aprÃ¨s validation.
* **`prepareForValidation()`** : hook pour **normaliser** les inputs avant validation.
* **`Rule`** : rÃ¨gles avancÃ©es (ex. `Rule::unique()->ignore(...)`).

## ğŸ¯ Objectifs pÃ©dagogiques

* CrÃ©er des **FormRequest** pour `store` et `update` dâ€™Article.
* Ã‰crire des **rÃ¨gles prÃ©cises** (chaÃ®nes, dates, tableaux, unicitÃ©).
* Personnaliser **messages** et **noms dâ€™attributs**.
* **Brancher** la validation dans le contrÃ´leur et **afficher** les erreurs en Blade.

## âœ… PrÃ©-requis

* Chapitres **3.1.1 â†’ 3.1.3** (routes, contrÃ´leurs, Blade, formulaires).
* ModÃ¨le `Article` + migration basique (titre, slug, contenu, etc.).

---

## 1) GÃ©nÃ©rer les FormRequest

```bash
php artisan make:request StoreArticleRequest
php artisan make:request UpdateArticleRequest
```

Deux fichiers sont crÃ©Ã©s dans `app/Http/Requests/`.

---

## 2) `StoreArticleRequest` (crÃ©ation)

```php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Support\Str;

class StoreArticleRequest extends FormRequest
{
    public function authorize(): bool
    {
        // Ici: autoriser tout le monde (ex. back-office protÃ©gÃ© par middleware).
        return true;
    }

    protected function prepareForValidation(): void
    {
        // Auto-gÃ©nÃ©rer le slug Ã  partir du titre si absent
        $this->merge([
            'slug' => $this->input('slug') ?: Str::slug((string) $this->input('title'))
        ]);
    }

    public function rules(): array
    {
        return [
            'title'        => ['bail','required','string','max:160'],
            'slug'         => ['required','alpha_dash','max:180','unique:articles,slug'],
            'excerpt'      => ['nullable','string','max:180'],
            'content'      => ['required','string','min:50'],
            'published_at' => ['nullable','date'],
            'tags'         => ['nullable','array','max:5'],
            'tags.*'       => ['string','distinct','max:20'],
        ];
    }

    public function messages(): array
    {
        return [
            'title.required'   => 'Le titre est obligatoire.',
            'slug.unique'      => 'Ce slug est dÃ©jÃ  utilisÃ©, merci dâ€™en choisir un autre.',
            'content.min'      => 'Le contenu doit contenir au moins :min caractÃ¨res.',
            'tags.array'       => 'Le format des tags est invalide.',
            'tags.*.distinct'  => 'Les tags doivent Ãªtre uniques.',
        ];
    }

    public function attributes(): array
    {
        return [
            'title'   => 'titre',
            'slug'    => 'slug',
            'content' => 'contenu',
            'tags.*'  => 'tag',
        ];
    }
}
```

> Notes
>
> * `bail` stoppe la validation **au premier Ã©chec** du champ.
> * `prepareForValidation()` garantit un **slug cohÃ©rent** mÃªme si le champ nâ€™est pas rempli.

---

## 3) `UpdateArticleRequest` (modification)

Ici, la rÃ¨gle dâ€™unicitÃ© du `slug` doit **ignorer lâ€™article courant**.

```php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;
use Illuminate\Support\Str;

class UpdateArticleRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    protected function prepareForValidation(): void
    {
        $this->merge([
            'slug' => $this->input('slug') ?: Str::slug((string) $this->input('title'))
        ]);
    }

    public function rules(): array
    {
        $article = $this->route('article'); // Model-binded via route:articles.update

        return [
            'title'        => ['bail','required','string','max:160'],
            'slug'         => [
                'required','alpha_dash','max:180',
                Rule::unique('articles','slug')->ignore($article)
            ],
            'excerpt'      => ['nullable','string','max:180'],
            'content'      => ['required','string','min:50'],
            'published_at' => ['nullable','date'],
            'tags'         => ['nullable','array','max:5'],
            'tags.*'       => ['string','distinct','max:20'],
        ];
    }

    public function messages(): array
    {
        return [
            'slug.unique' => 'Ce slug est dÃ©jÃ  pris par un autre article.',
        ];
    }

    public function attributes(): array
    {
        return [
            'title' => 'titre',
            'slug'  => 'slug',
        ];
    }
}
```

---

## 4) Utilisation cÃ´tÃ© contrÃ´leur

```php
<?php

namespace App\Http\Controllers;

use App\Models\Article;
use App\Http\Requests\StoreArticleRequest;
use App\Http\Requests\UpdateArticleRequest;

class ArticleController extends Controller
{
    public function store(StoreArticleRequest $request)
    {
        $article = Article::create($request->validated());

        return redirect()
            ->route('articles.edit', $article)
            ->with('success', 'Article crÃ©Ã© avec succÃ¨s.');
    }

    public function update(UpdateArticleRequest $request, Article $article)
    {
        $article->update($request->validated());

        return redirect()
            ->route('articles.edit', $article)
            ->with('success', 'Article mis Ã  jour.');
    }
}
```

> Astuce : `validated()` renvoie **uniquement** les champs passÃ©s par la validation.

---

## 5) Afficher les erreurs dans Blade

### 5.1 Champs avec `old()` et `@error`

{% raw %}
```php
<form method="POST" action="{{ route('articles.store') }}">
  @csrf

  <label for="title">Titre</label>
  <input id="title" name="title" type="text" value="{{ old('title') }}">
  @error('title')
    <div class="text-red-600 text-sm">{{ $message }}</div>
  @enderror

  <label for="slug">Slug</label>
  <input id="slug" name="slug" type="text" value="{{ old('slug') }}">
  @error('slug')
    <div class="text-red-600 text-sm">{{ $message }}</div>
  @enderror

  <label for="content">Contenu</label>
  <textarea id="content" name="content">{{ old('content') }}</textarea>
  @error('content')
    <div class="text-red-600 text-sm">{{ $message }}</div>
  @enderror

  <button type="submit">Enregistrer</button>
</form>
```
{% endraw %}

### 5.2 Liste globale dâ€™erreurs

{% raw %}
```php
@if ($errors->any())
  <div class="bg-red-50 border border-red-200 p-3 rounded">
    <strong>Veuillez corriger les erreurs suivantes :</strong>
    <ul class="list-disc ml-6">
      @foreach ($errors->all() as $error)
        <li>{{ $error }}</li>
      @endforeach
    </ul>
  </div>
@endif
```
{% endraw %}

---

## 6) RÃ©ponses JSON (API)

Pour les requÃªtes **AJAX/API** (`Accept: application/json`), Laravel renvoie automatiquement un **HTTP 422** avec le payload :

```json
{
  "message": "The given data was invalid.",
  "errors": {
    "title": ["Le titre est obligatoire."],
    "slug": ["Ce slug est dÃ©jÃ  utilisÃ©, merci dâ€™en choisir un autre."]
  }
}
```

---

## ğŸ§ª (Option) Test rapide de validation

```php
public function test_title_is_required()
{
    $response = $this->post('/articles', [
        'slug' => 'mon-slug',
        'content' => 'Texte suffisant pour valider la longueur minimale...'
    ]);

    $response->assertSessionHasErrors(['title']);
}
```

---

## ğŸ§­ Bonnes pratiques

* Conserver les **FormRequest par ressource** (`StoreXxxRequest`, `UpdateXxxRequest`).
* Centraliser les **messages** et **labels** dans les FormRequest pour Ã©viter la duplication.
* Utiliser `Rule::unique()->ignore($model)` pour les updates.
* Normaliser les inputs (ex. `slug`) dans `prepareForValidation()`.

---

## ğŸ§° Exercice (N2 â€“ Adaptation)

1. Obliger **au moins un tag** lors de la crÃ©ation : ajoutez `['required','array','min:1']` sur `tags`.
2. Restreindre les tags Ã  une **liste whitelist** : `Rule::in(['PHP','Laravel','Mobile','UX','MySQL'])`.
3. Ajouter un champ `reading_time` **optionnel** mais, sâ€™il est prÃ©sent, `integer|min:1|max:30`.
4. Personnaliser les messages pour ces nouvelles rÃ¨gles.

**CritÃ¨res de rÃ©ussite**

* La crÃ©ation Ã©choue proprement si `title` ou `content` sont invalides.
* Lâ€™update respecte lâ€™unicitÃ© du `slug`.
* Les messages sont **clairs** et affichÃ©s en Blade.

---

## ğŸ§¾ RÃ©sumÃ©

* **FormRequest** = lieu unique pour **valider** et **autoriser** une requÃªte.
* `rules()/messages()/attributes()` structurent **rÃ¨gles**, **textes** et **labels**.
* `validated()` sÃ©curise les **donnÃ©es entrantes** avant `create()` / `update()`.
* PrÃ©parer les inputs (ex. `slug`) dans `prepareForValidation()` fiabilise lâ€™expÃ©rience.

---
