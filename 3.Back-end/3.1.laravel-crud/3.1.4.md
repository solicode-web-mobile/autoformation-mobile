---
title: 4. Validation
layout: home
nav_order: 4
parent: 3.1. CRUD avec Laravel
permalink: /laravel-crud/validation-formrequest/
---

# 📘  3.1.4 - Validation avec **FormRequest**

## 📒 Glossaire minute

* **FormRequest** : classe dédiée qui **encapsule la validation** et l’autorisation d’une requête.
* **`rules()`** : renvoie les **règles** de validation.
* **`messages()`** : **messages personnalisés** d’erreur.
* **`attributes()`** : alias lisibles pour les **noms de champs**.
* **`validated()`** : données **nettoyées** après validation.
* **`prepareForValidation()`** : hook pour **normaliser** les inputs avant validation.
* **`Rule`** : règles avancées (ex. `Rule::unique()->ignore(...)`).

## 🎯 Objectifs pédagogiques

* Créer des **FormRequest** pour `store` et `update` d’Article.
* Écrire des **règles précises** (chaînes, dates, tableaux, unicité).
* Personnaliser **messages** et **noms d’attributs**.
* **Brancher** la validation dans le contrôleur et **afficher** les erreurs en Blade.

## ✅ Pré-requis

* Chapitres **3.1.1 → 3.1.3** (routes, contrôleurs, Blade, formulaires).
* Modèle `Article` + migration basique (titre, slug, contenu, etc.).

---

## 1) Générer les FormRequest

```bash
php artisan make:request StoreArticleRequest
php artisan make:request UpdateArticleRequest
```

Deux fichiers sont créés dans `app/Http/Requests/`.

---

## 2) `StoreArticleRequest` (création)

```php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Support\Str;

class StoreArticleRequest extends FormRequest
{
    public function authorize(): bool
    {
        // Ici: autoriser tout le monde (ex. back-office protégé par middleware).
        return true;
    }

    protected function prepareForValidation(): void
    {
        // Auto-générer le slug à partir du titre si absent
        $this->merge([
            'slug' => $this->input('slug') ?: Str::slug((string) $this->input('title'))
        ]);
    }

    public function rules(): array
    {
        return [
            'title'        => ['bail','required','string','max:160'],
            'slug'         => ['required','alpha_dash','max:180','unique:articles,slug'],
            'excerpt'      => ['nullable','string','max:180'],
            'content'      => ['required','string','min:50'],
            'published_at' => ['nullable','date'],
            'tags'         => ['nullable','array','max:5'],
            'tags.*'       => ['string','distinct','max:20'],
        ];
    }

    public function messages(): array
    {
        return [
            'title.required'   => 'Le titre est obligatoire.',
            'slug.unique'      => 'Ce slug est déjà utilisé, merci d’en choisir un autre.',
            'content.min'      => 'Le contenu doit contenir au moins :min caractères.',
            'tags.array'       => 'Le format des tags est invalide.',
            'tags.*.distinct'  => 'Les tags doivent être uniques.',
        ];
    }

    public function attributes(): array
    {
        return [
            'title'   => 'titre',
            'slug'    => 'slug',
            'content' => 'contenu',
            'tags.*'  => 'tag',
        ];
    }
}
```

> Notes
>
> * `bail` stoppe la validation **au premier échec** du champ.
> * `prepareForValidation()` garantit un **slug cohérent** même si le champ n’est pas rempli.

---

## 3) `UpdateArticleRequest` (modification)

Ici, la règle d’unicité du `slug` doit **ignorer l’article courant**.

```php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;
use Illuminate\Support\Str;

class UpdateArticleRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    protected function prepareForValidation(): void
    {
        $this->merge([
            'slug' => $this->input('slug') ?: Str::slug((string) $this->input('title'))
        ]);
    }

    public function rules(): array
    {
        $article = $this->route('article'); // Model-binded via route:articles.update

        return [
            'title'        => ['bail','required','string','max:160'],
            'slug'         => [
                'required','alpha_dash','max:180',
                Rule::unique('articles','slug')->ignore($article)
            ],
            'excerpt'      => ['nullable','string','max:180'],
            'content'      => ['required','string','min:50'],
            'published_at' => ['nullable','date'],
            'tags'         => ['nullable','array','max:5'],
            'tags.*'       => ['string','distinct','max:20'],
        ];
    }

    public function messages(): array
    {
        return [
            'slug.unique' => 'Ce slug est déjà pris par un autre article.',
        ];
    }

    public function attributes(): array
    {
        return [
            'title' => 'titre',
            'slug'  => 'slug',
        ];
    }
}
```

---

## 4) Utilisation côté contrôleur

```php
<?php

namespace App\Http\Controllers;

use App\Models\Article;
use App\Http\Requests\StoreArticleRequest;
use App\Http\Requests\UpdateArticleRequest;

class ArticleController extends Controller
{
    public function store(StoreArticleRequest $request)
    {
        $article = Article::create($request->validated());

        return redirect()
            ->route('articles.edit', $article)
            ->with('success', 'Article créé avec succès.');
    }

    public function update(UpdateArticleRequest $request, Article $article)
    {
        $article->update($request->validated());

        return redirect()
            ->route('articles.edit', $article)
            ->with('success', 'Article mis à jour.');
    }
}
```

> Astuce : `validated()` renvoie **uniquement** les champs passés par la validation.

---

## 5) Afficher les erreurs dans Blade

### 5.1 Champs avec `old()` et `@error`

{% raw %}
```php
<form method="POST" action="{{ route('articles.store') }}">
  @csrf

  <label for="title">Titre</label>
  <input id="title" name="title" type="text" value="{{ old('title') }}">
  @error('title')
    <div class="text-red-600 text-sm">{{ $message }}</div>
  @enderror

  <label for="slug">Slug</label>
  <input id="slug" name="slug" type="text" value="{{ old('slug') }}">
  @error('slug')
    <div class="text-red-600 text-sm">{{ $message }}</div>
  @enderror

  <label for="content">Contenu</label>
  <textarea id="content" name="content">{{ old('content') }}</textarea>
  @error('content')
    <div class="text-red-600 text-sm">{{ $message }}</div>
  @enderror

  <button type="submit">Enregistrer</button>
</form>
```
{% endraw %}

### 5.2 Liste globale d’erreurs

{% raw %}
```php
@if ($errors->any())
  <div class="bg-red-50 border border-red-200 p-3 rounded">
    <strong>Veuillez corriger les erreurs suivantes :</strong>
    <ul class="list-disc ml-6">
      @foreach ($errors->all() as $error)
        <li>{{ $error }}</li>
      @endforeach
    </ul>
  </div>
@endif
```
{% endraw %}

---

## 6) Réponses JSON (API)

Pour les requêtes **AJAX/API** (`Accept: application/json`), Laravel renvoie automatiquement un **HTTP 422** avec le payload :

```json
{
  "message": "The given data was invalid.",
  "errors": {
    "title": ["Le titre est obligatoire."],
    "slug": ["Ce slug est déjà utilisé, merci d’en choisir un autre."]
  }
}
```

---

## 🧪 (Option) Test rapide de validation

```php
public function test_title_is_required()
{
    $response = $this->post('/articles', [
        'slug' => 'mon-slug',
        'content' => 'Texte suffisant pour valider la longueur minimale...'
    ]);

    $response->assertSessionHasErrors(['title']);
}
```

---

## 🧭 Bonnes pratiques

* Conserver les **FormRequest par ressource** (`StoreXxxRequest`, `UpdateXxxRequest`).
* Centraliser les **messages** et **labels** dans les FormRequest pour éviter la duplication.
* Utiliser `Rule::unique()->ignore($model)` pour les updates.
* Normaliser les inputs (ex. `slug`) dans `prepareForValidation()`.

---

## 🧰 Exercice (N2 – Adaptation)

1. Obliger **au moins un tag** lors de la création : ajoutez `['required','array','min:1']` sur `tags`.
2. Restreindre les tags à une **liste whitelist** : `Rule::in(['PHP','Laravel','Mobile','UX','MySQL'])`.
3. Ajouter un champ `reading_time` **optionnel** mais, s’il est présent, `integer|min:1|max:30`.
4. Personnaliser les messages pour ces nouvelles règles.

**Critères de réussite**

* La création échoue proprement si `title` ou `content` sont invalides.
* L’update respecte l’unicité du `slug`.
* Les messages sont **clairs** et affichés en Blade.

---

## 🧾 Résumé

* **FormRequest** = lieu unique pour **valider** et **autoriser** une requête.
* `rules()/messages()/attributes()` structurent **règles**, **textes** et **labels**.
* `validated()` sécurise les **données entrantes** avant `create()` / `update()`.
* Préparer les inputs (ex. `slug`) dans `prepareForValidation()` fiabilise l’expérience.

---
