---
title: 4. Validation
layout: home
nav_order: 4
parent: 3.1. CRUD avec Laravel
permalink: /laravel-crud/validation/
code: 3.1.4
competence: C3
autoformation: "C3.2"
ua: "3.1.U2"
duree_h: 1.5
objectif: "Isoler la validation dans des FormRequest et lâ€™intÃ©grer aux actions `store/update` et aux vues."
notions_nouvelles: ["FormRequest", "rules()", "messages()", "attributes()", "validated()", "prepareForValidation()", "Rule::unique"]
fil_rouge: "Blog Laravel + App Mobile (qualitÃ© des donnÃ©es)"
livrable_chapitre: "`StoreArticleRequest` & `UpdateArticleRequest` branchÃ©s dans le contrÃ´leur + affichage dâ€™erreurs en Blade"
alimentation_prototype: "Renforce la fiabilitÃ© des formulaires du prototype"
alimentation_miniprojet: "RÃ¨gles mÃ©tier centralisÃ©es et testables"
---

# ğŸ“˜ 3.1.4 â€” Validation avec FormRequest

## ğŸ§  Introduction thÃ©orique

La **validation** est une Ã©tape clÃ© dans le flux MVC : elle protÃ¨ge ton application contre les entrÃ©es invalides et amÃ©liore lâ€™expÃ©rience utilisateur.  
Dans Laravel, on peut valider les donnÃ©es directement dans le **contrÃ´leur**, ou de faÃ§on plus propre via une **classe dÃ©diÃ©e** : le **FormRequest**.  

Un **FormRequest** agit comme un *filtre intelligent* : il reÃ§oit la requÃªte, vÃ©rifie son contenu selon les rÃ¨gles, puis la transmet au contrÃ´leur uniquement si tout est valide.  
Ce dÃ©couplage permet :
- de garder le contrÃ´leur lÃ©ger et lisible,  
- de centraliser les rÃ¨gles, messages et labels,  
- et de garantir la cohÃ©rence entre crÃ©ation et modification.  

---

## ğŸ“’ Glossaire minute
- **FormRequest** : classe Laravel pour valider et autoriser une requÃªte.  
- **`rules()`** : dÃ©finit les rÃ¨gles de validation.  
- **`messages()`** : personnalise les erreurs.  
- **`attributes()`** : remplace les noms techniques par des labels clairs.  
- **`validated()`** : renvoie uniquement les donnÃ©es validÃ©es.  
- **`prepareForValidation()`** : ajuste les donnÃ©es avant validation (ex : gÃ©nÃ©rer un slug).  

---

## ğŸ§­ Ã‰tapes guidÃ©es â€” Phase N2 : Adapter

### ğŸ§© Ã‰tape 1 â€” GÃ©nÃ©rer les FormRequest

```bash
php artisan make:request StoreArticleRequest
php artisan make:request UpdateArticleRequest
````

Deux fichiers sont crÃ©Ã©s dans `app/Http/Requests/`.
Chaque classe sâ€™occupera dâ€™une opÃ©ration : **store** (crÃ©ation) et **update** (modification).

---

### ğŸ§© Ã‰tape 2 â€” CrÃ©er le FormRequest de crÃ©ation (`StoreArticleRequest`)

Cette classe dÃ©finit les rÃ¨gles de base pour crÃ©er un article.

```php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Support\Str;

class StoreArticleRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true; // AccÃ¨s dÃ©jÃ  protÃ©gÃ© par middleware
    }

    protected function prepareForValidation(): void
    {
        // GÃ©nÃ©rer automatiquement un slug si non fourni
        $this->merge([
            'slug' => $this->input('slug') ?: Str::slug($this->input('title'))
        ]);
    }

    public function rules(): array
    {
        return [
            'title'   => ['required','string','min:3','max:150'],
            'slug'    => ['required','string','max:180','unique:articles,slug'],
            'content' => ['required','string','min:20'],
        ];
    }

    public function messages(): array
    {
        return [
            'title.required' => 'Le titre est obligatoire.',
            'content.min'    => 'Le contenu doit contenir au moins :min caractÃ¨res.',
            'slug.unique'    => 'Ce slug est dÃ©jÃ  utilisÃ©.',
        ];
    }

    public function attributes(): array
    {
        return [
            'title'   => 'titre',
            'slug'    => 'slug',
            'content' => 'contenu',
        ];
    }
}
```

ğŸ’¡ **Explication**

* `prepareForValidation()` est exÃ©cutÃ©e avant la validation pour crÃ©er un **slug automatique**.
* `bail` a Ã©tÃ© retirÃ© pour simplifier la lecture.
* Les rÃ¨gles sont limitÃ©es Ã  trois champs essentiels (titre, slug, contenu) : idÃ©al pour un premier CRUD.

---

### ğŸ§© Ã‰tape 3 â€” CrÃ©er le FormRequest de modification (`UpdateArticleRequest`)

Lors de la mise Ã  jour, la rÃ¨gle dâ€™unicitÃ© du `slug` doit **ignorer lâ€™article courant**.

```php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;
use Illuminate\Support\Str;

class UpdateArticleRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    protected function prepareForValidation(): void
    {
        $this->merge([
            'slug' => $this->input('slug') ?: Str::slug($this->input('title'))
        ]);
    }

    public function rules(): array
    {
        $article = $this->route('article');

        return [
            'title'   => ['required','string','min:3','max:150'],
            'slug'    => [
                'required','string','max:180',
                Rule::unique('articles','slug')->ignore($article)
            ],
            'content' => ['required','string','min:20'],
        ];
    }

    public function messages(): array
    {
        return [
            'slug.unique' => 'Ce slug est dÃ©jÃ  pris par un autre article.',
        ];
    }
}
```

Cette version reprend la mÃªme structure avec une **rÃ¨gle dâ€™unicitÃ© plus souple**.
Elle permet de modifier un article sans erreur tant que le slug ne change pas.

---

### ğŸ§© Ã‰tape 4 â€” Utiliser les FormRequest dans le contrÃ´leur

`app/Http/Controllers/ArticleController.php`

```php
<?php

namespace App\Http\Controllers;

use App\Models\Article;
use App\Http\Requests\StoreArticleRequest;
use App\Http\Requests\UpdateArticleRequest;

class ArticleController extends Controller
{
    public function store(StoreArticleRequest $request)
    {
        $article = Article::create($request->validated());

        return redirect()
            ->route('articles.edit', $article)
            ->with('success', 'Article crÃ©Ã© avec succÃ¨s.');
    }

    public function update(UpdateArticleRequest $request, Article $article)
    {
        $article->update($request->validated());

        return redirect()
            ->route('articles.edit', $article)
            ->with('success', 'Article mis Ã  jour.');
    }
}
```

ğŸ’¡ Ici, la validation est dÃ©jÃ  exÃ©cutÃ©e **avant** lâ€™appel du contrÃ´leur.
Si une erreur existe, Laravel redirige vers le formulaire avec `$errors`.
Sinon, la mÃ©thode `validated()` renvoie les donnÃ©es prÃªtes Ã  Ãªtre utilisÃ©es.

---

### ğŸ§© Ã‰tape 5 â€” Afficher les erreurs dans Blade

#### a) Par champ

{% raw %}

```php
<form method="POST" action="{{ route('articles.store') }}">
  @csrf

  <label for="title">Titre</label>
  <input id="title" name="title" type="text" value="{{ old('title') }}">
  @error('title')
    <div class="text-red-600 text-sm">{{ $message }}</div>
  @enderror

  <label for="slug">Slug</label>
  <input id="slug" name="slug" type="text" value="{{ old('slug') }}">
  @error('slug')
    <div class="text-red-600 text-sm">{{ $message }}</div>
  @enderror

  <label for="content">Contenu</label>
  <textarea id="content" name="content">{{ old('content') }}</textarea>
  @error('content')
    <div class="text-red-600 text-sm">{{ $message }}</div>
  @enderror

  <button type="submit">Enregistrer</button>
</form>
```

{% endraw %}

#### b) Liste globale

{% raw %}

```php
@if ($errors->any())
  <div class="bg-red-50 border border-red-200 p-3 rounded">
    <strong>Veuillez corriger les erreurs suivantes :</strong>
    <ul class="list-disc ml-6">
      @foreach ($errors->all() as $error)
        <li>{{ $error }}</li>
      @endforeach
    </ul>
  </div>
@endif
```

{% endraw %}

---

### ğŸ§© Ã‰tape 6 â€” (Optionnel) Validation API

En cas de requÃªte AJAX (header `Accept: application/json`), Laravel renvoie une **rÃ©ponse JSON** automatique :

```json
{
  "message": "The given data was invalid.",
  "errors": {
    "title": ["Le titre est obligatoire."],
    "slug": ["Ce slug est dÃ©jÃ  utilisÃ©."]
  }
}
```

---

## ğŸ§  Bonnes pratiques

* CrÃ©er un **FormRequest par ressource** (`StoreXxx`, `UpdateXxx`).
* Centraliser les rÃ¨gles dans `rules()` pour Ã©viter la duplication.
* Utiliser `Rule::unique()->ignore()` pour les mises Ã  jour.
* Simplifier les rÃ¨gles au dÃ©but, puis les enrichir selon le niveau des apprenants.
* Toujours personnaliser les messages pour une expÃ©rience claire.

---

## ğŸ§¾ RÃ©sumÃ©

* Le **FormRequest** rend le code plus clair et plus maintenable.
* La validation est isolÃ©e du contrÃ´leur et appliquÃ©e automatiquement.
* Les erreurs sont gÃ©rÃ©es nativement avec `$errors` et `@error`.
* Les donnÃ©es validÃ©es sont rÃ©cupÃ©rÃ©es via `$request->validated()`.

GrÃ¢ce Ã  cette approche, ton CRUD devient **plus robuste et professionnel**,
tout en respectant la logique MVC et la progression pÃ©dagogique de Solicode.
