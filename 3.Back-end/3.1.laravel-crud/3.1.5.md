---
title: 5. Modèle & migrations
layout: home
nav_order: 5
parent: 3.1. CRUD avec Laravel
permalink: /laravel-crud/article-migrations/
code: 3.1.5
competence: C2
autoformation: "C2.1"
ua: "2.1.U3"
duree_h: 2
objectif: "Créer le modèle Article, la table `articles` et un seeder à partir d’un JSON."
notions_nouvelles: ["Migration", "Seeder", "Eloquent Model", "fillable/casts", "getRouteKeyName()", "updateOrCreate()", "slug unique"]
fil_rouge: "Blog Laravel + App Mobile (persistance & seed)"
livrable_chapitre: "Migration `articles`, modèle `Article`, seeder lisant `storage/seeds/articles.seed.json`"
alimentation_prototype: "Alimente la base de données du CRUD admin"
alimentation_miniprojet: "Schéma durable et seeds reproductibles"
---


# 📘  3.1.5 - Modèle **Article** + migrations/seeders 

## 📒 Glossaire minute
- **Migration** : script qui crée/modifie le **schéma** de la base.  
- **Seeder** : script qui insère des **données** (ex. depuis un `*.json`).  
- **Eloquent Model** : classe PHP qui représente une **table**.  
- **Casts** : conversion auto des types (`bool`, `int`, `datetime`…).  
- **Route model binding** : résolution automatique d’un modèle depuis l’URL (ex. `slug`).  

---

## 🎯 Objectifs pédagogiques
À la fin du chapitre, vous saurez :
1. Créer la **table `articles`** (migration) avec les bonnes colonnes & index.  
2. Définir le **modèle Eloquent `Article`** (fillable, casts, `getRouteKeyName`).  
3. Écrire un **seeder** qui lit `storage/seeds/articles.seed.json` et peuple la base.  
4. Exécuter **`migrate`/`db:seed`** et vérifier les données.

---

## 🧱 Pré-requis
- Projet Laravel initialisé (3.1.1) et pages de base (3.1.2).  
- Avoir (idéalement) généré `storage/seeds/articles.seed.json` en **C3.0.8**.  

---

## 🛠️ Tutoriel guidé (pas à pas)

### 1) Générer le modèle + migration
```bash
php artisan make:model Article -m
````

### 2) Définir le schéma de la table

`database/migrations/xxxx_xx_xx_xxxxxx_create_articles_table.php`

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration {
    public function up(): void {
        Schema::create('articles', function (Blueprint $table) {
            $table->id();
            $table->string('title');
            $table->string('slug')->unique();                 // pour routes /articles/{slug}
            $table->text('excerpt')->nullable();
            $table->unsignedInteger('views')->default(0);
            $table->boolean('published')->default(true);
            $table->timestamps();
            // $table->softDeletes(); // optionnel
        });
    }

    public function down(): void {
        Schema::dropIfExists('articles');
    }
};
```

> 💡 Le **slug** unique permettra le **route model binding** par slug.

### 3) Modèle Eloquent

`app/Models/Article.php`

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Article extends Model
{
    use HasFactory;

    protected $fillable = [
        'title', 'slug', 'excerpt', 'views', 'published',
    ];

    protected $casts = [
        'views'     => 'integer',
        'published' => 'boolean',
        'created_at'=> 'datetime',
        'updated_at'=> 'datetime',
    ];

    // Utiliser le slug dans les URLs: /articles/{slug}
    public function getRouteKeyName(): string
    {
        return 'slug';
    }
}
```

### 4) Seeder depuis `articles.seed.json`

```bash
php artisan make:seeder ArticleSeeder
```

`database/seeders/ArticleSeeder.php`

```php
<?php

namespace Database\Seeders;

use App\Models\Article;
use Illuminate\Database\Seeder;
use Illuminate\Support\Str;

class ArticleSeeder extends Seeder
{
    public function run(): void
    {
        $path = storage_path('seeds/articles.seed.json');
        if (! file_exists($path)) {
            $this->command->warn("⚠️  Fichier manquant: $path (seed ignoré)");
            return;
        }

        $items = json_decode(file_get_contents($path), true);
        if (! is_array($items)) {
            $this->command->error('❌ JSON invalide — attendu: array d’articles');
            return;
        }

        foreach ($items as $a) {
            $title   = trim((string)($a['title'] ?? 'Sans titre'));
            $slug    = Str::slug($title);
            $excerpt = ($a['excerpt'] ?? null) !== '' ? (string)$a['excerpt'] : null;
            $views   = (int)($a['views'] ?? 0);
            $pub     = filter_var($a['published'] ?? true, FILTER_VALIDATE_BOOL);

            // upsert par slug (idempotence raisonnable)
            Article::updateOrCreate(
                ['slug' => $slug],
                [
                    'title'     => $title,
                    'excerpt'   => $excerpt,
                    'views'     => $views,
                    'published' => $pub,
                ]
            );
        }

        $this->command->info('✅ ArticleSeeder: données importées avec succès.');
    }
}
```

Enregistrer le seeder dans `database/seeders/DatabaseSeeder.php` :

```php
public function run(): void
{
    $this->call(ArticleSeeder::class);
}
```

### 5) Exécuter migrations & seeders

```bash
php artisan migrate:fresh --seed
# ou, si DB déjà prête:
# php artisan db:seed --class=ArticleSeeder
```

### (Optionnel) Vérifier vite en Tinker

```bash
php artisan tinker
>>> App\Models\Article::count();
>>> App\Models\Article::first()->toArray();
```

---

## 🧪 Exercice guidé (livrable N1)

> **But** : rendre l’import **résistant** aux titres dupliqués.
>
> **Exigences**
>
> 1. Si un **slug** existe déjà, créez `slug-2`, `slug-3`, … avant l’insert.
> 2. Si `views` est négatif → **forcer à 0**.
> 3. Si `title` est vide → ignorer la ligne (logguez un warning via `$this->command->warn`).
> 4. Ajoutez un **index** sur `created_at` pour futur tri (migration).

### (Indication pour le slug unique)

```php
function uniqueSlug(string $base): string {
    $slug = $base;
    $i = 2;
    while (\App\Models\Article::where('slug', $slug)->exists()) {
        $slug = $base . '-' . $i++;
    }
    return $slug;
}
```

---

## ✅ Critères de réussite

* La table **`articles`** est créée avec **`slug` unique**.
* Le **seeder** lit `storage/seeds/articles.seed.json` et insère/Met à jour sans erreur.
* Les types sont correctement **castés** (`views` int, `published` bool).
* `Article::first()->getRouteKeyName()` retourne `'slug'`.

---

## ⚠️ Erreurs fréquentes

* Oublier d’ajouter le seeder dans `DatabaseSeeder`.
* JSON invalide (virgule en trop, encodage) → **vérifier** le fichier.
* Conflits d’unicité sur `slug` → implémenter une stratégie de **désambigüisation**.
* `fillable` incomplet → `MassAssignmentException` lors de `updateOrCreate`.

---

## 🧾 Résumé

Vous avez un **modèle Article** opérationnel, une **table** bien définie et un **seeder** qui alimente la base depuis `articles.seed.json`.
C’est le socle idéal pour le **CRUD (3.1.6)** et, plus tard, pour l’**API v1 (C3.2)**.

---

## 🔜 Suite

Passez à **3.1.6 — CRUD basique (index/create/edit/delete) + pagination** : contrôleur `resource`, vues `_form`, validation via `FormRequest`, et routes nommées.

