---
title: 5. ModÃ¨le & migrations
layout: home
nav_order: 5
parent: 3.1. CRUD avec Laravel
permalink: /laravel-crud/article-migrations/
code: 3.1.5
competence: C2
autoformation: "C2.1"
ua: "2.1.U3"
duree_h: 2
objectif: "CrÃ©er le modÃ¨le Article, la table `articles` et un seeder Ã  partir dâ€™un JSON."
notions_nouvelles: ["Migration", "Seeder", "Eloquent Model", "fillable/casts", "getRouteKeyName()", "updateOrCreate()", "slug unique"]
fil_rouge: "Blog Laravel + App Mobile (persistance & seed)"
livrable_chapitre: "Migration `articles`, modÃ¨le `Article`, seeder lisant `storage/seeds/articles.seed.json`"
alimentation_prototype: "Alimente la base de donnÃ©es du CRUD admin"
alimentation_miniprojet: "SchÃ©ma durable et seeds reproductibles"
---


# ğŸ“˜  3.1.5 - ModÃ¨le **Article** + migrations/seeders 

## ğŸ“’ Glossaire minute
- **Migration** : script qui crÃ©e/modifie le **schÃ©ma** de la base.  
- **Seeder** : script qui insÃ¨re des **donnÃ©es** (ex. depuis un `*.json`).  
- **Eloquent Model** : classe PHP qui reprÃ©sente une **table**.  
- **Casts** : conversion auto des types (`bool`, `int`, `datetime`â€¦).  
- **Route model binding** : rÃ©solution automatique dâ€™un modÃ¨le depuis lâ€™URL (ex. `slug`).  

---

## ğŸ¯ Objectifs pÃ©dagogiques
Ã€ la fin du chapitre, vous saurez :
1. CrÃ©er la **table `articles`** (migration) avec les bonnes colonnes & index.  
2. DÃ©finir le **modÃ¨le Eloquent `Article`** (fillable, casts, `getRouteKeyName`).  
3. Ã‰crire un **seeder** qui lit `storage/seeds/articles.seed.json` et peuple la base.  
4. ExÃ©cuter **`migrate`/`db:seed`** et vÃ©rifier les donnÃ©es.

---

## ğŸ§± PrÃ©-requis
- Projet Laravel initialisÃ© (3.1.1) et pages de base (3.1.2).  
- Avoir (idÃ©alement) gÃ©nÃ©rÃ© `storage/seeds/articles.seed.json` en **C3.0.8**.  

---

## ğŸ› ï¸ Tutoriel guidÃ© (pas Ã  pas)

### 1) GÃ©nÃ©rer le modÃ¨le + migration
```bash
php artisan make:model Article -m
````

### 2) DÃ©finir le schÃ©ma de la table

`database/migrations/xxxx_xx_xx_xxxxxx_create_articles_table.php`

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration {
    public function up(): void {
        Schema::create('articles', function (Blueprint $table) {
            $table->id();
            $table->string('title');
            $table->string('slug')->unique();                 // pour routes /articles/{slug}
            $table->text('excerpt')->nullable();
            $table->unsignedInteger('views')->default(0);
            $table->boolean('published')->default(true);
            $table->timestamps();
            // $table->softDeletes(); // optionnel
        });
    }

    public function down(): void {
        Schema::dropIfExists('articles');
    }
};
```

> ğŸ’¡ Le **slug** unique permettra le **route model binding** par slug.

### 3) ModÃ¨le Eloquent

`app/Models/Article.php`

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Article extends Model
{
    use HasFactory;

    protected $fillable = [
        'title', 'slug', 'excerpt', 'views', 'published',
    ];

    protected $casts = [
        'views'     => 'integer',
        'published' => 'boolean',
        'created_at'=> 'datetime',
        'updated_at'=> 'datetime',
    ];

    // Utiliser le slug dans les URLs: /articles/{slug}
    public function getRouteKeyName(): string
    {
        return 'slug';
    }
}
```

### 4) Seeder depuis `articles.seed.json`

```bash
php artisan make:seeder ArticleSeeder
```

`database/seeders/ArticleSeeder.php`

```php
<?php

namespace Database\Seeders;

use App\Models\Article;
use Illuminate\Database\Seeder;
use Illuminate\Support\Str;

class ArticleSeeder extends Seeder
{
    public function run(): void
    {
        $path = storage_path('seeds/articles.seed.json');
        if (! file_exists($path)) {
            $this->command->warn("âš ï¸  Fichier manquant: $path (seed ignorÃ©)");
            return;
        }

        $items = json_decode(file_get_contents($path), true);
        if (! is_array($items)) {
            $this->command->error('âŒ JSON invalide â€” attendu: array dâ€™articles');
            return;
        }

        foreach ($items as $a) {
            $title   = trim((string)($a['title'] ?? 'Sans titre'));
            $slug    = Str::slug($title);
            $excerpt = ($a['excerpt'] ?? null) !== '' ? (string)$a['excerpt'] : null;
            $views   = (int)($a['views'] ?? 0);
            $pub     = filter_var($a['published'] ?? true, FILTER_VALIDATE_BOOL);

            // upsert par slug (idempotence raisonnable)
            Article::updateOrCreate(
                ['slug' => $slug],
                [
                    'title'     => $title,
                    'excerpt'   => $excerpt,
                    'views'     => $views,
                    'published' => $pub,
                ]
            );
        }

        $this->command->info('âœ… ArticleSeeder: donnÃ©es importÃ©es avec succÃ¨s.');
    }
}
```

Enregistrer le seeder dans `database/seeders/DatabaseSeeder.php` :

```php
public function run(): void
{
    $this->call(ArticleSeeder::class);
}
```

### 5) ExÃ©cuter migrations & seeders

```bash
php artisan migrate:fresh --seed
# ou, si DB dÃ©jÃ  prÃªte:
# php artisan db:seed --class=ArticleSeeder
```

### (Optionnel) VÃ©rifier vite en Tinker

```bash
php artisan tinker
>>> App\Models\Article::count();
>>> App\Models\Article::first()->toArray();
```

---

## ğŸ§ª Exercice guidÃ© (livrable N1)

> **But** : rendre lâ€™import **rÃ©sistant** aux titres dupliquÃ©s.
>
> **Exigences**
>
> 1. Si un **slug** existe dÃ©jÃ , crÃ©ez `slug-2`, `slug-3`, â€¦ avant lâ€™insert.
> 2. Si `views` est nÃ©gatif â†’ **forcer Ã  0**.
> 3. Si `title` est vide â†’ ignorer la ligne (logguez un warning via `$this->command->warn`).
> 4. Ajoutez un **index** sur `created_at` pour futur tri (migration).

### (Indication pour le slug unique)

```php
function uniqueSlug(string $base): string {
    $slug = $base;
    $i = 2;
    while (\App\Models\Article::where('slug', $slug)->exists()) {
        $slug = $base . '-' . $i++;
    }
    return $slug;
}
```

---

## âœ… CritÃ¨res de rÃ©ussite

* La table **`articles`** est crÃ©Ã©e avec **`slug` unique**.
* Le **seeder** lit `storage/seeds/articles.seed.json` et insÃ¨re/Met Ã  jour sans erreur.
* Les types sont correctement **castÃ©s** (`views` int, `published` bool).
* `Article::first()->getRouteKeyName()` retourne `'slug'`.

---

## âš ï¸ Erreurs frÃ©quentes

* Oublier dâ€™ajouter le seeder dans `DatabaseSeeder`.
* JSON invalide (virgule en trop, encodage) â†’ **vÃ©rifier** le fichier.
* Conflits dâ€™unicitÃ© sur `slug` â†’ implÃ©menter une stratÃ©gie de **dÃ©sambigÃ¼isation**.
* `fillable` incomplet â†’ `MassAssignmentException` lors de `updateOrCreate`.

---

## ğŸ§¾ RÃ©sumÃ©

Vous avez un **modÃ¨le Article** opÃ©rationnel, une **table** bien dÃ©finie et un **seeder** qui alimente la base depuis `articles.seed.json`.
Câ€™est le socle idÃ©al pour le **CRUD (3.1.6)** et, plus tard, pour lâ€™**API v1 (C3.2)**.

---

## ğŸ”œ Suite

Passez Ã  **3.1.6 â€” CRUD basique (index/create/edit/delete) + pagination** : contrÃ´leur `resource`, vues `_form`, validation via `FormRequest`, et routes nommÃ©es.

