---
title: 3. Handler d’exceptions
layout: home
nav_order: 3
parent: 3.3. Sécurité
permalink: /securite/handler-exceptions/
code: 3.3.3
competence: C3
autoformation: "C3.4"
ua: "3.3.U2"
duree_h: 1.5
objectif: "Uniformiser les réponses d’erreur JSON pour l’API tout en conservant des pages d’erreur web lisibles."
notions_nouvelles: ["Handler", "renderable()", "expectsJson()", "ValidationException (422)", "AuthenticationException (401)", "AuthorizationException (403)", "404/429", "payload JSON"]
fil_rouge: "Blog Laravel + App Mobile (API propre)"
livrable_chapitre: "Handler.php avec détection API, formats JSON stables (401/403/404/422/429/500) + vues 404/500 optionnelles."
alimentation_prototype: "N2 : erreurs API cohérentes consommables par le Mobile."
alimentation_miniprojet: "N3 : base pour la journalisation/observabilité."
---

# 📘  3.3.3 - *Handler* d’exceptions 

## 📒 Glossaire minute
- **`Handler`** : classe centrale (`app/Exceptions/Handler.php`) qui **intercepte** et **formate** les erreurs.
- **`renderable()`** : enregistre un **rendu personnalisé** par type d’exception.
- **Négociation de contenu** : `expectsJson()` / route `api/*` → choisir **JSON** vs **HTML**.
- **Exceptions courantes** : `ValidationException` (422), `AuthenticationException` (401), `AuthorizationException` (403), `ModelNotFoundException`/`NotFoundHttpException` (404), `ThrottleRequestsException` (429).

---

## 🎯 Objectif pédagogique
Mettre en place un **format d’erreur JSON uniforme** pour l’API tout en conservant de belles **pages d’erreur web** :
- Détecter **API vs Web**,
- Normaliser les **payloads JSON** (code, message, détails),
- Gérer les cas fréquents (401/403/404/422/429/500),
- Laisser **Laravel** servir les vues d’erreur HTML en mode web.

---

## ✅ Pré-requis
- Projet Laravel fonctionnel (3.1.1)
- Middlewares `auth`, `throttle`, CORS configurés (3.3.1)
- Des routes API existantes (`/api/articles`) (3.2.1/3.2.2)

---

## 🧭 Étapes guidées

### 1) Détecter l’API dans le `Handler`
`app/Exceptions/Handler.php`
```php
<?php

namespace App\Exceptions;

use Throwable;
use Illuminate\Auth\Access\AuthorizationException;
use Illuminate\Auth\AuthenticationException;
use Illuminate\Database\Eloquent\ModelNotFoundException;
use Illuminate\Http\Exceptions\ThrottleRequestsException;
use Illuminate\Validation\ValidationException;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use Illuminate\Foundation\Exceptions\Handler as ExceptionHandler;

class Handler extends ExceptionHandler
{
    /** Détermine si on doit répondre en JSON (API) */
    protected function isApi($request): bool
    {
        return $request->expectsJson() || $request->is('api/*');
    }

    /** Convertit une exception en payload JSON + status HTTP */
    protected function toApiResponse(Throwable $e): array
    {
        $status = 500;
        $code   = 'SERVER_ERROR';
        $msg    = 'Une erreur interne est survenue.';

        if ($e instanceof ValidationException) {
            $status = 422; $code = 'VALIDATION_ERROR';
            return [
                'status'  => $status,
                'body'    => [
                    'status'  => 'error',
                    'code'    => $code,
                    'message' => 'Les données fournies sont invalides.',
                    'errors'  => $e->errors(),
                ],
            ];
        }
        if ($e instanceof AuthenticationException) {
            $status = 401; $code = 'AUTHENTICATION_REQUIRED'; $msg = 'Authentification requise.';
        } elseif ($e instanceof AuthorizationException) {
            $status = 403; $code = 'FORBIDDEN'; $msg = 'Accès refusé.';
        } elseif ($e instanceof ModelNotFoundException || $e instanceof NotFoundHttpException) {
            $status = 404; $code = 'NOT_FOUND'; $msg = 'Ressource introuvable.';
        } elseif ($e instanceof ThrottleRequestsException) {
            $status = 429; $code = 'RATE_LIMITED'; $msg = 'Trop de requêtes. Réessayez plus tard.';
        }

        $body = [
            'status'  => 'error',
            'code'    => $code,
            'message' => $msg,
        ];

        // En dev, exposer un peu plus d’infos (facultatif)
        if (config('app.debug')) {
            $body['exception'] = class_basename($e);
            $body['trace_id']  = substr(md5($e->getMessage().$e->getFile().$e->getLine()), 0, 8);
        }

        return ['status' => $status, 'body' => $body];
    }

    public function register(): void
    {
        // Validation → JSON propre
        $this->renderable(function (ValidationException $e, $request) {
            if ($this->isApi($request)) {
                $res = $this->toApiResponse($e);
                return response()->json($res['body'], $res['status']);
            }
        });

        // 401 / 403 / 404 / 429 / 500 (général)
        $this->renderable(function (Throwable $e, $request) {
            if ($this->isApi($request)) {
                $res = $this->toApiResponse($e);
                return response()->json($res['body'], $res['status']);
            }
        });
    }

    /** JSON custom pour échec d’auth (redirige côté web, JSON côté API) */
    protected function unauthenticated($request, AuthenticationException $exception)
    {
        if ($this->isApi($request)) {
            return response()->json([
                'status'  => 'error',
                'code'    => 'AUTHENTICATION_REQUIRED',
                'message' => 'Authentification requise.',
            ], 401);
        }
        return redirect()->guest(route('login'));
    }
}
````

> **Principe** :
>
> * **API** → réponses **JSON** uniformes (avec `code`, `message`, `errors?`).
> * **Web** → les **vues d’erreur** standard (`resources/views/errors/*.blade.php`) prennent le relais.

---

### 2) (Option) Pages d’erreur web lisibles

Créer des vues minimalistes :

```
resources/views/errors/404.blade.php
resources/views/errors/500.blade.php
```

`resources/views/errors/404.blade.php`

{% raw %}
```php
@extends('layouts.app')

@section('content')
  <h1>404 — Page introuvable</h1>
  <p>La ressource demandée n’existe pas ou a été déplacée.</p>
  <a href="{{ url('/') }}">← Retour à l’accueil</a>
@endsection
```
{% endraw %}

---

### 3) Démonstrations rapides

**A) 404 API**

```php
// routes/api.php
Route::get('/boom', fn() => abort(404));
```

`GET /api/boom` →

```json
{ "status":"error","code":"NOT_FOUND","message":"Ressource introuvable." }
```

**B) 401 API**

```php
// routes/api.php
Route::get('/private', fn() => ['ok' => true])->middleware('auth:api');
```

Sans token →

```json
{ "status":"error","code":"AUTHENTICATION_REQUIRED","message":"Authentification requise." }
```

**C) 422 Validation**
Une route POST qui valide `title` :

```php
// routes/api.php
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Route;

Route::post('/check', function (Request $r) {
    $r->validate(['title' => ['required','min:3']]);
    return ['ok' => true];
});
```

`POST /api/check` avec `{}` →

```json
{
  "status":"error",
  "code":"VALIDATION_ERROR",
  "message":"Les données fournies sont invalides.",
  "errors":{"title":["The title field is required."]}
}
```

**D) 429 Throttle**
Appliquez `->middleware('throttle:api')` et bombardez la route :

```json
{ "status":"error","code":"RATE_LIMITED","message":"Trop de requêtes. Réessayez plus tard." }
```

---

## 🔍 Bonnes pratiques

* **Ne divulguez pas** la trace complète en prod (`APP_DEBUG=false`).
* **Codes d’erreur stables** (`VALIDATION_ERROR`, `NOT_FOUND`, …) pour le **Mobile**.
* Laissez **Laravel** gérer le HTML des erreurs côté web (page 404/500 personnalisables).
* Centralisez toute la **normalisation JSON** dans le *Handler* (évite la duplication dans les contrôleurs).

---

## 🧩 Intégration fil rouge

* L’API `/api/articles` renverra désormais des **erreurs standardisées**.
* Les écrans web (CRUD auteur) continuent d’afficher des **pages d’erreur** propres.
* En 3.3.4, on **journalise** finement (canaux Monolog, niveaux, rotation).

---

## 🛠 Challenge (N1+)

* Créez `App\Exceptions\ApiException` (avec `$status`, `$code`, `$context`) et un `renderable()` dédié.
* Ajoutez un **trace\_id** injecté dans les logs pour corréler front ↔ back.
* Internationalisez les **messages** d’erreur avec `lang/fr/validation.php` et un fichier `lang/fr/errors.php`.

---

## 🧾 Résumé

* Le *Handler* unifie **API** (JSON) et **Web** (HTML) sans dupliquer la logique.
* **Détection API** : `expectsJson()` / `api/*`.
* **Payloads JSON** constants : `status`, `code`, `message`, `errors?`.
* Couverture des cas clés : **401/403/404/422/429/500**.

**Livrable attendu** :

* `app/Exceptions/Handler.php` mis à jour,
* (option) vues `resources/views/errors/404.blade.php` & `500.blade.php`,
* Tests Postman/cURL vérifiant les statuts et la structure JSON.
