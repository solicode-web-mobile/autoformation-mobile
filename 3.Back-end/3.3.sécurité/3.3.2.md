---
title: 2. Policy Article
layout: home
nav_order: 2
parent: 3.3. S√©curit√©
permalink: /securite/policy-article/
code: 3.3.2
competence: C3
autoformation: "C3.4"
ua: "3.3.U1"
duree_h: 1.5
objectif: "Restreindre la modification et la suppression d‚Äôun article √† son propri√©taire via une Policy."
notions_nouvelles: ["Policy", "Gate/Ability", "$this->authorize()", "authorizeResource()", "@can/@cannot", "middleware can:"]
fil_rouge: "Blog Laravel + App Mobile (droits auteur)"
livrable_chapitre: "ArticlePolicy compl√®te + auto-d√©couverte/mapping, authorizeResource() dans le contr√¥leur, @can en Blade, test 403."
alimentation_prototype: "N2 : contr√¥le d‚Äôacc√®s sur edit/destroy."
alimentation_miniprojet: "N3 : s√©curit√© par ressource pour le tableau de bord auteur."
---

# üìò  3.3.2 - Policy *Article*

## üìí Glossaire minute

- **Policy** : classe qui centralise les **r√®gles d‚Äôautorisation** d‚Äôun mod√®le (ici `Article`).
- **Gate/Ability** : capacit√© nomm√©e (ex. `update`) √©valu√©e pour un **user** et une **ressource**.
- **`$this->authorize()`** : v√©rifie une ability dans un contr√¥leur, renvoie **403** si refus.
- **`@can` / `@cannot`** : directives Blade pour **afficher/masquer** selon les droits.
- **`authorizeResource()`** : lie automatiquement un **Resource Controller** √† sa **Policy**.

---

## üéØ Objectifs d‚Äôapprentissage

√Ä la fin du chapitre, vous saurez :

1) √âcrire une **Policy `ArticlePolicy`** avec les m√©thodes cl√©s (`viewAny`, `view`, `create`, `update`, `delete`).  
2) **Enregistrer** la policy (`AuthServiceProvider`) ou laisser l‚Äô**auto-d√©couverte**.  
3) L‚Äô**utiliser** dans :  
   - un **contr√¥leur** (`$this->authorize(...)`, `authorizeResource()`),  
   - une **vue Blade** (`@can`, `@cannot`),  
   - les **routes** (`->middleware('can:update,article')`).  
4) V√©rifier le **comportement 403** (web) et **FORBIDDEN** (API JSON via `Handler`).

---

## ‚úÖ Pr√©requis

- Projet **Blog Laravel** (C3.1‚ÄìC3.2) op√©rationnel.  
- Authentification **session** minimale (route `/login`, middleware `auth`) activ√©e.  
- Mod√®le `Article` avec un champ `user_id` (propri√©taire).  

> Si `user_id` n‚Äôexiste pas, ajoutez-le :
```bash
php artisan make:migration add_user_id_to_articles_table --table=articles
````

```php
// database/migrations/xxxx_xx_xx_xxxxxx_add_user_id_to_articles_table.php
Schema::table('articles', function (Blueprint $table) {
    $table->foreignId('user_id')->after('id')->constrained()->cascadeOnDelete();
});
```

```php
// app/Models/Article.php (extrait)
public function user()
{
    return $this->belongsTo(User::class);
}
```

---

## üõ†Ô∏è √âtape 1 ‚Äî G√©n√©rer la Policy

```bash
php artisan make:policy ArticlePolicy --model=App\\Models\\Article
```

```php
// app/Policies/ArticlePolicy.php
<?php

namespace App\Policies;

use App\Models\Article;
use App\Models\User;

class ArticlePolicy
{
    /** Voir la liste (ex: page index) */
    public function viewAny(?User $user): bool
    {
        // Liste publique : OK pour tout le monde (m√™me invit√©)
        return true;
    }

    /** Voir un article (d√©tail) */
    public function view(?User $user, Article $article): bool
    {
        // Article public : OK pour tous
        return true;
    }

    /** Cr√©er un article (auteur connect√©) */
    public function create(User $user): bool
    {
        return $user !== null; // tout user connect√© peut cr√©er
    }

    /** Mettre √† jour : seulement le propri√©taire */
    public function update(User $user, Article $article): bool
    {
        return $article->user_id === $user->id;
    }

    /** Supprimer : seulement le propri√©taire */
    public function delete(User $user, Article $article): bool
    {
        return $article->user_id === $user->id;
    }
}
```

> ‚ÑπÔ∏è M√©thodes disponibles : `viewAny`, `view`, `create`, `update`, `delete`, `restore`, `forceDelete`.

---

## üß© √âtape 2 ‚Äî Enregistrer la Policy

### Option A (clair) : mapping explicite

```php
// app/Providers/AuthServiceProvider.php (extrait)
protected $policies = [
    \App\Models\Article::class => \App\Policies\ArticlePolicy::class,
];
```

### Option B : auto-d√©couverte

Respectez la convention d‚Äôemplacement/naming (`App\Policies\{Model}Policy`) et Laravel
d√©tecte la policy sans mapping manuel.

---

## üß≠ √âtape 3 ‚Äî Appliquer la Policy dans un contr√¥leur

### A) V√©rification cibl√©e

```php
// app/Http/Controllers/ArticleController.php (extraits)
public function edit(Article $article)
{
    $this->authorize('update', $article); // 403 si refus
    return view('articles.edit', compact('article'));
}

public function destroy(Article $article)
{
    $this->authorize('delete', $article);
    $article->delete();
    return redirect()->route('articles.index');
}
```

### B) Liaison automatique pour un Resource Controller

```php
// app/Http/Controllers/ArticleController.php (constructeur)
public function __construct()
{
    $this->authorizeResource(\App\Models\Article::class, 'article');
}
```

> Avantage : mappe automatiquement `index‚ÜíviewAny`, `show‚Üíview`, `create/store‚Üícreate`, `edit/update‚Üíupdate`, `destroy‚Üídelete`.

---

## üß± √âtape 4 ‚Äî Prot√©ger aux niveaux **Routes** & **Vues**

### A) Middleware `can:` en routes

```php
// routes/web.php (exemples)
Route::resource('articles', ArticleController::class)
     ->middleware(['auth']); // global pour l‚Äôadmin, √† combiner si besoin

// Protection ponctuelle :
Route::get('/articles/{article}/edit', [ArticleController::class, 'edit'])
     ->middleware(['auth','can:update,article'])
     ->name('articles.edit');
```

### B) Directives Blade

{% raw %}
```php
{{-- resources/views/articles/show.blade.php --}}
<h1>{{ $article->title }}</h1>

@can('update', $article)
  <a href="{{ route('articles.edit', $article) }}">Modifier</a>
@endcan

@can('delete', $article)
  <form method="POST" action="{{ route('articles.destroy', $article) }}">
    @csrf @method('DELETE')
    <button>Supprimer</button>
  </form>
@endcan
```
{% endraw %}

> Ainsi, l‚ÄôUI **n‚Äôaffiche pas** les actions interdites, et le contr√¥leur **s√©curise r√©ellement**.

---

## üåê √âtape 5 ‚Äî Effet c√¥t√© API (JSON)

Dans un contr√¥leur API, la m√™me v√©rification :

```php
public function update(ApiRequest $request, Article $article)
{
    $this->authorize('update', $article);
    $article->update($request->validated());
    return response()->json(['ok' => true, 'data' => $article]);
}
```

Si refus, le `Handler` (chap. 3.3.3) renvoie un JSON uniforme :

```json
{
  "ok": false,
  "error": { "code": "FORBIDDEN", "message": "Action non autoris√©e." }
}
```

---

## üîé V√©rification rapide (manuel)

1. Connectez-vous avec **Auteur A** et **Auteur B**.
2. Cr√©ez 1 article avec A, 1 article avec B.
3. Avec A, tentez d‚Äô**√©diter/supprimer** l‚Äôarticle de B ‚Üí **403** attendu.
4. Les boutons **Modifier/Supprimer** ne doivent **pas** s‚Äôafficher chez l‚Äôutilisateur non propri√©taire.

---

## üß™ (Optionnel) Test minimal avec Pest

```bash
php artisan make:test Policies/ArticlePolicyTest
```

```php
// tests/Feature/Policies/ArticlePolicyTest.php (extrait)
it('owner can update his article, others cannot', function () {
    $owner = \App\Models\User::factory()->create();
    $other = \App\Models\User::factory()->create();
    $article = \App\Models\Article::factory()->for($owner)->create();

    expect($owner->can('update', $article))->toBeTrue();
    expect($other->can('update', $article))->toBeFalse();
});
```

---

## üöë D√©pannage (erreurs fr√©quentes)

* **‚ÄúThis action is unauthorized.‚Äù**
  ‚Üí La policy dit **false**, ou `$this->authorize()` est appel√© sans √™tre connect√©.
  V√©rifiez **connexion**, **`user_id`**, **m√©thode** correspondante.

* **Policy non charg√©e** / ‚ÄúTarget class ‚Ä¶ does not exist‚Äù
  ‚Üí Mauvais **namespace**/chemin, ou mapping manquant dans `AuthServiceProvider`.

* **Bouton visible mais 403 au submit**
  ‚Üí Oubli du `@can` c√¥t√© Blade. Rappelez-vous : **UI** ET **contr√¥leur** doivent v√©rifier.

---

## üìù Exercice guid√© (livrable)

> **But** : s√©curiser totalement l‚Äô√©dition/suppression d‚Äôarticles.

1. Impl√©mentez `ArticlePolicy` comme ci-dessus.
2. Ajoutez `authorizeResource()` dans `ArticleController`.
3. Prot√©gez `edit`, `update`, `destroy` par middleware `auth` + `can:update/delete,article`.
4. Mettez `@can('update', $article)` et `@can('delete', $article)` dans `show.blade.php` et `index.blade.php`.
5. V√©rifiez le comportement avec deux comptes diff√©rents.

**Crit√®res d‚Äôacceptation**

* Un auteur **ne peut pas** modifier/supprimer l‚Äôarticle d‚Äôun autre.
* Les boutons d‚Äôaction n‚Äôapparaissent **que** chez le propri√©taire.
* En cas de refus : **403** (web) et **JSON FORBIDDEN** (API).

---

## üßæ R√©sum√©

* La **Policy** centralise les r√®gles d‚Äôacc√®s **m√©tier**.
* `authorizeResource()` couvre tout un **Resource Controller** d‚Äôun coup.
* Double barri√®re : **UI** (`@can`) + **serveur** (`$this->authorize()` / middleware `can:`).
* Avec le `Handler`, l‚ÄôAPI renvoie des **erreurs coh√©rentes** et exploitables.

