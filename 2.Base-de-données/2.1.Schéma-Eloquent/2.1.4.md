---
title: 4. Relations 1-n et n-n
layout: home
nav_order: 4
parent: 2.1. Sch√©ma & Eloquent
permalink: /schema-eloquent-bases/2-1-4-relations/
---

# üìò Chapitre 2.1.4 ‚Äî Relations 1-n et n-n : pivots attach sync

## üìí Glossaire minute
- **1-n (hasMany / belongsTo)** : un parent poss√®de plusieurs enfants (ex. *User ‚Üí Articles*).
- **n-n (belongsToMany)** : association via une **table pivot** (ex. *Article ‚Üî Tag*).
- **Pivot** : table d‚Äôassociation (ex. `article_tag`) nomm√©e par **ordre alphab√©tique** au singulier.
- **Eager loading** : chargement anticip√© (`with`, `load`) pour √©viter le **N+1**.
- **attach / detach / sync** : m√©thodes pour g√©rer les liens n-n.

## üéØ Objectif p√©dagogique
D√©clarer correctement les **relations Eloquent** 1-n et n-n, manipuler les associations avec `attach`, `detach`, `sync`, et utiliser `with` / `withCount` pour optimiser les requ√™tes.

## üß† D√©finition th√©orique
- En 1-n, le **c√¥t√© enfant** porte la **FK** (ex. `articles.user_id`).  
- En n-n, la **pivot** contient deux FKs (ex. `article_id`, `tag_id`) et **pas de PK auto** si vous utilisez une **PK composite**.  
- Par conventions, Eloquent d√©duit les noms :  
  `belongsToMany(Tag::class)` ‚Üî pivot `article_tag` avec colonnes `article_id`, `tag_id`.

### Exemple minimal
```php
// app/Models/Article.php
public function user() { return $this->belongsTo(User::class); }
public function tags() { return $this->belongsToMany(Tag::class); } // n-n

// app/Models/User.php
public function articles() { return $this->hasMany(Article::class); } // 1-n

// app/Models/Tag.php
public function articles() { return $this->belongsToMany(Article::class); } // n-n
````

## üîç Exemple appliqu√© au fil rouge

Dans le **Blog Laravel** :

* Un **user** poss√®de plusieurs **articles** (1-n).
* Un **article** a plusieurs **tags** et un **tag** appartient √† plusieurs **articles** (n-n via `article_tag`).

---

## üõ† Tutoriel pratique

**Arborescence cibl√©e :**

```
app/Models/
‚îú‚îÄ Article.php
‚îú‚îÄ Tag.php
‚îî‚îÄ User.php
app/Http/Controllers/
‚îî‚îÄ ArticleController.php
resources/views/articles/
‚îú‚îÄ _form.blade.php
‚îú‚îÄ create.blade.php
‚îú‚îÄ edit.blade.php
‚îî‚îÄ index.blade.php
```

### √âtape 1 ‚Äî D√©clarer les relations

```php
<?php // app/Models/Article.php
namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class Article extends Model
{
    use HasFactory;

    protected $fillable = ['user_id','title','slug','excerpt','content'];

    public function user() { return $this->belongsTo(User::class); }      // 1-n
    public function tags() { return $this->belongsToMany(Tag::class); }    // n-n
}
```

```php
<?php // app/Models/User.php
namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class User extends Model
{
    use HasFactory;

    public function articles() { return $this->hasMany(Article::class); }  // 1-n
}
```

```php
<?php // app/Models/Tag.php
namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class Tag extends Model
{
    use HasFactory;

    protected $fillable = ['name','slug'];

    public function articles() { return $this->belongsToMany(Article::class); } // n-n
}
```

### √âtape 2 ‚Äî Optimiser la liste (eager loading + count)

```php
// app/Http/Controllers/ArticleController.php
public function index()
{
    $articles = \App\Models\Article::query()
        ->with(['user','tags'])    // √©vite N+1
        ->withCount('tags')        // ajoute tags_count
        ->latest('created_at')
        ->paginate(10);

    return view('articles.index', compact('articles'));
}
```

Dans la vue :

```blade
{{-- resources/views/articles/index.blade.php (extrait) --}}
@foreach($articles as $a)
  <tr>
    <td>{{ $a->id }}</td>
    <td>{{ $a->title }}</td>
    <td>{{ $a->user?->name }}</td>
    <td>
      @foreach($a->tags as $t)
        <span>{{ $t->name }}</span>{{ !$loop->last ? ', ' : '' }}
      @endforeach
      ({{ $a->tags_count }})
    </td>
  </tr>
@endforeach
```

### √âtape 3 ‚Äî S√©lectionner les tags dans le formulaire

```php
// app/Http/Controllers/ArticleController.php (extraits)
use App\Models\Tag;

public function create()
{
    $article = new \App\Models\Article();
    $tags = Tag::orderBy('name')->get();
    return view('articles.create', compact('article','tags'));
}

public function edit(\App\Models\Article $article)
{
    $tags = Tag::orderBy('name')->get();
    return view('articles.edit', compact('article','tags'));
}
```

```blade
{{-- resources/views/articles/_form.blade.php (ajout) --}}
@php
  $selected = collect(old('tag_ids', $article->exists ? $article->tags->pluck('id')->all() : []));
@endphp

<fieldset>
  <legend>Tags</legend>
  @foreach($tags as $tag)
    <label style="margin-right:10px">
      <input type="checkbox" name="tag_ids[]" value="{{ $tag->id }}"
             @checked($selected->contains($tag->id))>
      {{ $tag->name }}
    </label>
  @endforeach
</fieldset>
```

### √âtape 4 ‚Äî `attach` / `sync` dans `store` & `update`

```php
// app/Http/Controllers/ArticleController.php (extraits)

public function store(\Illuminate\Http\Request $request)
{
    $data = $request->validate([
        'title' => ['required','string','max:180'],
        'slug'  => ['nullable','string','max:200','unique:articles,slug'],
        'excerpt' => ['nullable','string'],
        'content' => ['nullable','string'],
        'tag_ids' => ['array'], // champs checkboxes
        'tag_ids.*' => ['integer','exists:tags,id'],
    ]);

    $data['user_id'] = auth()->id() ?? 1;

    $article = \App\Models\Article::create($data);

    // Associer les tags (remplace l‚Äôexistant)
    $article->tags()->sync($request->input('tag_ids', []));

    return redirect()->route('articles.show', $article)
        ->with('success','Article cr√©√© et tags associ√©s.');
}

public function update(\Illuminate\Http\Request $request, \App\Models\Article $article)
{
    $data = $request->validate([
        'title' => ['required','string','max:180'],
        'slug'  => ['nullable','string','max:200','unique:articles,slug,'.$article->id],
        'excerpt' => ['nullable','string'],
        'content' => ['nullable','string'],
        'tag_ids' => ['array'],
        'tag_ids.*' => ['integer','exists:tags,id'],
    ]);

    $article->update($data);

    // Mettre √† jour les liens (ajoute/supprime pour coller √† la liste donn√©e)
    $article->tags()->sync($request->input('tag_ids', []));

    return redirect()->route('articles.show', $article)
        ->with('success','Article mis √† jour.');
}
```

> Alternatives utiles :
>
> * **Ajouter sans retirer** : `$article->tags()->syncWithoutDetaching([1,5]);`
> * **Ajouter une seule liaison** : `$article->tags()->attach($tagId);`
> * **Retirer** : `$article->tags()->detach([$tagId1, $tagId2]);`

### √âtape 5 ‚Äî (Optionnel) Attributs de pivot

Si vous ajoutez des colonnes (ex. `position`, `is_primary`) dans la pivot :

```php
// app/Models/Article.php
public function tags()
{
    return $this->belongsToMany(Tag::class)
        ->withPivot(['position','is_primary']); // acc√®s via $tag->pivot->position
}

// Attacher avec attributs
$article->tags()->attach($tagId, ['position' => 1, 'is_primary' => true]);

// Mettre √† jour un attribut pivot
$article->tags()->updateExistingPivot($tagId, ['position' => 2]);
```

---

## üß™ Tests rapides (Tinker)

```bash
php artisan tinker
```

```php
$a = App\Models\Article::first();
$t = App\Models\Tag::inRandomOrder()->first();

// Lier
$a->tags()->attach($t->id);

// Lister
$a->tags()->pluck('name');

// Remplacer tout par [1,2,3]
$a->tags()->sync([1,2,3]);

// Ajouter sans retirer
$a->tags()->syncWithoutDetaching([4,5]);

// Retirer
$a->tags()->detach([2]);
```

---

## üßæ R√©sum√© et points-cl√©s

* 1-n : **`hasMany`/`belongsTo`** ; n-n : **`belongsToMany`** via **pivot**.
* Utiliser **`with`** / **`withCount`** pour √©viter le **N+1**.
* G√©rer n-n avec **`attach`**, **`detach`**, **`sync`**, **`syncWithoutDetaching`**.
* **Nommer la pivot** correctement (`article_tag`) et garder des **FK coh√©rentes**.

---

## ü©∫ D√©pannage (fr√©quents)

| Probl√®me                                    | Cause                             | Solution                                               |
| ------------------------------------------- | --------------------------------- | ------------------------------------------------------ |
| `Base table or view not found: article_tag` | Pivot absente/nom erron√©          | Cr√©er la pivot et respecter l‚Äô**ordre alphab√©tique**   |
| Doublons pivot                              | `attach` r√©p√©t√©                   | Utiliser `sync` ou une **PK composite** sur pivot      |
| N+1 (lenteur liste)                         | Relations charg√©es paresseusement | Ajouter `with(['user','tags'])`                        |
| FK violation                                | Incoh√©rence d‚ÄôIDs                 | V√©rifier que les **tags** existent avant `attach/sync` |

---

## ‚úÖ Checklist d‚Äôacceptation

* [ ] Relations **1-n** et **n-n** d√©clar√©es dans les mod√®les.
* [ ] Formulaire **articles** avec **checkboxes tags** op√©rationnel.
* [ ] `store`/`update` utilisent `sync` avec validation des IDs.
* [ ] Liste optimis√©e avec `with` et `withCount`.

