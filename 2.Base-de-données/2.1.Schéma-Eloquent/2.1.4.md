---
title: 4. Relations 1-n & n-n
layout: home
nav_order: 4
parent: 2.1. Sch√©ma & Eloquent
permalink: /schema-eloquent/relations/
code: 2.1.4
competence: C2
autoformation: "C2.1"
ua: "2.1.U2"
duree_h: 2
objectif: "D√©clarer 1-n et n-n, manipuler `attach/detach/sync`, optimiser avec `with/withCount`."
notions_nouvelles: ["hasMany/belongsTo", "belongsToMany", "Pivot", "Eager loading", "attach/detach/sync"]
fil_rouge: "Blog Laravel : User‚ÜíArticles (1-n), Article‚ÜîTags (n-n)"
livrable_chapitre: "Relations dans mod√®les + formulaire tags (checkboxes) + `sync` dans `store/update` + liste optimis√©e (`with`, `withCount`)"
alimentation_prototype: "Association Article‚ÜîTags visible en UI (N2)."
alimentation_miniprojet: "Tra√ßabilit√© multi-entit√©s & requ√™tes optimis√©es (N3)."
---


#  2.1.4 ‚Äî Relations 1-n et n-n : pivots attach sync

> ‚ÑπÔ∏è Objectif : connecter les mod√®les entre eux pour cr√©er des relations coh√©rentes (User‚ÜíArticles, Article‚ÜîTags) et apprendre √† manipuler leurs associations.

---

## üìí Glossaire minute
- **1-n (hasMany / belongsTo)** : un parent poss√®de plusieurs enfants (ex. User ‚Üí Articles).  
- **n-n (belongsToMany)** : association via une table pivot (ex. Article ‚Üî Tag).  
- **Pivot** : table d‚Äôassociation nomm√©e par **ordre alphab√©tique** au singulier (ex. `article_tag`).  
- **Eager loading** : chargement anticip√© avec `with` / `load` pour √©viter le **N+1**.  
- **attach / detach / sync** : m√©thodes Eloquent pour g√©rer les liens n-n.  

---

## üéØ Objectif p√©dagogique
D√©clarer les **relations Eloquent** (1-n, n-n), manipuler les associations via `attach`, `detach`, `sync`, et optimiser les requ√™tes avec `with` / `withCount`.

---

## üß† D√©finition th√©orique
- En 1-n, la **FK** se trouve dans la table enfant (`articles.user_id`).  
- En n-n, la **pivot** contient deux FKs (`article_id`, `tag_id`) et pas de PK auto.  
- Eloquent d√©duit automatiquement les noms si les conventions sont respect√©es.  

{% raw %}
```php
// app/Models/Article.php
public function user() { return $this->belongsTo(User::class); }          // 1-n
public function tags() { return $this->belongsToMany(Tag::class); }       // n-n

// app/Models/User.php
public function articles() { return $this->hasMany(Article::class); }     // 1-n

// app/Models/Tag.php
public function articles() { return $this->belongsToMany(Article::class); } // n-n
````

{% endraw %}

---

## üîç Exemple fil rouge

Dans le **Blog Laravel** :

* Un **user** poss√®de plusieurs **articles** (1-n).
* Un **article** poss√®de plusieurs **tags**, et un **tag** peut appartenir √† plusieurs **articles** (n-n).

---

## üõ† Tutoriel pratique

### √âtape 1 ‚Äî D√©clarer les relations

> Chaque mod√®le d√©clare ses m√©thodes de relation (1-n ou n-n).

{% raw %}

```php
// app/Models/Article.php
class Article extends Model {
    use HasFactory;
    protected $fillable = ['user_id','title','slug','excerpt','content'];
    public function user()  { return $this->belongsTo(User::class); } 
    public function tags()  { return $this->belongsToMany(Tag::class); }
}
```

```php
// app/Models/User.php
class User extends Model {
    use HasFactory;
    public function articles() { return $this->hasMany(Article::class); }
}
```

```php
// app/Models/Tag.php
class Tag extends Model {
    use HasFactory;
    protected $fillable = ['name','slug'];
    public function articles() { return $this->belongsToMany(Article::class); }
}
```

{% endraw %}

---

### √âtape 2 ‚Äî Optimiser la liste (`with`, `withCount`)

> Le chargement anticip√© √©vite les requ√™tes multiples (N+1) et ajoute un compteur de tags par article.

{% raw %}

```php
// app/Http/Controllers/ArticleController.php
public function index()
{
    $articles = Article::with(['user','tags'])
        ->withCount('tags')
        ->latest('created_at')
        ->paginate(10);

    return view('articles.index', compact('articles'));
}
```

{% endraw %}

Dans la vue :

{% raw %}

```blade
@foreach($articles as $a)
<tr>
  <td>{{ $a->title }}</td>
  <td>{{ $a->user?->name }}</td>
  <td>
    @foreach($a->tags as $t)
      <span>{{ $t->name }}</span>{{ !$loop->last ? ', ' : '' }}
    @endforeach
    ({{ $a->tags_count }})
  </td>
</tr>
@endforeach
```

{% endraw %}

---

### √âtape 3 ‚Äî Ajouter les tags dans le formulaire

> On charge les tags et on affiche des cases √† cocher pr√©-s√©lectionn√©es.

{% raw %}

```php
// ArticleController@create / @edit
use App\Models\Tag;

$tags = Tag::orderBy('name')->get();
return view('articles.create', compact('article','tags'));
```

{% endraw %}

{% raw %}

```blade
{{-- resources/views/articles/_form.blade.php --}}
@php
  $selected = collect(old('tag_ids', $article->exists ? $article->tags->pluck('id')->all() : []));
@endphp
<fieldset>
  <legend>Tags</legend>
  @foreach($tags as $tag)
    <label>
      <input type="checkbox" name="tag_ids[]" value="{{ $tag->id }}"
             @checked($selected->contains($tag->id))>
      {{ $tag->name }}
    </label>
  @endforeach
</fieldset>
```

{% endraw %}

---

### √âtape 4 ‚Äî G√©rer les liens `attach` / `sync`

> Les tags choisis sont enregistr√©s via `sync()` dans `store` et `update`.

{% raw %}

```php
// store()
$article = Article::create($data);
$article->tags()->sync($request->input('tag_ids', []));

// update()
$article->update($data);
$article->tags()->sync($request->input('tag_ids', []));
```

{% endraw %}

> Autres cas :
>
> * `$article->tags()->attach($id);` ‚Üí ajoute
> * `$article->tags()->detach($id);` ‚Üí supprime
> * `$article->tags()->syncWithoutDetaching([...]);` ‚Üí ajoute sans retirer

---

### √âtape 5 ‚Äî (Optionnel) Attributs de pivot

> Pour stocker des infos dans la table pivot (position, is_primary‚Ä¶).

{% raw %}

```php
public function tags()
{
    return $this->belongsToMany(Tag::class)
        ->withPivot(['position','is_primary']);
}
$article->tags()->attach($tagId, ['position'=>1,'is_primary'=>true]);
```

{% endraw %}

---

## üß™ Tests rapides (Tinker)

```bash
php artisan tinker
```

{% raw %}

```php
$a = Article::first();
$t = Tag::first();
$a->tags()->attach($t->id);
$a->tags()->sync([1,2,3]);
$a->tags()->syncWithoutDetaching([4]);
$a->tags()->detach([2]);
```

{% endraw %}

---

## üßæ R√©sum√© et points-cl√©s

* **1-n** : `hasMany` / `belongsTo`‚ÄÉ‚Ä¢‚ÄÉ**n-n** : `belongsToMany` + pivot.
* Utiliser `with` / `withCount` pour √©viter le **N+1**.
* Manipuler les liaisons via `attach`, `detach`, `sync`.
* Nommer la pivot selon la convention (`article_tag`).

---

## ü©∫ D√©pannage

| Probl√®me                                    | Cause           | Solution                             |
| ------------------------------------------- | --------------- | ------------------------------------ |
| `Base table or view not found: article_tag` | Pivot manquante | Cr√©er la table pivot `article_tag`   |
| Doublons pivot                              | `attach` r√©p√©t√© | Utiliser `sync`                      |
| Requ√™tes lentes                             | N+1             | Ajouter `with(['user','tags'])`      |
| Erreur FK                                   | Tag inexistant  | V√©rifier les IDs avant `attach/sync` |

---

## ‚úÖ Checklist

* [ ] Relations 1-n et n-n d√©clar√©es dans les mod√®les
* [ ] Formulaire avec checkboxes fonctionnel
* [ ] M√©thodes `store`/`update` utilisent `sync`
* [ ] Liste optimis√©e avec `with` / `withCount`

