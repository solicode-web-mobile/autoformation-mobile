---
title: 2.1. SchÃ©ma & Eloquent
permalink: /schema-eloquent-bases/
layout: home
nav_order: 1
parent: 2. Base-de-donnÃ©es
has_children: true
---

# ğŸ—„ï¸ Comprendre le **schÃ©ma** & **Eloquent**

Avant toute fonctionnalitÃ©, une application repose sur un **modÃ¨le de donnÃ©es solide**. Cette autoformation vous apprend Ã  **concevoir un schÃ©ma relationnel** (PK/FK, contraintes), Ã  le **versionner avec des migrations**, Ã  **gÃ©nÃ©rer des jeux de donnÃ©es** (seeders/factories) et Ã  **manipuler ces donnÃ©es** via **Eloquent** (CRUD & relations).

## Pourquoi apprendre ces notions ?
- **Structurer correctement** les donnÃ©es : clÃ©s primaires/Ã©trangÃ¨res, **unicitÃ©**, **contraintes**.
- **Fiabiliser lâ€™Ã©volution** du schÃ©ma avec des **migrations versionnÃ©es** (reproductible sur tous les postes).
- **Prototyper vite** grÃ¢ce Ã  des **seeders/factories** cohÃ©rents (mÃªmes donnÃ©es pour toute la classe).
- **Coder plus lisible** : **Eloquent** simplifie CRUD et **relations** (1-n, n-n, pivot).
- **PrÃ©parer la suite** : API, pagination, filtres et application Mobile sâ€™appuieront sur ces bases.

## Objectifs de lâ€™autoformation
Ã€ la fin, vous saurez :
1. **ModÃ©liser** un mini-schÃ©ma (ex. *Article*, *Tag*, *User*) avec **PK/FK** et **index** utiles.  
2. Ã‰crire et exÃ©cuter des **migrations** et **seeders** (rÃ©utilisation dâ€™un `articles.seed.json` si disponible).  
3. CrÃ©er un **modÃ¨le Eloquent** et rÃ©aliser un **CRUD** simple.  
4. DÃ©clarer des **relations** 1-n (*User â†’ Article*) et n-n (*Article â†” Tag*) avec **table pivot** et mÃ©thodes `attach/sync`.  
5. Mettre en place quelques **bonnes pratiques** (nomenclature, timestamps, soft deletes â€” aperÃ§u).

## Ã€ qui sâ€™adresse ce module ?
Aux **dÃ©butants en bases de donnÃ©es & Laravel** souhaitant partir sur des **fondations propres** avant lâ€™API et le Mobile. Aisance minimale en **PHP/Composer** conseillÃ©e.

---

## ğŸ”— Fil rouge (Blog Laravel)
Vous appliquerez ces notions au **Blog Laravel** :  
- Tables **articles**, **tags** (+ **article_tag**), **users** ;  
- **Migrations** reproductibles ; **seeders/factories** pour donnÃ©es de test ;  
- **Eloquent** pour lister, crÃ©er, mettre Ã  jour et associer **tags â†” articles**.

---

## ğŸ“˜ UnitÃ©s dâ€™apprentissage (UAs) couvertes

### UA 2.1.U1 â€“ SchÃ©ma par migrations *(â‰ˆ 4 h)*
- **Chapitre 2.1.1** : **CrÃ©ation de tables** avec **PK/FK** et **contraintes** *(â‰ˆ 2 h)*  
- **Chapitre 2.1.2** : **Seeders** & **jeux de donnÃ©es** de test *(â‰ˆ 2 h)*

### UA 2.1.U2 â€“ Eloquent dÃ©butant *(â‰ˆ 6 h)*
- **Chapitre 2.1.3** : **CRUD basique** avec un **modÃ¨le simple** *(â‰ˆ 3 h)*  
- **Chapitre 2.1.4** : **Relations 1-n et n-n** (pivots, `attach/sync`) *(â‰ˆ 3 h)*

---

## ğŸ“‚ Livrables attendus (Niveau 1)
- **Migrations** et **seeders** exÃ©cutables (`php artisan migrate`, `php artisan db:seed`).  
- Au moins **un modÃ¨le** Eloquent fonctionnel (ex. `Article`) + **factory**.  
- **Relations** configurÃ©es et **donnÃ©es associÃ©es** (ex. `article_tag`).  
- Mini-README : **commandes** pour (re)crÃ©er la base et semer les donnÃ©es.

---

## ğŸ§­ Pistes de vÃ©rification rapide
- Les **FK** empÃªchent la suppression incohÃ©rente (intÃ©gritÃ© rÃ©fÃ©rentielle).  
- Les **seeders** produisent des donnÃ©es **cohÃ©rentes et suffisantes**.  
- Les **relations** retournent les bons jeux (ex. `Article::first()->tags`).  

---
