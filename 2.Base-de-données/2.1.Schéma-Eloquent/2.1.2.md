---
title: 2. D√©claration des relations Eloquent
layout: home
nav_order: 2
parent: 2.1. Sch√©ma & Eloquent
permalink: /schema-eloquent/relations/
code: 2.1.2
competence: C2
autoformation: "C2.1"
ua: "2.1.U1"
duree_h: 2
objectif: "D√©clarer et tester les relations Eloquent (belongsTo, hasMany, belongsToMany) entre User, Article et Tag."
notions_nouvelles: ["belongsTo", "hasMany", "belongsToMany", "Eager loading"]
fil_rouge: "Blog Laravel : User ‚Üí Articles (1-n) et Article ‚Üî Tags (n-n)"
livrable_chapitre: "Relations d√©clar√©es dans les mod√®les + v√©rification via Tinker (`with`, `withCount`)."
alimentation_prototype: "Relations pr√™tes pour g√©n√©ration de donn√©es et affichage (seeders & API)."
alimentation_miniprojet: "Base coh√©rente avec requ√™tes relationnelles Eloquent."
---

# üìò 2.1.2 ‚Äî D√©claration des relations Eloquent

> ‚ÑπÔ∏è **Pr√©requis :** les migrations et mod√®les `User`, `Article` et `Tag` doivent d√©j√† √™tre cr√©√©s (tutoriel 2.1.1).

---

## üìí Glossaire minute

- **Relation 1-n (`hasMany` / `belongsTo`)** ‚Üí un parent poss√®de plusieurs enfants (ex. *User ‚Üí Articles*).  
- **Relation n-n (`belongsToMany`)** ‚Üí deux entit√©s reli√©es via une **table pivot** (*Article ‚Üî Tag*).  
- **Pivot** ‚Üí table interm√©diaire contenant les identifiants des deux entit√©s (ex. `article_tag`).  
- **Eager loading** ‚Üí chargement anticip√© des relations pour √©viter le **probl√®me N+1**.  

---

## üéØ Objectif p√©dagogique

D√©clarer et tester les **relations entre mod√®les Eloquent** du projet Blog :

1. `User ‚Üí hasMany(Article)`  
2. `Article ‚Üí belongsTo(User)`  
3. `Article ‚Üî Tag` via `belongsToMany`  
4. Utiliser `with()` et `withCount()` pour interroger efficacement les relations.  

---

## üß† D√©finition th√©orique

Laravel Eloquent fournit trois relations principales :

| Relation | Exemple | Description |
|-----------|----------|-------------|
| **1 ‚Üí n** | `User` ‚Üí `Article` | Un utilisateur poss√®de plusieurs articles. |
| **n ‚Üí 1** | `Article` ‚Üí `User` | Un article appartient √† un utilisateur. |
| **n ‚Üî n** | `Article` ‚Üî `Tag` | Plusieurs articles peuvent avoir plusieurs tags. |

üí° Ces relations permettent de parcourir les donn√©es **dans les deux sens** :
```php
$user->articles;     // articles de l‚Äôutilisateur
$article->user;      // auteur de l‚Äôarticle
$article->tags;      // tags d‚Äôun article
$tag->articles;      // articles associ√©s √† un tag
````

---

## üõ† Tutoriel pratique

### √âtape 1 ‚Äî D√©clarer la relation **User ‚Üí Article**

> Un utilisateur peut √©crire plusieurs articles : `hasMany`.

**Fichier : `app/Models/User.php`**

{% raw %}

```php
public function articles()
{
    return $this->hasMany(Article::class);
}
```

{% endraw %}

---

### √âtape 2 ‚Äî D√©clarer la relation **Article ‚Üí User**

> Un article appartient √† un seul utilisateur : `belongsTo`.

**Fichier : `app/Models/Article.php`**

{% raw %}

```php
public function user()
{
    return $this->belongsTo(User::class);
}
```

{% endraw %}

---

### √âtape 3 ‚Äî D√©clarer la relation **Article ‚Üî Tag (n-n)**

> Un article peut avoir plusieurs tags, et un tag peut appartenir √† plusieurs articles.
> Cela passe par la table pivot `article_tag`.

**Fichier : `app/Models/Article.php`**

{% raw %}

```php
public function tags()
{
    return $this->belongsToMany(Tag::class);
}
```

{% endraw %}

**Fichier : `app/Models/Tag.php`**

{% raw %}

```php
public function articles()
{
    return $this->belongsToMany(Article::class);
}
```

{% endraw %}

---

### √âtape 4 ‚Äî Charger les relations (Eager loading)

> Pour √©viter de multiples requ√™tes SQL (le probl√®me **N+1**), on peut charger les relations √† l‚Äôavance.

```php
// Sans eager loading (risque N+1)
$articles = App\Models\Article::all();

// Avec eager loading
$articles = App\Models\Article::with(['user', 'tags'])->get();
```

üí° V√©rification du nombre de requ√™tes dans le log Laravel (`storage/logs/laravel.log`) ou via Laravel Debugbar.

---

### √âtape 5 ‚Äî Ajouter un compteur de relation (`withCount`)

> `withCount()` ajoute automatiquement une colonne virtuelle `*_count` sur le mod√®le.

```php
$articles = App\Models\Article::withCount('tags')->get();

foreach ($articles as $a) {
    echo $a->title.' ('.$a->tags_count.' tags)';
}
```

---

### √âtape 6 ‚Äî V√©rification dans Tinker

> On teste chaque relation pour confirmer qu‚Äôelle fonctionne correctement.

```bash
php artisan tinker
```

```php
>>> $u = App\Models\User::first();
>>> $u->articles; // liste des articles du user

>>> $a = App\Models\Article::first();
>>> $a->user; // auteur de l‚Äôarticle
>>> $a->tags; // liste des tags li√©s

>>> $t = App\Models\Tag::first();
>>> $t->articles; // articles associ√©s √† ce tag

>>> App\Models\Article::with(['user','tags'])->withCount('tags')->first();
```

‚úÖ Si ces commandes renvoient bien des objets Eloquent, les relations sont op√©rationnelles.

---

## üìò Bonus ‚Äî Tester la navigation entre relations

> Exemple : acc√©der aux tags du premier article d‚Äôun utilisateur.

```php
$user = App\Models\User::with('articles.tags')->first();

foreach ($user->articles as $article) {
    echo "Article : {$article->title}\n";
    echo "Tags : ". $article->tags->pluck('name')->join(', ') ."\n\n";
}
```

---

## üßæ R√©sum√© et points-cl√©s

| Relation      | M√©thode                 | Exemple pratique                        |
| ------------- | ----------------------- | --------------------------------------- |
| 1-n           | `hasMany` / `belongsTo` | `$user->articles`, `$article->user`     |
| n-n           | `belongsToMany`         | `$article->tags`, `$tag->articles`      |
| Eager loading | `with()`                | `Article::with(['user','tags'])->get()` |
| Compteur      | `withCount()`           | `Article::withCount('tags')->first()`   |

---

## üîó Suite du parcours

> Prochain chapitre ‚Üí **2.1.3 ‚Äî Seeders & factories Eloquent**
> Vous apprendrez √† **g√©n√©rer automatiquement** des utilisateurs, articles et tags li√©s gr√¢ce aux factories et aux seeders.


