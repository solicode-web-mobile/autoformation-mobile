---
title: 1. Tables & contraintes
layout: home
nav_order: 1
parent: 2.1. Schéma & Eloquent
permalink: /schema-eloquent/tables-contraintes/
code: 2.1.1
competence: C2
autoformation: "C2.1"
ua: "2.1.U1"
duree_h: 1.5
objectif: "Créer des tables avec PK/FK et contraintes (unicité, cascade) puis exécuter les migrations proprement."
notions_nouvelles: ["PK", "FK", "Contrainte"]
fil_rouge: "Blog Laravel + App Mobile (liste, détail, tags)"
livrable_chapitre: "Migrations `articles`, `tags`, `article_tag` + capture de `php artisan migrate`"
alimentation_prototype: "Schéma minimal prêt pour routes/DTOs du prototype N2."
alimentation_miniprojet: "Base relationnelle propre (PK/FK + pivot) pour N3."
---

# 📘 Chapitre 2.1.1 — Création de tables avec PK/FK et contraintes

## 📒 Glossaire minute
- **PK (Primary Key)** : identifiant unique d’une ligne dans une table.  
- **FK (Foreign Key)** : clé faisant référence à une PK d’une autre table.  
- **Contrainte** : règle d’intégrité garantissant la cohérence des données (unicité, non-null, cascade…).  

## 🎯 Objectif pédagogique
Savoir créer des tables avec **clés primaires et étrangères**, ajouter des **contraintes** (unicité, cascade) et vérifier leur bon fonctionnement dans MySQL via Laravel migrations.

## 🧠 Définition théorique
Un schéma relationnel définit les **structures de données** d’une application.  
Chaque table doit avoir une **PK** pour identifier ses lignes, et les **FK** assurent la cohérence des liens entre tables.  

### Exemple
```sql
CREATE TABLE articles (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  user_id BIGINT UNSIGNED,
  title VARCHAR(180) NOT NULL,
  slug VARCHAR(200) UNIQUE,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
````

## 🔍 Exemple appliqué au fil rouge

Dans le **Blog Laravel** :

* Un **utilisateur** (*users*) écrit plusieurs **articles** (*articles*).
* Chaque article peut avoir plusieurs **tags** (relation n–n via une table pivot `article_tag`).

## 🛠 Tutoriel pratique

**Arborescence du projet :**

```
database/
└── migrations/
    ├── xxxx_create_articles_table.php
    ├── xxxx_create_tags_table.php
    └── xxxx_create_article_tag_table.php
```

### Étape 1 : Créer une migration

```bash
php artisan make:migration create_articles_table
```

### Étape 2 : Définir la table `articles`

```php
Schema::create('articles', function (Blueprint $table) {
    $table->id(); // PK
    $table->foreignId('user_id')->constrained()->cascadeOnDelete(); // FK -> users.id
    $table->string('title', 180);
    $table->string('slug', 200)->unique();
    $table->timestamps();
});
```

### Étape 3 : Définir la table `tags`

```php
Schema::create('tags', function (Blueprint $table) {
    $table->id();
    $table->string('name')->unique();
    $table->timestamps();
});
```

### Étape 4 : Définir la table pivot `article_tag`

```php
Schema::create('article_tag', function (Blueprint $table) {
    $table->foreignId('article_id')->constrained()->cascadeOnDelete();
    $table->foreignId('tag_id')->constrained()->cascadeOnDelete();
    $table->primary(['article_id', 'tag_id']); // évite les doublons
});
```

### Étape 5 : Lancer les migrations

```bash
php artisan migrate
```

## 🧾 Résumé et points-clés

* Une **PK** identifie chaque ligne de manière unique.
* Une **FK** relie deux tables et garantit l’intégrité des données.
* Les **contraintes** (unicité, cascade) assurent la cohérence du schéma.
* Toujours vérifier l’**ordre d’exécution** des migrations (tables parentes avant pivots).

