---
title: 1. Tables & contraintes
layout: home
nav_order: 1
parent: 2.1. SchÃ©ma & Eloquent
permalink: /schema-eloquent/tables-contraintes/
code: 2.1.1
competence: C2
autoformation: "C2.1"
ua: "2.1.U1"
duree_h: 1.5
objectif: "CrÃ©er des tables avec PK/FK et contraintes (unicitÃ©, cascade) puis exÃ©cuter les migrations proprement."
notions_nouvelles: ["PK", "FK", "Contrainte"]
fil_rouge: "Blog Laravel + App Mobile (liste, dÃ©tail, tags)"
livrable_chapitre: "Migrations `articles`, `tags`, `article_tag` + capture de `php artisan migrate`"
alimentation_prototype: "SchÃ©ma minimal prÃªt pour routes/DTOs du prototype N2."
alimentation_miniprojet: "Base relationnelle propre (PK/FK + pivot) pour N3."
---

# ğŸ“˜ Chapitre 2.1.1 â€” CrÃ©ation de tables avec PK/FK et contraintes

## ğŸ“’ Glossaire minute
- **PK (Primary Key)** : identifiant unique dâ€™une ligne dans une table.  
- **FK (Foreign Key)** : clÃ© faisant rÃ©fÃ©rence Ã  une PK dâ€™une autre table.  
- **Contrainte** : rÃ¨gle dâ€™intÃ©gritÃ© garantissant la cohÃ©rence des donnÃ©es (unicitÃ©, non-null, cascadeâ€¦).  

## ğŸ¯ Objectif pÃ©dagogique
Savoir crÃ©er des tables avec **clÃ©s primaires et Ã©trangÃ¨res**, ajouter des **contraintes** (unicitÃ©, cascade) et vÃ©rifier leur bon fonctionnement dans MySQL via Laravel migrations.

## ğŸ§  DÃ©finition thÃ©orique
Un schÃ©ma relationnel dÃ©finit les **structures de donnÃ©es** dâ€™une application.  
Chaque table doit avoir une **PK** pour identifier ses lignes, et les **FK** assurent la cohÃ©rence des liens entre tables.  

### Exemple
```sql
CREATE TABLE articles (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  user_id BIGINT UNSIGNED,
  title VARCHAR(180) NOT NULL,
  slug VARCHAR(200) UNIQUE,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
````

## ğŸ” Exemple appliquÃ© au fil rouge

Dans le **Blog Laravel** :

* Un **utilisateur** (*users*) Ã©crit plusieurs **articles** (*articles*).
* Chaque article peut avoir plusieurs **tags** (relation nâ€“n via une table pivot `article_tag`).

## ğŸ›  Tutoriel pratique

**Arborescence du projet :**

```
database/
â””â”€â”€ migrations/
    â”œâ”€â”€ xxxx_create_articles_table.php
    â”œâ”€â”€ xxxx_create_tags_table.php
    â””â”€â”€ xxxx_create_article_tag_table.php
```

### Ã‰tape 1 : CrÃ©er une migration

```bash
php artisan make:migration create_articles_table
```

### Ã‰tape 2 : DÃ©finir la table `articles`

```php
Schema::create('articles', function (Blueprint $table) {
    $table->id(); // PK
    $table->foreignId('user_id')->constrained()->cascadeOnDelete(); // FK -> users.id
    $table->string('title', 180);
    $table->string('slug', 200)->unique();
    $table->timestamps();
});
```

### Ã‰tape 3 : DÃ©finir la table `tags`

```php
Schema::create('tags', function (Blueprint $table) {
    $table->id();
    $table->string('name')->unique();
    $table->timestamps();
});
```

### Ã‰tape 4 : DÃ©finir la table pivot `article_tag`

```php
Schema::create('article_tag', function (Blueprint $table) {
    $table->foreignId('article_id')->constrained()->cascadeOnDelete();
    $table->foreignId('tag_id')->constrained()->cascadeOnDelete();
    $table->primary(['article_id', 'tag_id']); // Ã©vite les doublons
});
```

### Ã‰tape 5 : Lancer les migrations

```bash
php artisan migrate
```

## ğŸ§¾ RÃ©sumÃ© et points-clÃ©s

* Une **PK** identifie chaque ligne de maniÃ¨re unique.
* Une **FK** relie deux tables et garantit lâ€™intÃ©gritÃ© des donnÃ©es.
* Les **contraintes** (unicitÃ©, cascade) assurent la cohÃ©rence du schÃ©ma.
* Toujours vÃ©rifier lâ€™**ordre dâ€™exÃ©cution** des migrations (tables parentes avant pivots).

