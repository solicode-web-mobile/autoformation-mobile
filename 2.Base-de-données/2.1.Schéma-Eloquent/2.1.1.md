---
title: 1. Tables & contraintes
layout: home
nav_order: 1
parent: 2.1. Schéma & Eloquent
permalink: /schema-eloquent/tables-contraintes/
code: 2.1.1
competence: C2
autoformation: "C2.1"
ua: "2.1.U1"
duree_h: 1.5
objectif: "Créer des tables avec PK/FK et contraintes (unicité, cascade) puis exécuter les migrations proprement."
notions_nouvelles: ["PK", "FK", "Contrainte"]
fil_rouge: "Blog Laravel + App Mobile (liste, détail, tags)"
livrable_chapitre: "Migrations `articles`, `tags`, `article_tag` + capture de `php artisan migrate`"
alimentation_prototype: "Schéma minimal prêt pour routes/DTOs du prototype N2."
alimentation_miniprojet: "Base relationnelle propre (PK/FK + pivot) pour N3."
---

# 📘 2.1.1 — Création de tables avec PK/FK et contraintes

> ℹ️ Avant de commencer : assurez-vous d’avoir un projet Laravel 11 installé (ex. : `blog-laravel`) et une base MySQL configurée.

---

## 📒 Glossaire minute

- **PK (Primary Key)** → identifiant unique d’une ligne dans une table.  
- **FK (Foreign Key)** → clé faisant référence à une PK d’une autre table.  
- **Contrainte** → règle d’intégrité garantissant la cohérence des données (unicité, non-null, cascade…).  

---

## 🎯 Objectif pédagogique

Créer des tables avec **clés primaires et étrangères**, ajouter des **contraintes** (unicité, cascade) et vérifier leur bon fonctionnement dans MySQL via les migrations Laravel.

---

## 🧠 Définition théorique

Un **schéma relationnel** décrit la structure logique des données d’une application.  
Chaque table possède une **PK** unique ; les **FK** créent des liens fiables entre tables.  
Les **contraintes** (unicité, cascade, not null) protègent l’intégrité des données.

### 🧩 Exemple SQL classique

```sql
CREATE TABLE articles (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  user_id BIGINT UNSIGNED,
  title VARCHAR(180) NOT NULL,
  slug VARCHAR(200) UNIQUE,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
````

---

## 🔍 Exemple appliqué au fil rouge

Dans le **Blog Laravel** :

* Un **utilisateur** (*users*) peut écrire plusieurs **articles** (*articles*).
* Chaque **article** peut avoir plusieurs **tags**, via une table pivot `article_tag`.

Ces relations serviront ensuite à afficher les articles dans la **liste** et le **détail** de l’app mobile.

---

## 🛠 Tutoriel pratique

### 📁 Arborescence du projet

```
database/
└── migrations/
    ├── 2014_10_12_000000_create_users_table.php   ← déjà créée par Laravel
    ├── 2025_10_24_000001_create_articles_table.php
    ├── 2025_10_24_000002_create_tags_table.php
    └── 2025_10_24_000003_create_article_tag_table.php
```

---

### Étape 1 : Créer la migration

> Cette commande crée un fichier vide dans le dossier `database/migrations`.
> Chaque migration correspond à une **modification du schéma** (création, suppression ou mise à jour d’une table).

```bash
php artisan make:migration create_articles_table
```

---

### 🧩 À savoir : la table `users` existe déjà

> Laravel crée automatiquement la table `users` dans tout nouveau projet.
> Elle se trouve dans la migration :
> `database/migrations/2014_10_12_000000_create_users_table.php`

{% raw %}

```php
Schema::create('users', function (Blueprint $table) {
    $table->id(); // clé primaire
    $table->string('name');
    $table->string('email')->unique();
    $table->timestamp('email_verified_at')->nullable();
    $table->string('password');
    $table->rememberToken();
    $table->timestamps();
});
```

{% endraw %}

> Cette table gère les **comptes utilisateurs** de l’application (nom, email, mot de passe, etc.).
> Vous pouvez donc la **réutiliser directement** pour vos relations, par exemple avec la colonne `user_id` dans la table `articles`.
> Il n’est donc **pas nécessaire de la recréer**.

---

### Étape 2 : Définir la table `articles`

> Ici, on définit la structure de la table principale du blog.
> On y ajoute une **clé primaire (`id`)**, une **clé étrangère (`user_id`)** pointant vers `users.id`, et des **contraintes** sur les colonnes `title` et `slug`.

{% raw %}

```php
Schema::create('articles', function (Blueprint $table) {
    $table->id(); // PK auto-incrémentée
    $table->foreignId('user_id')->constrained()->cascadeOnDelete(); // FK -> users.id
    $table->string('title', 180);
    $table->string('slug', 200)->unique(); // contrainte d’unicité
    $table->timestamps(); // created_at / updated_at
});
```

{% endraw %}

---

### Étape 3 : Définir la table `tags`

> Cette table contiendra la liste des tags associés aux articles.
> La contrainte `unique()` sur le champ `name` garantit qu’un même tag ne soit pas créé deux fois.

{% raw %}

```php
Schema::create('tags', function (Blueprint $table) {
    $table->id();
    $table->string('name')->unique(); // nom de tag unique
    $table->timestamps();
});
```

{% endraw %}

---

### Étape 4 : Créer la table pivot `article_tag`

> Une table **pivot** permet de gérer les relations *n–n* entre deux entités (`articles` et `tags`).
> La contrainte `primary(['article_id', 'tag_id'])` empêche les doublons dans les associations.

{% raw %}

```php
Schema::create('article_tag', function (Blueprint $table) {
    $table->foreignId('article_id')->constrained()->cascadeOnDelete();
    $table->foreignId('tag_id')->constrained()->cascadeOnDelete();
    $table->primary(['article_id', 'tag_id']); // évite les doublons
});
```

{% endraw %}

---

### Étape 5 : Exécuter les migrations

> Cette commande crée réellement les tables dans la base MySQL selon la structure définie.

```bash
php artisan migrate
```

> 💡 Pour vérifier le résultat :

```sql
SHOW TABLES;
SHOW CREATE TABLE articles;
```

---

## 📘 Bonus — Les principaux types de colonnes Laravel

> Voici les types les plus utilisés dans les migrations Laravel :

| Type                              | Exemple                                          | Description                                   |
| --------------------------------- | ------------------------------------------------ | --------------------------------------------- |
| `string`                          | `$table->string('title', 255);`                  | Texte court (VARCHAR)                         |
| `text`                            | `$table->text('content');`                       | Texte long (description, contenu)             |
| `integer` / `bigInteger`          | `$table->integer('age');`                        | Nombre entier                                 |
| `boolean`                         | `$table->boolean('is_active');`                  | Vrai / Faux                                   |
| `decimal` / `float`               | `$table->decimal('price', 8, 2);`                | Nombre avec décimales                         |
| `date` / `datetime` / `timestamp` | `$table->timestamp('published_at');`             | Date et heure                                 |
| `enum`                            | `$table->enum('status', ['draft','published']);` | Choix dans une liste                          |
| `json`                            | `$table->json('meta');`                          | Données structurées (tableau/objet JSON)      |
| `foreignId`                       | `$table->foreignId('user_id')->constrained();`   | FK vers une autre table                       |
| `softDeletes`                     | `$table->softDeletes();`                         | Colonne `deleted_at` pour suppression logique |

> 👉 Bon réflexe : **choisir le type le plus adapté** pour optimiser la taille et la performance de votre base.

---

## 🧾 Résumé et points-clés

* La table **`users`** est déjà fournie par Laravel — inutile de la recréer.
* Une **PK** identifie chaque ligne de manière unique.
* Une **FK** relie deux tables et garantit l’intégrité référentielle.
* Les **contraintes** (unicité, cascade, not null) assurent la cohérence du schéma.
* Toujours vérifier l’**ordre d’exécution** des migrations :
  tables parentes → tables enfants → pivots.
* Les **types de champs** (`string`, `integer`, `boolean`, etc.) permettent d’adapter chaque donnée à sa nature.
* Ce schéma constitue la base du **prototype N2** et du **mini-projet N3**.

