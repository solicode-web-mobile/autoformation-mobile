---
title: 1. Tables & contraintes
layout: home
nav_order: 1
parent: 2.1. SchÃ©ma & Eloquent
permalink: /schema-eloquent/tables-contraintes/
code: 2.1.1
competence: C2
autoformation: "C2.1"
ua: "2.1.U1"
duree_h: 1.5
objectif: "CrÃ©er des tables avec PK/FK et contraintes (unicitÃ©, cascade) puis exÃ©cuter les migrations proprement."
notions_nouvelles: ["PK", "FK", "Contrainte"]
fil_rouge: "Blog Laravel + App Mobile (liste, dÃ©tail, tags)"
livrable_chapitre: "Migrations `articles`, `tags`, `article_tag` + capture de `php artisan migrate`"
alimentation_prototype: "SchÃ©ma minimal prÃªt pour routes/DTOs du prototype N2."
alimentation_miniprojet: "Base relationnelle propre (PK/FK + pivot) pour N3."
---

# ğŸ“˜ 2.1.1 â€” CrÃ©ation de tables avec PK/FK et contraintes

> â„¹ï¸ Avant de commencer : assurez-vous dâ€™avoir un projet Laravel 11 installÃ© (ex. : `blog-laravel`) et une base MySQL configurÃ©e.

---

## ğŸ“’ Glossaire minute

- **PK (Primary Key)** â†’ identifiant unique dâ€™une ligne dans une table.  
- **FK (Foreign Key)** â†’ clÃ© faisant rÃ©fÃ©rence Ã  une PK dâ€™une autre table.  
- **Contrainte** â†’ rÃ¨gle dâ€™intÃ©gritÃ© garantissant la cohÃ©rence des donnÃ©es (unicitÃ©, non-null, cascadeâ€¦).  

---

## ğŸ¯ Objectif pÃ©dagogique

CrÃ©er des tables avec **clÃ©s primaires et Ã©trangÃ¨res**, ajouter des **contraintes** (unicitÃ©, cascade) et vÃ©rifier leur bon fonctionnement dans MySQL via les migrations Laravel.

---

## ğŸ§  DÃ©finition thÃ©orique

Un **schÃ©ma relationnel** dÃ©crit la structure logique des donnÃ©es dâ€™une application.  
Chaque table possÃ¨de une **PK** unique ; les **FK** crÃ©ent des liens fiables entre tables.  
Les **contraintes** (unicitÃ©, cascade, not null) protÃ¨gent lâ€™intÃ©gritÃ© des donnÃ©es.

### ğŸ§© Exemple SQL classique

```sql
CREATE TABLE articles (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  user_id BIGINT UNSIGNED,
  title VARCHAR(180) NOT NULL,
  slug VARCHAR(200) UNIQUE,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
````

---

## ğŸ” Exemple appliquÃ© au fil rouge

Dans le **Blog Laravel** :

* Un **utilisateur** (*users*) peut Ã©crire plusieurs **articles** (*articles*).
* Chaque **article** peut avoir plusieurs **tags**, via une table pivot `article_tag`.

Ces relations serviront ensuite Ã  afficher les articles dans la **liste** et le **dÃ©tail** de lâ€™app mobile.

---

## ğŸ›  Tutoriel pratique

### ğŸ“ Arborescence du projet

```
database/
â””â”€â”€ migrations/
    â”œâ”€â”€ 2014_10_12_000000_create_users_table.php   â† dÃ©jÃ  crÃ©Ã©e par Laravel
    â”œâ”€â”€ 2025_10_24_000001_create_articles_table.php
    â”œâ”€â”€ 2025_10_24_000002_create_tags_table.php
    â””â”€â”€ 2025_10_24_000003_create_article_tag_table.php
```

---

### Ã‰tape 1 : CrÃ©er la migration

> Cette commande crÃ©e un fichier vide dans le dossier `database/migrations`.
> Chaque migration correspond Ã  une **modification du schÃ©ma** (crÃ©ation, suppression ou mise Ã  jour dâ€™une table).

```bash
php artisan make:migration create_articles_table
```

---

### ğŸ§© Ã€ savoir : la table `users` existe dÃ©jÃ 

> Laravel crÃ©e automatiquement la table `users` dans tout nouveau projet.
> Elle se trouve dans la migration :
> `database/migrations/2014_10_12_000000_create_users_table.php`

{% raw %}

```php
Schema::create('users', function (Blueprint $table) {
    $table->id(); // clÃ© primaire
    $table->string('name');
    $table->string('email')->unique();
    $table->timestamp('email_verified_at')->nullable();
    $table->string('password');
    $table->rememberToken();
    $table->timestamps();
});
```

{% endraw %}

> Cette table gÃ¨re les **comptes utilisateurs** de lâ€™application (nom, email, mot de passe, etc.).
> Vous pouvez donc la **rÃ©utiliser directement** pour vos relations, par exemple avec la colonne `user_id` dans la table `articles`.
> Il nâ€™est donc **pas nÃ©cessaire de la recrÃ©er**.

---

### Ã‰tape 2 : DÃ©finir la table `articles`

> Ici, on dÃ©finit la structure de la table principale du blog.
> On y ajoute une **clÃ© primaire (`id`)**, une **clÃ© Ã©trangÃ¨re (`user_id`)** pointant vers `users.id`, et des **contraintes** sur les colonnes `title` et `slug`.

{% raw %}

```php
Schema::create('articles', function (Blueprint $table) {
    $table->id(); // PK auto-incrÃ©mentÃ©e
    $table->foreignId('user_id')->constrained()->cascadeOnDelete(); // FK -> users.id
    $table->string('title', 180);
    $table->string('slug', 200)->unique(); // contrainte dâ€™unicitÃ©
    $table->timestamps(); // created_at / updated_at
});
```

{% endraw %}

---

### Ã‰tape 3 : DÃ©finir la table `tags`

> Cette table contiendra la liste des tags associÃ©s aux articles.
> La contrainte `unique()` sur le champ `name` garantit quâ€™un mÃªme tag ne soit pas crÃ©Ã© deux fois.

{% raw %}

```php
Schema::create('tags', function (Blueprint $table) {
    $table->id();
    $table->string('name')->unique(); // nom de tag unique
    $table->timestamps();
});
```

{% endraw %}

---

### Ã‰tape 4 : CrÃ©er la table pivot `article_tag`

> Une table **pivot** permet de gÃ©rer les relations *nâ€“n* entre deux entitÃ©s (`articles` et `tags`).
> La contrainte `primary(['article_id', 'tag_id'])` empÃªche les doublons dans les associations.

{% raw %}

```php
Schema::create('article_tag', function (Blueprint $table) {
    $table->foreignId('article_id')->constrained()->cascadeOnDelete();
    $table->foreignId('tag_id')->constrained()->cascadeOnDelete();
    $table->primary(['article_id', 'tag_id']); // Ã©vite les doublons
});
```

{% endraw %}

---

### Ã‰tape 5 : ExÃ©cuter les migrations

> Cette commande crÃ©e rÃ©ellement les tables dans la base MySQL selon la structure dÃ©finie.

```bash
php artisan migrate
```

> ğŸ’¡ Pour vÃ©rifier le rÃ©sultat :

```sql
SHOW TABLES;
SHOW CREATE TABLE articles;
```

---

## ğŸ“˜ Bonus â€” Les principaux types de colonnes Laravel

> Voici les types les plus utilisÃ©s dans les migrations Laravel :

| Type                              | Exemple                                          | Description                                   |
| --------------------------------- | ------------------------------------------------ | --------------------------------------------- |
| `string`                          | `$table->string('title', 255);`                  | Texte court (VARCHAR)                         |
| `text`                            | `$table->text('content');`                       | Texte long (description, contenu)             |
| `integer` / `bigInteger`          | `$table->integer('age');`                        | Nombre entier                                 |
| `boolean`                         | `$table->boolean('is_active');`                  | Vrai / Faux                                   |
| `decimal` / `float`               | `$table->decimal('price', 8, 2);`                | Nombre avec dÃ©cimales                         |
| `date` / `datetime` / `timestamp` | `$table->timestamp('published_at');`             | Date et heure                                 |
| `enum`                            | `$table->enum('status', ['draft','published']);` | Choix dans une liste                          |
| `json`                            | `$table->json('meta');`                          | DonnÃ©es structurÃ©es (tableau/objet JSON)      |
| `foreignId`                       | `$table->foreignId('user_id')->constrained();`   | FK vers une autre table                       |
| `softDeletes`                     | `$table->softDeletes();`                         | Colonne `deleted_at` pour suppression logique |

> ğŸ‘‰ Bon rÃ©flexe : **choisir le type le plus adaptÃ©** pour optimiser la taille et la performance de votre base.

---

## ğŸ§¾ RÃ©sumÃ© et points-clÃ©s

* La table **`users`** est dÃ©jÃ  fournie par Laravel â€” inutile de la recrÃ©er.
* Une **PK** identifie chaque ligne de maniÃ¨re unique.
* Une **FK** relie deux tables et garantit lâ€™intÃ©gritÃ© rÃ©fÃ©rentielle.
* Les **contraintes** (unicitÃ©, cascade, not null) assurent la cohÃ©rence du schÃ©ma.
* Toujours vÃ©rifier lâ€™**ordre dâ€™exÃ©cution** des migrations :
  tables parentes â†’ tables enfants â†’ pivots.
* Les **types de champs** (`string`, `integer`, `boolean`, etc.) permettent dâ€™adapter chaque donnÃ©e Ã  sa nature.
* Ce schÃ©ma constitue la base du **prototype N2** et du **mini-projet N3**.

