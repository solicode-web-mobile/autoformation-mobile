---
title: 3. Seeders & factories Eloquent
layout: home
nav_order: 3
parent: 2.1. SchÃ©ma & Eloquent
permalink: /schema-eloquent/seeders-factories/
code: 2.1.3
competence: C2
autoformation: "C2.1"
ua: "2.1.U2"
duree_h: 3
objectif: "GÃ©nÃ©rer automatiquement des donnÃ©es cohÃ©rentes et liÃ©es via les factories et seeders Eloquent (User â†’ Article â†” Tag)."
notions_nouvelles: ["Factory", "Seeder", "Faker", "firstOrCreate", "sync"]
fil_rouge: "Blog Laravel : gÃ©nÃ©ration de jeux de donnÃ©es cohÃ©rents (users, articles, tags, pivots)."
livrable_chapitre: "Factories + Seeders exÃ©cutables via DatabaseSeeder, testÃ©s dans Tinker."
alimentation_prototype: "Base de donnÃ©es rÃ©aliste pour les futures requÃªtes CRUD et API."
alimentation_miniprojet: "DonnÃ©es de test reproductibles avec relations cohÃ©rentes."
---

# ğŸ“˜ 2.1.3 â€” Seeders & Factories Eloquent

> â„¹ï¸ **PrÃ©requis :** les modÃ¨les et relations `User`, `Article` et `Tag` doivent dÃ©jÃ  Ãªtre fonctionnels (tutoriels 2.1.1 et 2.1.2).

---

## ğŸ“’ Glossaire minute  

- **Factory** â†’ modÃ¨le dÃ©crivant la forme des donnÃ©es fictives Ã  gÃ©nÃ©rer.  
- **Seeder** â†’ script dâ€™insertion automatique dans la base de donnÃ©es.  
- **Faker** â†’ gÃ©nÃ©rateur intÃ©grÃ© de textes, emails, dates et contenus alÃ©atoires.  
- **firstOrCreate()** â†’ crÃ©e une donnÃ©e uniquement si elle nâ€™existe pas encore (idempotent).  
- **sync()** â†’ associe plusieurs enregistrements dans une relation nâ€“n (`Article â†” Tag`).

---

## ğŸ¯ Objectif pÃ©dagogique  

Apprendre Ã  **automatiser la crÃ©ation de donnÃ©es rÃ©alistes et cohÃ©rentes** pour le projet *Blog Laravel*, en respectant les relations entre modÃ¨les :

1. GÃ©nÃ©rer des **utilisateurs** (`UserFactory`)  
2. GÃ©nÃ©rer des **tags** (`TagFactory`)  
3. GÃ©nÃ©rer des **articles** liÃ©s Ã  un utilisateur (`ArticleFactory`)  
4. Associer les **articles â†” tags** automatiquement via `sync()`  

---

## ğŸ§  DÃ©finition thÃ©orique  

Laravel propose un systÃ¨me combinÃ© **Factory + Seeder** pour faciliter le remplissage des bases de donnÃ©es pendant le dÃ©veloppement :

- Les **factories** dÃ©finissent la *structure type* des donnÃ©es Ã  gÃ©nÃ©rer (titres, contenus, dates, etc.).
- Les **seeders** orchestrent lâ€™**insertion** de ces donnÃ©es dans le bon ordre et en nombre souhaitÃ©.
- Lâ€™ensemble permet de recharger une base complÃ¨te Ã  tout moment via une simple commande :

```bash
php artisan migrate:fresh --seed
````

ğŸ’¡ Chaque modÃ¨le Eloquent dispose dâ€™une **factory dÃ©diÃ©e** dans `database/factories/`.

---

## ğŸ›  Tutoriel pratique

### Ã‰tape 1 : CrÃ©er les factories

> Les factories dÃ©finissent la forme des donnÃ©es gÃ©nÃ©rÃ©es automatiquement pour chaque modÃ¨le.
> On les crÃ©e avec la commande `make:factory` liÃ©e Ã  un modÃ¨le existant.

```bash
php artisan make:factory UserFactory --model=User
php artisan make:factory TagFactory --model=Tag
php artisan make:factory ArticleFactory --model=Article
```

#### `database/factories/UserFactory.php`

> GÃ©nÃ¨re de faux utilisateurs cohÃ©rents avec des emails uniques.

{% raw %}

```php
namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Str;

class UserFactory extends Factory
{
    public function definition(): array
    {
        return [
            'name' => fake()->name(),
            'email' => fake()->unique()->safeEmail(),
            'email_verified_at' => now(),
            'password' => bcrypt('password'),
            'remember_token' => Str::random(10),
        ];
    }
}
```

{% endraw %}

---

#### `database/factories/TagFactory.php`

> GÃ©nÃ¨re des tags uniques avec un nom et un slug automatique.

{% raw %}

```php
namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Str;

class TagFactory extends Factory
{
    public function definition(): array
    {
        $name = fake()->unique()->word();
        return [
            'name' => ucfirst($name),
            'slug' => Str::slug($name),
        ];
    }
}
```

{% endraw %}

---

#### `database/factories/ArticleFactory.php`

> CrÃ©e des articles liÃ©s Ã  un utilisateur existant (`user_id`), avec titre, extrait et contenu alÃ©atoires.

{% raw %}

```php
namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Str;
use App\Models\User;

class ArticleFactory extends Factory
{
    public function definition(): array
    {
        $title = fake()->unique()->sentence(4);
        return [
            'user_id' => User::inRandomOrder()->value('id') ?? 1,
            'title' => $title,
            'slug' => Str::slug($title),
            'excerpt' => fake()->sentence(12),
            'content' => fake()->paragraphs(3, true),
        ];
    }
}
```

{% endraw %}

---

### Ã‰tape 2 : CrÃ©er les seeders

> Les seeders orchestrent la gÃ©nÃ©ration des donnÃ©es dans un ordre prÃ©cis.

```bash
php artisan make:seeder UserSeeder
php artisan make:seeder TagSeeder
php artisan make:seeder ArticleSeeder
php artisan make:seeder PivotArticleTagSeeder
```

---

#### `database/seeders/UserSeeder.php`

> CrÃ©e un petit jeu dâ€™utilisateurs de test.

{% raw %}

```php
namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\User;

class UserSeeder extends Seeder
{
    public function run(): void
    {
        User::factory()->count(5)->create();
    }
}
```

{% endraw %}

---

#### `database/seeders/TagSeeder.php`

> GÃ©nÃ¨re une dizaine de tags de blog.

{% raw %}

```php
namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\Tag;

class TagSeeder extends Seeder
{
    public function run(): void
    {
        Tag::factory()->count(10)->create();
    }
}
```

{% endraw %}

---

#### `database/seeders/ArticleSeeder.php`

> Produit 20 articles, chacun liÃ© Ã  un utilisateur existant.

{% raw %}

```php
namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\Article;

class ArticleSeeder extends Seeder
{
    public function run(): void
    {
        Article::factory()->count(20)->create();
    }
}
```

{% endraw %}

---

#### `database/seeders/PivotArticleTagSeeder.php`

> Associe 1 Ã  4 tags alÃ©atoires Ã  chaque article via la relation `belongsToMany`.

{% raw %}

```php
namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\Article;
use App\Models\Tag;

class PivotArticleTagSeeder extends Seeder
{
    public function run(): void
    {
        $tagIds = Tag::pluck('id');

        Article::all()->each(function ($article) use ($tagIds) {
            $article->tags()->sync($tagIds->random(rand(1, 4))->all());
        });
    }
}
```

{% endraw %}

---

### Ã‰tape 3 : Orchestration avec `DatabaseSeeder`

> On regroupe tous les seeders dans le bon ordre dâ€™exÃ©cution pour remplir la base dâ€™un coup.

{% raw %}

```php
namespace Database\Seeders;

use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    public function run(): void
    {
        $this->call([
            UserSeeder::class,
            TagSeeder::class,
            ArticleSeeder::class,
            PivotArticleTagSeeder::class,
        ]);
    }
}
```

{% endraw %}

---

### Ã‰tape 4 : ExÃ©cuter les seeders

> On vide la base et relance tout le remplissage automatiquement :

```bash
php artisan migrate:fresh --seed
```

ğŸ’¡ Si tout fonctionne, la console affichera :

```
Seeding: UserSeeder
Seeding: TagSeeder
Seeding: ArticleSeeder
Seeding: PivotArticleTagSeeder
```

---

### Ã‰tape 5 : VÃ©rification dans Tinker

> On vÃ©rifie que les donnÃ©es sont bien gÃ©nÃ©rÃ©es et liÃ©es entre elles.

```bash
php artisan tinker
```

```php
>>> App\Models\User::count();       // 5 utilisateurs
>>> App\Models\Article::count();    // 20 articles
>>> App\Models\Tag::count();        // 10 tags
>>> App\Models\Article::first()->tags->pluck('name'); // tags associÃ©s
>>> App\Models\User::first()->articles->count();      // articles dâ€™un user
```

âœ… Si toutes ces commandes renvoient des rÃ©sultats, la base est peuplÃ©e et les relations sont fonctionnelles.

---

## ğŸ§¾ RÃ©sumÃ© et points-clÃ©s

| Ã‰lÃ©ment            | RÃ´le                                               | Exemple                         |
| ------------------ | -------------------------------------------------- | ------------------------------- |
| **Factory**        | DÃ©finit la structure des donnÃ©es fictives          | `TagFactory`                    |
| **Seeder**         | ExÃ©cute la gÃ©nÃ©ration de donnÃ©es dans le bon ordre | `TagSeeder`                     |
| **DatabaseSeeder** | Coordonne tous les seeders                         | `$this->call([...])`            |
| **Faker**          | GÃ©nÃ¨re des donnÃ©es rÃ©alistes                       | `fake()->sentence()`            |
| **sync()**         | Lie plusieurs entitÃ©s dans une table pivot         | `$article->tags()->sync([...])` |

---

## ğŸ Livrable attendu

* Fichiers `UserFactory`, `TagFactory`, `ArticleFactory`.
* Fichiers `UserSeeder`, `TagSeeder`, `ArticleSeeder`, `PivotArticleTagSeeder`.
* VÃ©rification rÃ©ussie via **Tinker** (`count()`, `pluck()` et `sync()`).
* Capture de la sortie de la commande `php artisan migrate:fresh --seed`.

---

## ğŸ”— Suite du parcours

> Prochain chapitre â†’ **2.1.4 â€” RequÃªtes CRUD avec Eloquent**
> Vous apprendrez Ã  manipuler directement vos donnÃ©es (`create`, `read`, `update`, `delete`) depuis **Tinker**, sans passer par Blade ni par un contrÃ´leur.

