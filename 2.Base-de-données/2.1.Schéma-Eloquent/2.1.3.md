---
title: 3. Seeders & factories Eloquent
layout: home
nav_order: 3
parent: 2.1. Schéma & Eloquent
permalink: /schema-eloquent/seeders-factories/
code: 2.1.3
competence: C2
autoformation: "C2.1"
ua: "2.1.U2"
duree_h: 3
objectif: "Générer automatiquement des données cohérentes et liées via les factories et seeders Eloquent (User → Article ↔ Tag)."
notions_nouvelles: ["Factory", "Seeder", "Faker", "firstOrCreate", "sync"]
fil_rouge: "Blog Laravel : génération de jeux de données cohérents (users, articles, tags, pivots)."
livrable_chapitre: "Factories + Seeders exécutables via DatabaseSeeder, testés dans Tinker."
alimentation_prototype: "Base de données réaliste pour les futures requêtes CRUD et API."
alimentation_miniprojet: "Données de test reproductibles avec relations cohérentes."
---

# 📘 2.1.3 — Seeders & Factories Eloquent

> ℹ️ **Prérequis :** les modèles et relations `User`, `Article` et `Tag` doivent déjà être fonctionnels (tutoriels 2.1.1 et 2.1.2).

---

## 📒 Glossaire minute  

- **Factory** → modèle décrivant la forme des données fictives à générer.  
- **Seeder** → script d’insertion automatique dans la base de données.  
- **Faker** → générateur intégré de textes, emails, dates et contenus aléatoires.  
- **firstOrCreate()** → crée une donnée uniquement si elle n’existe pas encore (idempotent).  
- **sync()** → associe plusieurs enregistrements dans une relation n–n (`Article ↔ Tag`).

---

## 🎯 Objectif pédagogique  

Apprendre à **automatiser la création de données réalistes et cohérentes** pour le projet *Blog Laravel*, en respectant les relations entre modèles :

1. Générer des **utilisateurs** (`UserFactory`)  
2. Générer des **tags** (`TagFactory`)  
3. Générer des **articles** liés à un utilisateur (`ArticleFactory`)  
4. Associer les **articles ↔ tags** automatiquement via `sync()`  

---

## 🧠 Définition théorique  

Laravel propose un système combiné **Factory + Seeder** pour faciliter le remplissage des bases de données pendant le développement :

- Les **factories** définissent la *structure type* des données à générer (titres, contenus, dates, etc.).
- Les **seeders** orchestrent l’**insertion** de ces données dans le bon ordre et en nombre souhaité.
- L’ensemble permet de recharger une base complète à tout moment via une simple commande :

```bash
php artisan migrate:fresh --seed
````

💡 Chaque modèle Eloquent dispose d’une **factory dédiée** dans `database/factories/`.

---

## 🛠 Tutoriel pratique

### Étape 1 : Créer les factories

> Les factories définissent la forme des données générées automatiquement pour chaque modèle.
> On les crée avec la commande `make:factory` liée à un modèle existant.

```bash
php artisan make:factory UserFactory --model=User
php artisan make:factory TagFactory --model=Tag
php artisan make:factory ArticleFactory --model=Article
```

#### `database/factories/UserFactory.php`

> Génère de faux utilisateurs cohérents avec des emails uniques.

{% raw %}

```php
namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Str;

class UserFactory extends Factory
{
    public function definition(): array
    {
        return [
            'name' => fake()->name(),
            'email' => fake()->unique()->safeEmail(),
            'email_verified_at' => now(),
            'password' => bcrypt('password'),
            'remember_token' => Str::random(10),
        ];
    }
}
```

{% endraw %}

---

#### `database/factories/TagFactory.php`

> Génère des tags uniques avec un nom et un slug automatique.

{% raw %}

```php
namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Str;

class TagFactory extends Factory
{
    public function definition(): array
    {
        $name = fake()->unique()->word();
        return [
            'name' => ucfirst($name),
            'slug' => Str::slug($name),
        ];
    }
}
```

{% endraw %}

---

#### `database/factories/ArticleFactory.php`

> Crée des articles liés à un utilisateur existant (`user_id`), avec titre, extrait et contenu aléatoires.

{% raw %}

```php
namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Str;
use App\Models\User;

class ArticleFactory extends Factory
{
    public function definition(): array
    {
        $title = fake()->unique()->sentence(4);
        return [
            'user_id' => User::inRandomOrder()->value('id') ?? 1,
            'title' => $title,
            'slug' => Str::slug($title),
            'excerpt' => fake()->sentence(12),
            'content' => fake()->paragraphs(3, true),
        ];
    }
}
```

{% endraw %}

---

### Étape 2 : Créer les seeders

> Les seeders orchestrent la génération des données dans un ordre précis.

```bash
php artisan make:seeder UserSeeder
php artisan make:seeder TagSeeder
php artisan make:seeder ArticleSeeder
php artisan make:seeder PivotArticleTagSeeder
```

---

#### `database/seeders/UserSeeder.php`

> Crée un petit jeu d’utilisateurs de test.

{% raw %}

```php
namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\User;

class UserSeeder extends Seeder
{
    public function run(): void
    {
        User::factory()->count(5)->create();
    }
}
```

{% endraw %}

---

#### `database/seeders/TagSeeder.php`

> Génère une dizaine de tags de blog.

{% raw %}

```php
namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\Tag;

class TagSeeder extends Seeder
{
    public function run(): void
    {
        Tag::factory()->count(10)->create();
    }
}
```

{% endraw %}

---

#### `database/seeders/ArticleSeeder.php`

> Produit 20 articles, chacun lié à un utilisateur existant.

{% raw %}

```php
namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\Article;

class ArticleSeeder extends Seeder
{
    public function run(): void
    {
        Article::factory()->count(20)->create();
    }
}
```

{% endraw %}

---

#### `database/seeders/PivotArticleTagSeeder.php`

> Associe 1 à 4 tags aléatoires à chaque article via la relation `belongsToMany`.

{% raw %}

```php
namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\Article;
use App\Models\Tag;

class PivotArticleTagSeeder extends Seeder
{
    public function run(): void
    {
        $tagIds = Tag::pluck('id');

        Article::all()->each(function ($article) use ($tagIds) {
            $article->tags()->sync($tagIds->random(rand(1, 4))->all());
        });
    }
}
```

{% endraw %}

---

### Étape 3 : Orchestration avec `DatabaseSeeder`

> On regroupe tous les seeders dans le bon ordre d’exécution pour remplir la base d’un coup.

{% raw %}

```php
namespace Database\Seeders;

use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    public function run(): void
    {
        $this->call([
            UserSeeder::class,
            TagSeeder::class,
            ArticleSeeder::class,
            PivotArticleTagSeeder::class,
        ]);
    }
}
```

{% endraw %}

---

### Étape 4 : Exécuter les seeders

> On vide la base et relance tout le remplissage automatiquement :

```bash
php artisan migrate:fresh --seed
```

💡 Si tout fonctionne, la console affichera :

```
Seeding: UserSeeder
Seeding: TagSeeder
Seeding: ArticleSeeder
Seeding: PivotArticleTagSeeder
```

---

### Étape 5 : Vérification dans Tinker

> On vérifie que les données sont bien générées et liées entre elles.

```bash
php artisan tinker
```

```php
>>> App\Models\User::count();       // 5 utilisateurs
>>> App\Models\Article::count();    // 20 articles
>>> App\Models\Tag::count();        // 10 tags
>>> App\Models\Article::first()->tags->pluck('name'); // tags associés
>>> App\Models\User::first()->articles->count();      // articles d’un user
```

✅ Si toutes ces commandes renvoient des résultats, la base est peuplée et les relations sont fonctionnelles.

---

## 🧾 Résumé et points-clés

| Élément            | Rôle                                               | Exemple                         |
| ------------------ | -------------------------------------------------- | ------------------------------- |
| **Factory**        | Définit la structure des données fictives          | `TagFactory`                    |
| **Seeder**         | Exécute la génération de données dans le bon ordre | `TagSeeder`                     |
| **DatabaseSeeder** | Coordonne tous les seeders                         | `$this->call([...])`            |
| **Faker**          | Génère des données réalistes                       | `fake()->sentence()`            |
| **sync()**         | Lie plusieurs entités dans une table pivot         | `$article->tags()->sync([...])` |

---

## 🎁 Livrable attendu

* Fichiers `UserFactory`, `TagFactory`, `ArticleFactory`.
* Fichiers `UserSeeder`, `TagSeeder`, `ArticleSeeder`, `PivotArticleTagSeeder`.
* Vérification réussie via **Tinker** (`count()`, `pluck()` et `sync()`).
* Capture de la sortie de la commande `php artisan migrate:fresh --seed`.

---

## 🔗 Suite du parcours

> Prochain chapitre → **2.1.4 — Requêtes CRUD avec Eloquent**
> Vous apprendrez à manipuler directement vos données (`create`, `read`, `update`, `delete`) depuis **Tinker**, sans passer par Blade ni par un contrôleur.

