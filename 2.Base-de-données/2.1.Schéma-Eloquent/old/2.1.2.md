---
title: 2. Seeders & jeux de donn√©es
layout: home
nav_order: 2
parent: 2.1. Sch√©ma & Eloquent
permalink: /schema-eloquent/seeders-jeux-donnees/
code: 2.1.2
competence: C2
autoformation: "C2.1"
ua: "2.1.U1"
duree_h: 1.5
objectif: "Construire factories & seeders pour un jeu de donn√©es reproductible avec relations, orchestr√© via DatabaseSeeder."
notions_nouvelles: ["Seeder", "Factory", "Fixture", "Idempotent"]
fil_rouge: "Blog Laravel + App Mobile (tags ‚Üí articles ‚Üí pivot)"
livrable_chapitre: "Factories + seeders + JSON (`seeders/data/*.json`) + `DatabaseSeeder` ; commandes `make:*` et ex√©cution de semences"
alimentation_prototype: "Donn√©es r√©alistes pour listes/d√©tails (d√©mo N2)."
alimentation_miniprojet: "Fixtures reproductibles pour dev/tests N3."
---


#  üìò2.1.2 ‚Äî Seeders & jeux de donn√©es de test

> ‚ÑπÔ∏è Ce tutoriel compl√®te le pr√©c√©dent : il sert √† **peupler la base cr√©√©e par les migrations** avec des donn√©es coh√©rentes et reproductibles.

---

## üìí Glossaire minute

- **Seeder** : script qui **ins√®re** des donn√©es de test/d√©mo en base.  
- **Factory** : g√©n√©rateur d‚Äôobjets **fictifs** coh√©rents (via Faker).  
- **Fixture** : **jeu de donn√©es fixe** (souvent depuis un JSON).  
- **Idempotent** : peut √™tre **r√©ex√©cut√© sans cr√©er de doublons**.

---

## üéØ Objectif p√©dagogique

Cr√©er des **factories** et **seeders** permettant de produire un **jeu de donn√©es complet et reproductible**, avec des **relations** 1-n et n-n, ex√©cutables via `DatabaseSeeder`.

---

## üß† D√©finition th√©orique

- Les **factories** d√©crivent la **forme** des donn√©es g√©n√©r√©es (titres, slugs, dates‚Ä¶).  
- Les **seeders** orchestrent leur **insertion en base**, dans le bon ordre.  
- `DatabaseSeeder` regroupe plusieurs seeders pour un **remplissage global**.

### üß© Exemple simple

{% raw %}
```php
// database/seeders/DatabaseSeeder.php
public function run(): void
{
    $this->call([
        TagSeeder::class,
        ArticleSeeder::class,
        PivotArticleTagSeeder::class,
    ]);
}
````

{% endraw %}

---

## üîç Exemple appliqu√© au fil rouge

Dans le **Blog Laravel**, on doit cr√©er des **tags**, puis des **articles**, et enfin associer chaque article √† plusieurs tags via la table **pivot** `article_tag`.

---

## üõ† Tutoriel pratique

### üìÅ Arborescence du projet

```
database/
‚îú‚îÄ factories/
‚îÇ  ‚îú‚îÄ ArticleFactory.php
‚îÇ  ‚îî‚îÄ TagFactory.php
‚îú‚îÄ seeders/
‚îÇ  ‚îú‚îÄ DatabaseSeeder.php
‚îÇ  ‚îú‚îÄ TagSeeder.php
‚îÇ  ‚îú‚îÄ ArticleSeeder.php
‚îÇ  ‚îî‚îÄ PivotArticleTagSeeder.php
‚îî‚îÄ seeders/data/
   ‚îú‚îÄ tags.seed.json
   ‚îî‚îÄ articles.seed.json
```

---

### √âtape 1 ‚Äî Cr√©er les factories et seeders

> On commence par g√©n√©rer les fichiers n√©cessaires avec Artisan.
> Ces fichiers serviront √† d√©finir la structure des donn√©es et leur insertion.

```bash
php artisan make:factory TagFactory --model=Tag
php artisan make:factory ArticleFactory --model=Article

php artisan make:seeder TagSeeder
php artisan make:seeder ArticleSeeder
php artisan make:seeder PivotArticleTagSeeder
```

> üí° Variante pour un module Laravel (`nWidart` ou `spatie/laravel-modules`) :

```bash
php artisan module:make-seeder TagSeeder PkgBlog
```

---

### √âtape 2 ‚Äî D√©finir les **factories**

> Une factory d√©finit la logique de g√©n√©ration de donn√©es fictives :
> ici, des `tags` et des `articles` avec des champs al√©atoires mais coh√©rents.

{% raw %}

```php
<?php
// database/factories/TagFactory.php
namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Str;
use App\Models\Tag;

class TagFactory extends Factory
{
    protected $model = Tag::class;

    public function definition(): array
    {
        $name = $this->faker->unique()->words(rand(1, 2), true);
        return [
            'name' => ucfirst($name),
            'slug' => Str::slug($name) . '-' . Str::random(5),
        ];
    }
}
```

{% endraw %}

{% raw %}

```php
<?php
// database/factories/ArticleFactory.php
namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Str;
use App\Models\Article;
use App\Models\User;

class ArticleFactory extends Factory
{
    protected $model = Article::class;

    public function definition(): array
    {
        $title = $this->faker->unique()->sentence(4);
        return [
            'user_id'   => User::inRandomOrder()->value('id') ?? 1,
            'title'     => $title,
            'slug'      => Str::slug($title) . '-' . Str::random(6),
            'excerpt'   => $this->faker->sentence(12),
            'content'   => $this->faker->paragraphs(3, true),
            'created_at'=> now(),
            'updated_at'=> now(),
        ];
    }
}
```

{% endraw %}

> V√©rifiez que vos mod√®les `Article` et `Tag` utilisent bien le trait `HasFactory`.

---

### √âtape 3 ‚Äî Cr√©er le **TagSeeder**

> Ce seeder lit d‚Äôabord un fichier JSON s‚Äôil existe, sinon il utilise la factory.
> L‚Äôapproche `firstOrCreate` garantit l‚Äôidempotence (pas de doublons).

{% raw %}

```php
<?php
namespace Database\Seeders;

use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\File;
use App\Models\Tag;

class TagSeeder extends Seeder
{
    public function run(): void
    {
        $jsonPath = database_path('seeders/data/tags.seed.json');

        if (File::exists($jsonPath)) {
            $items = json_decode(File::get($jsonPath), true);
            foreach ($items as $it) {
                Tag::firstOrCreate(
                    ['slug' => $it['slug']],
                    ['name' => $it['name']]
                );
            }
        } else {
            Tag::factory()->count(12)->create();
        }
    }
}
```

{% endraw %}

---

### √âtape 4 ‚Äî Cr√©er le **ArticleSeeder**

> M√™me logique : lecture d‚Äôun JSON optionnel ou g√©n√©ration automatique.
> Chaque article est reli√© √† un utilisateur existant.

{% raw %}

```php
<?php
namespace Database\Seeders;

use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\File;
use App\Models\Article;

class ArticleSeeder extends Seeder
{
    public function run(): void
    {
        $jsonPath = database_path('seeders/data/articles.seed.json');

        if (File::exists($jsonPath)) {
            $items = json_decode(File::get($jsonPath), true);
            foreach ($items as $it) {
                Article::firstOrCreate(
                    ['slug' => $it['slug']],
                    [
                        'user_id' => $it['user_id'] ?? 1,
                        'title'   => $it['title'],
                        'excerpt' => $it['excerpt'] ?? null,
                        'content' => $it['content'] ?? '',
                        'created_at' => now(),
                        'updated_at' => now(),
                    ]
                );
            }
        } else {
            Article::factory()->count(20)->create();
        }
    }
}
```

{% endraw %}

---

### √âtape 5 ‚Äî Lier les `articles ‚Üî tags` (pivot)

> Ce seeder attache al√©atoirement 1 √† 4 tags par article
> en utilisant `syncWithoutDetaching()` pour √©viter les doublons.

{% raw %}

```php
<?php
namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\Article;
use App\Models\Tag;

class PivotArticleTagSeeder extends Seeder
{
    public function run(): void
    {
        $tagIds = Tag::pluck('id');

        Article::each(function ($article) use ($tagIds) {
            $attach = $tagIds->shuffle()->take(rand(1, 4))->all();
            $article->tags()->syncWithoutDetaching($attach);
        });
    }
}
```

{% endraw %}

---

### √âtape 6 ‚Äî Orchestration avec **DatabaseSeeder**

> Ce fichier ex√©cute les trois seeders dans le bon ordre.

{% raw %}

```php
<?php
namespace Database\Seeders;

use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    public function run(): void
    {
        $this->call([
            TagSeeder::class,
            ArticleSeeder::class,
            PivotArticleTagSeeder::class,
        ]);
    }
}
```

{% endraw %}

---

### √âtape 7 ‚Äî Ex√©cuter les semences

> Lancer le remplissage de la base avec :

```bash
php artisan db:seed
```

> Pour repartir d‚Äôune base vide et propre :

```bash
php artisan migrate:fresh --seed
```

---

## üîé V√©rification rapide avec Tinker

> On peut tester le r√©sultat directement en console Laravel :

```bash
php artisan tinker
```

{% raw %}

```php
Tag::count(); // >= 12
Article::count(); // ~20
Article::first()->tags->pluck('name'); // doit renvoyer 1 √† 4 tags
Tag::first()->articles()->count(); // > 0 si pivot OK
```

{% endraw %}

---

## üßæ R√©sum√© et points-cl√©s

* **Factory** = g√©n√©ration de donn√©es ; **Seeder** = insertion orchestr√©e.
* `firstOrCreate()` rend les seeders **idempotents** (r√©ex√©cutables sans doublons).
* `syncWithoutDetaching()` maintient les relations n-n sans √©craser les anciennes.
* `migrate:fresh --seed` restaure une **base coh√©rente et reproductible**.

---

## ü©∫ D√©pannage courant

| Probl√®me                                  | Cause              | Solution                                                    |
| ----------------------------------------- | ------------------ | ----------------------------------------------------------- |
| `Integrity constraint violation (unique)` | Slug dupliqu√©      | Ajouter suffixe al√©atoire ou `firstOrCreate()`              |
| `Cannot add or update a child row`        | FK inexistante     | Ordonner seeders (parents avant enfants)                    |
| `MassAssignmentException`                 | `$fillable` absent | Ajouter `$fillable` ou `$guarded = []` dans le mod√®le       |
| `Class not found`                         | Mauvais namespace  | V√©rifier `use App\Models\...` dans les factories et seeders |
