---
title: 4. Index cibl√©s
layout: home
nav_order: 4
parent: 2.2. Eloquent avanc√©
permalink: /eloquent-avance/2-2-4-index-explain/
---

# üìò Chapitre 2.2.4 ‚Äî Index cibl√©s & lecture d‚Äôun `EXPLAIN` simple

## üìí Glossaire minute
- **Index** : structure (souvent **BTREE**) qui acc√©l√®re les recherches/tri/jointures.
- **S√©lectivit√©** : capacit√© d‚Äôune colonne √† **r√©duire** le nombre de lignes (haute = bon candidat).
- **Index composite** : index sur **plusieurs colonnes** (`(user_id, created_at)`).
- **R√®gle du pr√©fixe gauche** : dans un index composite, l‚Äôordre **compte** (l‚Äôindex peut servir pour `user_id` seul, puis `user_id, created_at`, etc.).
- **Covering index** : l‚Äôindex contient **toutes** les colonnes demand√©es par la requ√™te ‚Üí moins d‚Äôacc√®s table.
- **FULLTEXT** : index texte pour `MATCH ... AGAINST` (recherche typ√©e).
- **`EXPLAIN`** : plan choisi par l‚Äôoptimiseur (colonnes cl√©s : `key`, `rows`, `Extra`).

## üéØ Objectif p√©dagogique
Choisir et cr√©er des **index utiles** (simples/composites/fulltext), puis **v√©rifier** leur utilisation avec `EXPLAIN` pour am√©liorer **WHERE / JOIN / ORDER BY** sans sur-indexer.

---

## üîç Exemple appliqu√© au fil rouge
**Blog Laravel** ‚Äî cas fr√©quents :
- D√©tail par **slug** (`WHERE slug = ?`).
- Liste des articles d‚Äôun **auteur** tri√©s par **date** (`WHERE user_id = ? ORDER BY created_at DESC`).
- Filtre par **tag** (`JOIN article_tag`) + tri.
- Recherche texte **plein-texte** sur `title` / `content`.

---

## üõ† Tutoriel pratique

**Arborescence cibl√©e :**
```

database/migrations/2025\_..\_add\_indexes\_to\_articles.php
app/Http/Controllers/ArticleController.php (requ√™tes)

````

### √âtape 1 ‚Äî Identifier les requ√™tes cl√©s

- **WHERE exact** : `where('slug', $slug)`
- **Filtres + tri** : `where('user_id', $id)->orderBy('created_at','desc')`
- **Jointure pivot** : `whereHas('tags', ...)`
- **Recherche** : `whereFullText(['title','content'], $q)` (MySQL 8)

> Indice : indexer les **FK**, les colonnes tr√®s filtrantes, et les colonnes utilis√©es pour le **tri** conjointement au filtre.

### √âtape 2 ‚Äî Cr√©er des index dans une migration

```php
<?php
// database/migrations/2025_08_27_000001_add_indexes_to_articles.php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration {
  public function up(): void {
    Schema::table('articles', function (Blueprint $table) {
      // D√©tail par slug
      $table->unique('slug'); // si pas d√©j√† unique

      // Liste d'un auteur tri√©e par date
      $table->index(['user_id', 'created_at']); // composite (pr√©fixe gauche)

      // (Optionnel) FULLTEXT pour recherche (MySQL 8+)
      // $table->fullText(['title','content']); // uncomment si besoin
    });

    Schema::table('article_tag', function (Blueprint $table) {
      // Assure un acc√®s rapide par article OU par tag
      $table->index('article_id');
      $table->index('tag_id');
      // PK composite (article_id, tag_id) normalement d√©j√† pos√©e
    });
  }

  public function down(): void {
    Schema::table('articles', function (Blueprint $table) {
      $table->dropUnique(['slug']);
      $table->dropIndex(['user_id', 'created_at']);
      // $table->dropFullText(['title','content']);
    });

    Schema::table('article_tag', function (Blueprint $table) {
      $table->dropIndex(['article_id']);
      $table->dropIndex(['tag_id']);
    });
  }
};
````

> Bon r√©flexe : **d√©clarer explicitement** les index n√©cessaires (ne pas d√©pendre d‚Äôajouts implicites).

### √âtape 3 ‚Äî V√©rifier avec `EXPLAIN`

```php
use Illuminate\Support\Facades\DB;

// 1) Par slug (devrait utiliser l'index UNIQUE slug)
DB::select('EXPLAIN SELECT id, title FROM articles WHERE slug = ?', [$slug]);

// 2) Auteur + tri par date (devrait utiliser (user_id, created_at))
DB::select('EXPLAIN SELECT id, title FROM articles WHERE user_id = ? ORDER BY created_at DESC', [$userId]);

// 3) Via pivot tag (v√©rifier l'usage des index sur article_tag.tag_id)
DB::select('EXPLAIN
  SELECT a.id, a.title
  FROM articles a
  JOIN article_tag at ON at.article_id = a.id
  JOIN tags t        ON t.id = at.tag_id
  WHERE t.slug = ?
  ORDER BY a.created_at DESC
', [$tagSlug]);

// 4) FULLTEXT (si activ√©)
DB::select('EXPLAIN SELECT id FROM articles WHERE MATCH(title,content) AGAINST (? IN BOOLEAN MODE)', [$q]);
```

**Cl√©s d‚Äôinterpr√©tation :**

* `key` = index **effectivement** utilis√© (‚â† `possible_keys`).
* `rows` = **lignes estim√©es** parcourues (plus petit est mieux).
* `Extra` :

  * `Using index` = covering index (excellente nouvelle),
  * `Using where` = filtre appliqu√©,
  * `Using filesort` = tri m√©moire/disque ‚Üí r√©fl√©chir √† un index supportant le tri,
  * `Using temporary` = table temporaire ‚Üí voir `GROUP BY` / `DISTINCT`.

### √âtape 4 ‚Äî Ajuster l‚Äôordre des colonnes (composite)

* **√âgalit√©s d‚Äôabord**, **plage ensuite** : `(user_id, created_at)` aide `WHERE user_id = ? ORDER BY created_at`.
* `(created_at, user_id)` serait **moins utile** si le filtre est surtout sur `user_id`.
* La **r√®gle du pr√©fixe gauche** permet d‚Äôutiliser l‚Äôindex pour :

  * `(user_id)` seul,
  * `(user_id, created_at)`.

### √âtape 5 ‚Äî Covering index (exemple cibl√©)

```sql
-- Pour couvrir SELECT id, slug, title WHERE slug = ?
-- L‚Äôunicit√© sur slug suffit souvent ; pour d‚Äôautres cas :
CREATE INDEX idx_articles_user_created_title ON articles (user_id, created_at, title);
-- La requ√™te SELECT title WHERE user_id=? ORDER BY created_at pourra √™tre "Using index"
```

> Objectif : que la requ√™te lise **seulement** l‚Äôindex (pas la table).

### √âtape 6 ‚Äî Recherche plein-texte (optionnel MySQL 8)

**Migration** :

```php
Schema::table('articles', function (Blueprint $table) {
    $table->fullText(['title','content']);
});
```

**Requ√™te Eloquent** :

```php
$items = \App\Models\Article::whereFullText(['title','content'], $request->q)->paginate();
```

> Pr√©f√©rer FULLTEXT pour une **vraie recherche** (mise √† l‚Äô√©chelle meilleure que `LIKE %q%`).

---

## üß™ V√©rifications rapides (Tinker)

```php
// 1) Index slug utilis√© ?
DB::select('EXPLAIN SELECT id FROM articles WHERE slug = ?', ['mon-slug']);

// 2) Composite (user_id, created_at) utilis√© ?
DB::select('EXPLAIN SELECT id FROM articles WHERE user_id=? ORDER BY created_at DESC', [1]);

// 3) Pivot index√© ?
DB::select('EXPLAIN SELECT a.id FROM article_tag at JOIN articles a ON a.id=at.article_id WHERE at.tag_id=?', [1]);

// 4) FULLTEXT (si activ√©)
DB::select('EXPLAIN SELECT id FROM articles WHERE MATCH(title,content) AGAINST (? IN NATURAL LANGUAGE MODE)', ['laravel']);
```

---

## üßæ R√©sum√© et points-cl√©s

* Indexer ce qui sert √† **WHERE/JOIN/ORDER BY** ; viser une **haute s√©lectivit√©**.
* **Composite** : l‚Äôordre des colonnes est **strat√©gique** (√©galit√© ‚Üí plage ‚Üí tri).
* Utiliser `EXPLAIN` pour v√©rifier `key`, `rows`, `Extra` et **it√©rer**.
* **Ne pas sur-indexer** : chaque index a un **co√ªt** (√©criture, stockage).
* **FULLTEXT** pour recherches textuelles s√©rieuses (MySQL 8).

---

## ü©∫ D√©pannage (fr√©quents)

| Probl√®me                | Cause                                  | Correctif                                                          |
| ----------------------- | -------------------------------------- | ------------------------------------------------------------------ |
| `Using filesort` au tri | Index ne couvre pas l‚Äô`ORDER BY`       | Ajouter colonne(s) de tri √† l‚Äôindex composite                      |
| `rows` tr√®s √©lev√©       | Colonne peu s√©lective                  | Indexer une colonne plus discriminante ou composite                |
| Index non utilis√©       | Ordre des colonnes inad√©quat / casting | R√©ordonner l‚Äôindex, √©viter fonctions sur la colonne (`LOWER(col)`) |
| Jointure lente pivot    | Absence d‚Äôindex sur `article_tag`      | Indexer **`article_id`** et **`tag_id`**                           |

---

## ‚úÖ Checklist d‚Äôacceptation

* [ ] Index **`slug`** (unique) pr√©sent et **utilis√©** (`EXPLAIN`).
* [ ] Composite **`(user_id, created_at)`** en place pour la liste par auteur.
* [ ] Index sur **pivot** (`article_tag.article_id`, `article_tag.tag_id`) op√©rationnels.
* [ ] `EXPLAIN` montre une **baisse de `rows`** et pas de `Using temporary` inutile.
* [ ] Pas d‚Äôindex redondants / inutiles (revue p√©riodique).
