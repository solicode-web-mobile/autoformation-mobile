---
title: 3. Transactions
layout: home
nav_order: 3
parent: 2.2. Eloquent avanc√©
permalink: /eloquent-avance/transactions/
code: 2.2.3
competence: C2
autoformation: "C2.2"
ua: "2.2.U2"
duree_h: 1.5
objectif: "√âcrire des op√©rations atomiques avec DB::transaction, g√©rer erreurs/concurrences et retries."
notions_nouvelles: ["Transaction", "ACID", "Deadlock", "Isolation level", "FOR UPDATE", "Idempotence"]
fil_rouge: "Blog Laravel + App Mobile (lecture & ranking)"
livrable_chapitre: "Service applicatif avec DB::transaction (cr√©ation Article + tags) + exemple lockForUpdate()"
alimentation_prototype: "N2 : √©criture s√ªre (ex. compteur/avg) avec rollback en cas d‚Äô√©chec"
alimentation_miniprojet: "N3 : POST note (anti-double vote) avec recalcul transactionnel + retry deadlock"
---


# üìò Chapitre 2.2.3 ‚Äî Transactions ACID, `commit/rollback`

## üìí Glossaire minute
- **Transaction** : bloc d‚Äôop√©rations qui r√©ussissent **toutes** ou **aucune**.
- **ACID** : *Atomicity, Consistency, Isolation, Durability* ‚Äî garanties d‚Äôune transaction.
- **Deadlock** : blocage circulaire entre transactions concurrentes.
- **Isolation level** : r√®gle de visibilit√© entre transactions (ex. `READ COMMITTED`).
- **`FOR UPDATE`** : verrou exclusif sur les lignes lues pour pr√©venir les courses critiques.
- **Idempotent** : ex√©cutable plusieurs fois sans effet ind√©sirable.

## üéØ Objectif p√©dagogique
√âcrire des op√©rations **atomiques** avec `DB::transaction`, g√©rer les **erreurs** (`rollback`), traiter les **concurrences** (retries, verrous) et choisir un **niveau d‚Äôisolation** adapt√©.

---

## üîç Exemple appliqu√© au fil rouge
Dans le **Blog Laravel** :
- Cr√©er un article **et** associer ses **tags** ; si l‚Äôun √©choue ‚Üí **rien** n‚Äôest √©crit.
- Mettre √† jour un compteur (ex. `views_count`) **sans course critique** via `FOR UPDATE`.
- R√©essayer automatiquement en cas de **deadlock**.

---

## üõ† Tutoriel pratique

> Fichier(s) impliqu√©s : contr√¥leur de domaine (ex. `ArticleController`), service applicatif √©ventuel, mod√®les `Article` / `Tag`.

### √âtape 1 ‚Äî Transaction simple (closure)

```php
<?php
use Illuminate\Support\Facades\DB;
use App\Models\Article;

$article = DB::transaction(function () use ($request) {
    // 1) Cr√©er l'article
    $article = Article::create([
        'user_id' => auth()->id() ?? 1,
        'title'   => $request->string('title'),
        'slug'    => $request->string('slug') ?: \Str::slug($request->string('title')),
        'excerpt' => $request->string('excerpt'),
        'content' => $request->string('content'),
    ]);

    // 2) Associer les tags
    $tagIds = $request->input('tag_ids', []);
    $article->tags()->sync($tagIds);

    // 3) Tout OK ‚Üí commit implicite
    return $article;
}); // Exception ‚Üí rollback automatique
````

### √âtape 2 ‚Äî Version `try/catch` (journaliser l‚Äôerreur)

```php
use Illuminate\Support\Facades\Log;

try {
    DB::beginTransaction();

    $article = Article::create([...]);
    $article->tags()->sync($request->input('tag_ids', []));

    DB::commit();
} catch (\Throwable $e) {
    DB::rollBack();
    Log::error('Transaction Article √©chou√©e', ['error' => $e->getMessage()]);
    throw $e; // ou return back()->with('error','Cr√©ation impossible');
}
```

### √âtape 3 ‚Äî G√©rer les **deadlocks** (retries)

```php
// Rejoue la transaction jusqu'√† 3 fois si deadlock d√©tect√©
$article = DB::transaction(function () use ($request) {
    $article = Article::create([...]);
    $article->tags()->sync($request->input('tag_ids', []));
    return $article;
}, 3);
```

> Astuce : limitez la **dur√©e** de vos transactions (pas d‚ÄôIO externe, pas d‚Äôenvoi d‚Äôemail dedans).

### √âtape 4 ‚Äî Concurrence : verrouiller la ligne (`FOR UPDATE`)

Exemple : s√©curiser une mise √† jour de compteur pour √©viter les pertes d‚Äôincr√©ments.

```php
use Illuminate\Support\Facades\DB;

// Dans une transaction :
DB::transaction(function () use ($articleId) {
    // Verrouille la ligne d'article
    $row = DB::table('articles')
        ->where('id', $articleId)
        ->lockForUpdate()   // SELECT ... FOR UPDATE
        ->first();

    // Mettre √† jour le compteur en se basant sur la valeur verrouill√©e
    DB::table('articles')
        ->where('id', $articleId)
        ->update(['views_count' => ($row->views_count ?? 0) + 1]);
});
```

> Alternative lecture partag√©e : `sharedLock()` (lecture verrouill√©e, non exclusive).

### √âtape 5 ‚Äî Niveau d‚Äôisolation (optionnel)

```php
// MySQL par d√©faut : REPEATABLE READ. Exemple pour READ COMMITTED (session courante) :
DB::statement('SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED');

DB::transaction(function () {
    // op√©rations sensibles √† l‚Äôisolation
});
```

### √âtape 6 ‚Äî Idempotence (√©viter les doublons si r√©essais)

```php
// Exemple "upsert" sur une table pivot ou table d‚Äô√©v√©nements
Article::updateOrCreate(
    ['slug' => $slug],
    ['title' => $title, 'excerpt' => $excerpt, 'content' => $content]
);
```

### √âtape 7 ‚Äî Effets secondaires **apr√®s** le commit

```php
$article = DB::transaction(function () use ($request) {
    // ... cr√©er article + tags ...
    return $article;
});

// Ici seulement : mails, notifications, indexation, broadcast‚Ä¶
\Mail::to($author)->send(new \App\Mail\ArticlePublished($article));
```

---

## üß™ V√©rifications rapides (Tinker)

```php
// 1) Tout-ou-rien
try {
  DB::transaction(function () {
    $a = \App\Models\Article::create(['user_id'=>1,'title'=>'Tx test','slug'=>\Str::random(8)]);
    // Forcer une erreur (ex: FK pivot invalide)
    DB::table('article_tag')->insert(['article_id'=>$a->id,'tag_id'=>999999]); // devrait √©chouer
  });
} catch (\Throwable $e) {}
\App\Models\Article::where('title','Tx test')->exists(); // false si rollback OK

// 2) Deadlock retry (simuler en deux sessions concurrentes) : la transaction finit par passer ou lever une exception
```

---

## üßæ R√©sum√© et points-cl√©s

* **Transactions** : regrouper les √©critures critiques ‚Üí `DB::transaction(...)`.
* **Pas d‚Äôeffets externes** dans la transaction ; d√©clencher **apr√®s** le commit.
* **Concurrence** : `lockForUpdate()` pour des mises √† jour d√©terministes.
* **Robustesse** : g√©rer/rejouer les **deadlocks**, garder les blocs **courts**.
* **Isolation** : ajuster au besoin (`READ COMMITTED` vs d√©faut MySQL).

---

## ü©∫ D√©pannage (fr√©quents)

| Probl√®me                            | Cause                               | Solution                                                                              |
| ----------------------------------- | ----------------------------------- | ------------------------------------------------------------------------------------- |
| `Deadlock found` (40001)            | Acc√®s concurrent invers√©            | R√©duire la dur√©e, ordre d‚Äôacc√®s identique, **retries** avec `DB::transaction(..., 3)` |
| `Lock wait timeout exceeded` (1205) | Verrou tenu trop longtemps          | Raccourcir la transaction, √©viter requ√™tes lentes/tri sans index                      |
| √âv√©nements envoy√©s 2√ó               | R√©essai apr√®s exception             | Rendre l‚Äôop√©ration **idempotente** (`updateOrCreate`, cl√© unique)                     |
| Incoh√©rences apr√®s crash            | Effets externes dans la transaction | D√©placer mails/notifications **apr√®s** le commit                                      |

---

## ‚úÖ Checklist d‚Äôacceptation

* [ ] Op√©rations critiques encapsul√©es dans `DB::transaction`.
* [ ] Aucune op√©ration externe (mail, HTTP) **dans** la transaction.
* [ ] Concurrence couverte (`lockForUpdate` sur les √©critures sensibles).
* [ ] Retry deadlock configur√© (‚â• 2 tentatives) pour les blocs √† risque.
* [ ] Tests manuels OK : √©chec partiel ‚áí **rollback** int√©gral.

