---
title: 1. Scopes & requêtes
layout: home
nav_order: 1
parent: 2.2. Eloquent avancé
permalink: /eloquent-avance/scopes-requetes/
code: 2.2.1
competence: C2
autoformation: "C2.2"
ua: "2.2.U1"
duree_h: 1.5
objectif: "Structurer des requêtes maintenables avec scopes, filtres conditionnels et sous-requêtes/EXISTS."
notions_nouvelles: ["Scope local", "Scope global", "when()", "Sous-requête", "EXISTS/NOT EXISTS"]
fil_rouge: "Blog Laravel + App Mobile (lecture & ranking)"
livrable_chapitre: "Méthodes Article::search(), Article::filter() et withLastCommentDate() + liste paginée fonctionnelle"
alimentation_prototype: "N2 : recherche/tri multi-critères côté /api/articles"
alimentation_miniprojet: "N3 : page Liste avec tri/filtre + ordre par dernière activité"
---


# 📘 Chapitre 2.2.1 — Scopes & requêtes complexes

## 📒 Glossaire minute
- **Scope local** : méthode `scopeXxx()` dans un modèle qui **réutilise** un filtre (`Article::published()->search('laravel')`).
- **Scope global** : règle appliquée **automatiquement** à toutes les requêtes d’un modèle (ex. `published = 1`).
- **when()** : applique **conditionnellement** un morceau de requête selon une valeur d’entrée.
- **Sous-requête (subquery)** : requête imbriquée dans un `SELECT`/`ORDER BY` via `selectSub()` / `addSelect()`.
- **EXISTS / NOT EXISTS** : filtre performant basé sur l’**existence** de lignes associées.

## 🎯 Objectif pédagogique
Structurer des **requêtes expressives et maintenables** : créer des **scopes locaux** réutilisables, enchaîner des **filtres conditionnels**, et intégrer des **sous-requêtes** / `EXISTS` pour résoudre des cas métiers sans multiplier les contrôleurs.

---

## 🔍 Exemple appliqué au fil rouge
Dans le **Blog Laravel**, on veut :
- Lister les articles **publiés** uniquement.
- Rechercher par **titre**/**extrait**/**contenu**.
- Filtrer par **auteur**, **période**, **statut**.
- Trier selon une **liste blanche** de colonnes (`created_at`, `title`, etc.).
- (Bonus) Pour l’ordre, utiliser la **date du dernier commentaire** via sous-requête.

---

## 🛠 Tutoriel pratique

**Arborescence ciblée :**
```

app/Models/Article.php
app/Models/Scopes/PublishedScope.php         (optionnel)
app/Http/Controllers/ArticleController.php   (index avec filtres)

````

### Étape 1 — Scopes locaux de base (`Article`)

```php
<?php
// app/Models/Article.php
namespace App\Models;

use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Support\Arr;
use Illuminate\Support\Str;
use Illuminate\Support\Facades\DB;

class Article extends Model
{
    use HasFactory;

    protected $fillable = ['user_id','title','slug','excerpt','content','is_published','published_at'];

    /* ---------- SCOPES LOCAUX ---------- */

    // 1) Publiés (ET publiés dans le passé si date fournie)
    public function scopePublished(Builder $q): Builder
    {
        return $q->where('is_published', true)
                 ->when($this->getConnection()->getDriverName() === 'mysql', fn($qq) =>
                     $qq->where(function ($qqq) {
                         $qqq->whereNull('published_at')->orWhere('published_at', '<=', now());
                     })
                 );
    }

    // 2) Recherche plein-texte "simple" (LIKE) sur plusieurs colonnes
    public function scopeSearch(Builder $q, ?string $term): Builder
    {
        $term = trim((string) $term);
        if ($term === '') return $q;

        $like = '%'.str_replace(['%','_'], ['\%','\_'], $term).'%';
        return $q->where(function ($qq) use ($like) {
            $qq->where('title', 'like', $like)
               ->orWhere('excerpt', 'like', $like)
               ->orWhere('content', 'like', $like);
        });
    }

    // 3) Filtre "combiné" & tri (liste blanche)
    public function scopeFilter(Builder $q, array $filters): Builder
    {
        $authorId = Arr::get($filters, 'author');
        $status   = Arr::get($filters, 'status');    // 'published' | 'draft' | null
        $from     = Arr::get($filters, 'from');      // 'YYYY-mm-dd'
        $to       = Arr::get($filters, 'to');
        $sort     = Arr::get($filters, 'sort', '-created_at'); // ex: "-created_at", "title"

        $q->when($authorId, fn($qq) => $qq->where('user_id', $authorId));

        $q->when($status === 'published', fn($qq) => $qq->where('is_published', true))
          ->when($status === 'draft',     fn($qq) => $qq->where('is_published', false));

        $q->when($from, fn($qq) => $qq->whereDate('created_at', '>=', $from))
          ->when($to,   fn($qq) => $qq->whereDate('created_at', '<=', $to));

        // Tri sécurisé (liste blanche)
        $allowed = ['created_at','title','published_at'];
        $dir = Str::startsWith($sort, '-') ? 'desc' : 'asc';
        $col = ltrim($sort, '-');

        if (! in_array($col, $allowed, true)) {
            $col = 'created_at'; $dir = 'desc';
        }

        return $q->orderBy($col, $dir);
    }

    // 4) Sous-requête : date du dernier commentaire (si table comments existe)
    public function scopeWithLastCommentDate(Builder $q): Builder
    {
        return $q->addSelect([
            'last_comment_at' => DB::table('comments')
                ->selectRaw('MAX(comments.created_at)')
                ->whereColumn('comments.article_id', 'articles.id')
        ]);
    }
}
````

> Astuce : préférez `scopeFilter()` pour centraliser les règles de tri/filtre, vos contrôleurs restent **fins**.

---

### Étape 2 — Contrôleur : combiner les scopes

```php
<?php
// app/Http/Controllers/ArticleController.php (extrait index)
namespace App\Http\Controllers;

use App\Models\Article;
use Illuminate\Http\Request;

class ArticleController extends Controller
{
    public function index(Request $request)
    {
        $filters = $request->only(['q','author','status','from','to','sort']);

        $articles = Article::query()
            ->when($filters['q'] ?? null, fn($q, $term) => $q->search($term))
            ->filter($filters)
            ->withLastCommentDate()        // bonus : sous-requête
            ->paginate(12)
            ->appends($filters);           // conserve les paramètres dans la pagination

        return view('articles.index', compact('articles','filters'));
    }
}
```

---

### Étape 3 — Scope global (optionnel)

```php
<?php
// app/Models/Scopes/PublishedScope.php
namespace App\Models\Scopes;

use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Scope;

class PublishedScope implements Scope
{
    public function apply(Builder $builder, Model $model): void
    {
        $builder->where('is_published', true);
    }
}
```

```php
// app/Models/Article.php (dans class Article)
protected static function booted(): void
{
    // Applique le filtre "publié" partout (désactivable au besoin)
    // static::addGlobalScope(new \App\Models\Scopes\PublishedScope);
}
```

> Pour **désactiver temporairement** : `Article::withoutGlobalScopes()->get()` ou `->withoutGlobalScope(PublishedScope::class)`.

---

### Étape 4 — EXISTS / NOT EXISTS (exemples ciblés)

```php
use Illuminate\Support\Facades\DB;

// Articles qui ont au moins un commentaire
$withComments = \App\Models\Article::whereExists(function ($q) {
    $q->select(DB::raw(1))
      ->from('comments')
      ->whereColumn('comments.article_id', 'articles.id');
});

// Articles sans commentaire
$withoutComments = \App\Models\Article::whereNotExists(function ($q) {
    $q->select(DB::raw(1))
      ->from('comments')
      ->whereColumn('comments.article_id', 'articles.id');
});
```

---

## 🧪 Vérifications rapides (Tinker)

```bash
php artisan tinker
```

```php
// 1) Recherche + tri
App\Models\Article::search('laravel')->filter(['sort' => '-title'])->limit(3)->get(['id','title']);

// 2) Période + auteur
App\Models\Article::filter(['author'=>1,'from'=>'2025-01-01','to'=>'2025-12-31'])->count();

// 3) Dernier commentaire en colonne calculée
App\Models\Article::withLastCommentDate()->orderByDesc('last_comment_at')->take(3)->get(['id','title','last_comment_at']);

// 4) Désactiver le global scope (si activé)
App\Models\Article::withoutGlobalScopes()->where('is_published', false)->count();
```

---

## 🧾 Résumé et points-clés

* Les **scopes locaux** rendent les requêtes **lisibles et DRY** (`search`, `filter`, etc.).
* `when()` permet d’ajouter un filtre **seulement si** une valeur est fournie.
* Les **listes blanches** sécurisent le **tri** (évite l’injection via `orderBy`).
* Les **sous-requêtes** et **EXISTS** résolvent des besoins avancés sans surcharger l’Eloquent des relations.

---

## 🩺 Dépannage (fréquents)

| Problème                                                | Cause                                      | Solution                                                                    |
| ------------------------------------------------------- | ------------------------------------------ | --------------------------------------------------------------------------- |
| Tri non pris en compte                                  | Colonne non whitelistée                   | Vérifier la **liste blanche** dans `scopeFilter()`                          |
| SQL ambigu (`column 'id' in where clause is ambiguous`) | Jointures/sous-requêtes sans qualification | Utiliser des préfixes (`articles.id`) et `select('articles.*')`             |
| Recherche lente                                         | LIKE sur plusieurs colonnes non indexées   | Ajouter index sur les colonnes utiles ou basculer vers **FULLTEXT** (MySQL) |
| Global scope gênant                                     | Filtre appliqué partout                    | `withoutGlobalScope()` / **désactiver** au besoin                           |

---

## ✅ Checklist d’acceptation

* [ ] `scopeSearch()` et `scopeFilter()` **chainables** et testés.
* [ ] Tri **sécurisé** par **liste blanche**.
* [ ] `withLastCommentDate()` **ajoute** une colonne calculée exploitable (`ORDER BY`).
* [ ] Page index fonctionnelle avec filtres via query string (`?q=&author=&status=&from=&to=&sort=`).

