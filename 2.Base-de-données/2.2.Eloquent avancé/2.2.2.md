---
title: 2. Relations imbriquÃ©es
layout: home
nav_order: 2
parent: 2.2. Eloquent avancÃ©
permalink: /eloquent-avance/2-2-2-relations-imbriquees-bonnes-pratiques/
---

# ğŸ“˜ Chapitre 2.2.2 â€” Relations imbriquÃ©es & bonnes pratiques de requÃªtes

## ğŸ“’ Glossaire minute
- **Eager loading imbriquÃ©** : chargement de relations en profondeur (`with('comments.user')`).
- **Eager loading contraint** : limiter/filtrer ce qui est chargÃ© (`with(['comments' => fn($q) => $q->latest()->limit(5)])`).
- **`has / whereHas / doesntHave`** : filtrer **par existence** et conditions sur une relation.
- **`withCount / withSum / withExists`** : **agrÃ©gats** prÃ©-calculÃ©s dans la requÃªte.
- **`load / loadMissing`** : chargement **aprÃ¨s** rÃ©cupÃ©ration (lazy eager loading).
- **`select` ciblÃ©** : ne charger que les colonnes nÃ©cessaires (ex. `user:id,name`).
- **`chunkById / lazyById`** : traiter de gros volumes **sans explosion mÃ©moire**.

## ğŸ¯ Objectif pÃ©dagogique
Savoir combiner **relations imbriquÃ©es**, **filtres par relations**, **agrÃ©gats** et **sÃ©lections ciblÃ©es** pour des listes rapides, lisibles et faciles Ã  maintenir â€” sans **N+1**.

---

## ğŸ” Exemple appliquÃ© au fil rouge
Dans le **Blog Laravel** :
- Afficher la liste des **articles** avec **auteur**, **tags**, et les **5 derniers commentaires** (utilisateur inclus).
- Filtrer par **tags** et **pÃ©riode**, afficher le **nombre de commentaires** et trier par **activitÃ©** (date du dernier commentaire).

---

## ğŸ›  Tutoriel pratique

**Arborescence ciblÃ©e :**
```

app/Models/{Article,User,Tag,Comment}.php
app/Http/Controllers/ArticleController.php (index avancÃ©)
resources/views/articles/index.blade.php

````

### Ã‰tape 1 â€” ModÃ¨les & relations (rappel minimal)

```php
// app/Models/Article.php
class Article extends Model
{
    use HasFactory;

    public function user()    { return $this->belongsTo(User::class); }
    public function tags()    { return $this->belongsToMany(Tag::class); }
    public function comments(){ return $this->hasMany(Comment::class); }

    // Dernier commentaire (relation "un-de-plusieurs")
    public function latestComment()
    {
        return $this->hasOne(Comment::class)->latestOfMany(); // nÃ©cessite created_at
    }
}
````

```php
// app/Models/Comment.php
class Comment extends Model
{
    use HasFactory;

    protected $fillable = ['article_id','user_id','body'];

    public function article(){ return $this->belongsTo(Article::class); }
    public function user()   { return $this->belongsTo(User::class); }
}
```

### Ã‰tape 2 â€” Liste optimisÃ©e (imbriquÃ© + contraint + agrÃ©gats)

```php
// app/Http/Controllers/ArticleController.php (index avancÃ©)
public function index(\Illuminate\Http\Request $request)
{
    $filters = $request->only(['q','tag','from','to','sort']); // ex: ?tag=php&from=2025-01-01

    $articles = \App\Models\Article::query()
        // SÃ©lection ciblÃ©e cÃ´tÃ© parent
        ->select(['id','user_id','title','slug','created_at'])
        // Relations imbriquÃ©es + sÃ©lection ciblÃ©e
        ->with([
            'user:id,name',
            'tags:id,name,slug',
            // Charger seulement 5 comments rÃ©cents + auteur (sÃ©lection ciblÃ©e)
            'comments' => fn($q) => $q->latest('created_at')->limit(5)
                ->select(['id','article_id','user_id','body','created_at'])
                ->with(['user:id,name']),
        ])
        // AgrÃ©gats utiles pour la vue/tri
        ->withCount(['comments','tags'])
        ->withExists('comments as has_comments') // boolÃ©en calculÃ©
        // Filtres par relation (whereHas)
        ->when($filters['tag'] ?? null, function ($q, $tag) {
            $q->whereHas('tags', fn($qq) => $qq->where('slug', $tag));
        })
        // Filtres simples
        ->when($filters['from'] ?? null, fn($q,$d) => $q->whereDate('created_at','>=',$d))
        ->when($filters['to']   ?? null, fn($q,$d) => $q->whereDate('created_at','<=',$d))
        ->when($filters['q']    ?? null, fn($q,$term) => $q->where(function($qq) use ($term){
            $like = '%'.str_replace(['%','_'],['\%','\_'],$term).'%';
            $qq->where('title','like',$like)->orWhere('slug','like',$like);
        }))
        // Tri contrÃ´lÃ©
        ->when(($filters['sort'] ?? null) === 'comments', fn($q) => $q->orderByDesc('comments_count'))
        ->when(($filters['sort'] ?? null) === 'recent',   fn($q) => $q->latest('created_at'))
        ->paginate(12)
        ->appends($filters);

    return view('articles.index', compact('articles','filters'));
}
```

### Ã‰tape 3 â€” Variantes utiles

**a) Charger aprÃ¨s-coup sans dupliquer (lazy eager)**

```php
$articles = \App\Models\Article::latest('id')->take(20)->get(['id','user_id','title']);
$articles->loadMissing(['user:id,name']); // ne recharge pas si dÃ©jÃ  chargÃ©
```

**b) Articles ayant â‰¥ 3 commentaires sur 30 derniers jours**

```php
use Illuminate\Support\Facades\DB;

$hot = \App\Models\Article::whereHas('comments', function($q){
        $q->where('created_at', '>=', now()->subDays(30));
    }, '>=', 3)
    ->withCount(['comments as comments_last30' => function($q){
        $q->where('created_at', '>=', now()->subDays(30));
    }])
    ->orderByDesc('comments_last30')
    ->get();
```

**c) SÃ©lection minimale cÃ´tÃ© relation**

```php
$articles = \App\Models\Article::select(['id','title','user_id'])
    ->with(['user:id,name', 'tags:id,name'])
    ->get(); // pas de colonnes inutiles cÃ´tÃ© user/tags
```

**d) TrÃ¨s grandes listes (traitement batch)**

```php
\App\Models\Article::with('user:id,name')
    ->select(['id','user_id','title'])
    ->chunkById(500, function ($chunk) {
        foreach ($chunk as $a) {
            // export, indexation, etc.
        }
    });
```

**e) Dernier commentaire via relation "ofMany"**

```php
$articles = \App\Models\Article::with(['latestComment.user:id,name'])->get();
```

---

## ğŸ§ª VÃ©rifications rapides (Tinker)

```php
// 1) ImbriquÃ© + contraint
A = App\Models\Article::with(['comments'=>fn($q)=>$q->latest()->limit(5)->with('user:id,name')])->first();
A->comments->pluck('user.name');

// 2) Filtrer par relation
App\Models\Article::whereHas('tags', fn($q)=>$q->whereIn('slug',['php','laravel']))->count();

// 3) AgrÃ©gats
App\Models\Article::withCount('comments')->orderByDesc('comments_count')->take(5)->get(['id','title']);

// 4) Charger aprÃ¨s coup
$arts = App\Models\Article::take(10)->get(['id','user_id','title']);
$arts->loadMissing('user:id,name');
```

---

## ğŸ§¾ RÃ©sumÃ© et points-clÃ©s

* Toujours penser **sÃ©lection ciblÃ©e** (`select`, `relation:id,colsâ€¦`) pour rÃ©duire les IO.
* PrÃ©fÃ©rer **eager loading** (et **imbriquÃ©** si nÃ©cessaire) pour Ã©viter **N+1**.
* Utiliser **whereHas/has** pour **filtrer** par relations plutÃ´t que des jointures artisanales.
* Les **agrÃ©gats** `withCount/withSum/withExists` Ã©vitent des requÃªtes secondaires.
* **Limiter/ordonner** une relation via **eager loading contraint**.

---

## ğŸ©º DÃ©pannage (frÃ©quents)

| ProblÃ¨me                    | Cause                     | Solution                                                         |
| --------------------------- | ------------------------- | ---------------------------------------------------------------- |
| N+1 dans les boucles Blade  | Relations non prÃ©chargÃ©es | Ajouter `with()` cÃ´tÃ© requÃªte ou `loadMissing()` cÃ´tÃ© collection |
| RÃ©ponse lourde              | Trop de colonnes chargÃ©es | `select` cÃ´tÃ© parent + `relation:id,...` cÃ´tÃ© relations          |
| `column ambiguous`          | SÃ©lection non qualifiÃ©e   | PrÃ©fixer (`articles.id`) et limiter les `select`                 |
| Compte de commentaires faux | Filtre temporel manquant  | `withCount(['comments' => fn($q)=>$q->whereBetween(...)])`       |

---

## âœ… Checklist dâ€™acceptation

* [ ] Liste **sans N+1** (profilage : â‰¤ 3â€“4 requÃªtes pour la page).
* [ ] `withCount`/`whereHas` utilisÃ©s au bon endroit.
* [ ] **Eager loading imbriquÃ©** (ex. `comments.user`) fonctionnel.
* [ ] SÃ©lections **ciblÃ©es** parent + relations.

