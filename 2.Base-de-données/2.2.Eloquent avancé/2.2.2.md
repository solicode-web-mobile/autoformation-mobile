---
title: 2. Relations imbriquées
layout: home
nav_order: 2
parent: 2.2. Eloquent avancé
permalink: /eloquent-avance/2-2-2-relations-imbriquees-bonnes-pratiques/
---

# 📘 Chapitre 2.2.2 — Relations imbriquées & bonnes pratiques de requêtes

## 📒 Glossaire minute
- **Eager loading imbriqué** : chargement de relations en profondeur (`with('comments.user')`).
- **Eager loading contraint** : limiter/filtrer ce qui est chargé (`with(['comments' => fn($q) => $q->latest()->limit(5)])`).
- **`has / whereHas / doesntHave`** : filtrer **par existence** et conditions sur une relation.
- **`withCount / withSum / withExists`** : **agrégats** pré-calculés dans la requête.
- **`load / loadMissing`** : chargement **après** récupération (lazy eager loading).
- **`select` ciblé** : ne charger que les colonnes nécessaires (ex. `user:id,name`).
- **`chunkById / lazyById`** : traiter de gros volumes **sans explosion mémoire**.

## 🎯 Objectif pédagogique
Savoir combiner **relations imbriquées**, **filtres par relations**, **agrégats** et **sélections ciblées** pour des listes rapides, lisibles et faciles à maintenir — sans **N+1**.

---

## 🔍 Exemple appliqué au fil rouge
Dans le **Blog Laravel** :
- Afficher la liste des **articles** avec **auteur**, **tags**, et les **5 derniers commentaires** (utilisateur inclus).
- Filtrer par **tags** et **période**, afficher le **nombre de commentaires** et trier par **activité** (date du dernier commentaire).

---

## 🛠 Tutoriel pratique

**Arborescence ciblée :**
```

app/Models/{Article,User,Tag,Comment}.php
app/Http/Controllers/ArticleController.php (index avancé)
resources/views/articles/index.blade.php

````

### Étape 1 — Modèles & relations (rappel minimal)

```php
// app/Models/Article.php
class Article extends Model
{
    use HasFactory;

    public function user()    { return $this->belongsTo(User::class); }
    public function tags()    { return $this->belongsToMany(Tag::class); }
    public function comments(){ return $this->hasMany(Comment::class); }

    // Dernier commentaire (relation "un-de-plusieurs")
    public function latestComment()
    {
        return $this->hasOne(Comment::class)->latestOfMany(); // nécessite created_at
    }
}
````

```php
// app/Models/Comment.php
class Comment extends Model
{
    use HasFactory;

    protected $fillable = ['article_id','user_id','body'];

    public function article(){ return $this->belongsTo(Article::class); }
    public function user()   { return $this->belongsTo(User::class); }
}
```

### Étape 2 — Liste optimisée (imbriqué + contraint + agrégats)

```php
// app/Http/Controllers/ArticleController.php (index avancé)
public function index(\Illuminate\Http\Request $request)
{
    $filters = $request->only(['q','tag','from','to','sort']); // ex: ?tag=php&from=2025-01-01

    $articles = \App\Models\Article::query()
        // Sélection ciblée côté parent
        ->select(['id','user_id','title','slug','created_at'])
        // Relations imbriquées + sélection ciblée
        ->with([
            'user:id,name',
            'tags:id,name,slug',
            // Charger seulement 5 comments récents + auteur (sélection ciblée)
            'comments' => fn($q) => $q->latest('created_at')->limit(5)
                ->select(['id','article_id','user_id','body','created_at'])
                ->with(['user:id,name']),
        ])
        // Agrégats utiles pour la vue/tri
        ->withCount(['comments','tags'])
        ->withExists('comments as has_comments') // booléen calculé
        // Filtres par relation (whereHas)
        ->when($filters['tag'] ?? null, function ($q, $tag) {
            $q->whereHas('tags', fn($qq) => $qq->where('slug', $tag));
        })
        // Filtres simples
        ->when($filters['from'] ?? null, fn($q,$d) => $q->whereDate('created_at','>=',$d))
        ->when($filters['to']   ?? null, fn($q,$d) => $q->whereDate('created_at','<=',$d))
        ->when($filters['q']    ?? null, fn($q,$term) => $q->where(function($qq) use ($term){
            $like = '%'.str_replace(['%','_'],['\%','\_'],$term).'%';
            $qq->where('title','like',$like)->orWhere('slug','like',$like);
        }))
        // Tri contrôlé
        ->when(($filters['sort'] ?? null) === 'comments', fn($q) => $q->orderByDesc('comments_count'))
        ->when(($filters['sort'] ?? null) === 'recent',   fn($q) => $q->latest('created_at'))
        ->paginate(12)
        ->appends($filters);

    return view('articles.index', compact('articles','filters'));
}
```

### Étape 3 — Variantes utiles

**a) Charger après-coup sans dupliquer (lazy eager)**

```php
$articles = \App\Models\Article::latest('id')->take(20)->get(['id','user_id','title']);
$articles->loadMissing(['user:id,name']); // ne recharge pas si déjà chargé
```

**b) Articles ayant ≥ 3 commentaires sur 30 derniers jours**

```php
use Illuminate\Support\Facades\DB;

$hot = \App\Models\Article::whereHas('comments', function($q){
        $q->where('created_at', '>=', now()->subDays(30));
    }, '>=', 3)
    ->withCount(['comments as comments_last30' => function($q){
        $q->where('created_at', '>=', now()->subDays(30));
    }])
    ->orderByDesc('comments_last30')
    ->get();
```

**c) Sélection minimale côté relation**

```php
$articles = \App\Models\Article::select(['id','title','user_id'])
    ->with(['user:id,name', 'tags:id,name'])
    ->get(); // pas de colonnes inutiles côté user/tags
```

**d) Très grandes listes (traitement batch)**

```php
\App\Models\Article::with('user:id,name')
    ->select(['id','user_id','title'])
    ->chunkById(500, function ($chunk) {
        foreach ($chunk as $a) {
            // export, indexation, etc.
        }
    });
```

**e) Dernier commentaire via relation "ofMany"**

```php
$articles = \App\Models\Article::with(['latestComment.user:id,name'])->get();
```

---

## 🧪 Vérifications rapides (Tinker)

```php
// 1) Imbriqué + contraint
A = App\Models\Article::with(['comments'=>fn($q)=>$q->latest()->limit(5)->with('user:id,name')])->first();
A->comments->pluck('user.name');

// 2) Filtrer par relation
App\Models\Article::whereHas('tags', fn($q)=>$q->whereIn('slug',['php','laravel']))->count();

// 3) Agrégats
App\Models\Article::withCount('comments')->orderByDesc('comments_count')->take(5)->get(['id','title']);

// 4) Charger après coup
$arts = App\Models\Article::take(10)->get(['id','user_id','title']);
$arts->loadMissing('user:id,name');
```

---

## 🧾 Résumé et points-clés

* Toujours penser **sélection ciblée** (`select`, `relation:id,cols…`) pour réduire les IO.
* Préférer **eager loading** (et **imbriqué** si nécessaire) pour éviter **N+1**.
* Utiliser **whereHas/has** pour **filtrer** par relations plutôt que des jointures artisanales.
* Les **agrégats** `withCount/withSum/withExists` évitent des requêtes secondaires.
* **Limiter/ordonner** une relation via **eager loading contraint**.

---

## 🩺 Dépannage (fréquents)

| Problème                    | Cause                     | Solution                                                         |
| --------------------------- | ------------------------- | ---------------------------------------------------------------- |
| N+1 dans les boucles Blade  | Relations non préchargées | Ajouter `with()` côté requête ou `loadMissing()` côté collection |
| Réponse lourde              | Trop de colonnes chargées | `select` côté parent + `relation:id,...` côté relations          |
| `column ambiguous`          | Sélection non qualifiée   | Préfixer (`articles.id`) et limiter les `select`                 |
| Compte de commentaires faux | Filtre temporel manquant  | `withCount(['comments' => fn($q)=>$q->whereBetween(...)])`       |

---

## ✅ Checklist d’acceptation

* [ ] Liste **sans N+1** (profilage : ≤ 3–4 requêtes pour la page).
* [ ] `withCount`/`whereHas` utilisés au bon endroit.
* [ ] **Eager loading imbriqué** (ex. `comments.user`) fonctionnel.
* [ ] Sélections **ciblées** parent + relations.

