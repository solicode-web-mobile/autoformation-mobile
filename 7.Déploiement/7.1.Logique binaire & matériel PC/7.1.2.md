---
title: 2. OpÃ©rateurs
permalink: /deploiement/c7-1/operateurs-decalages-masques/
layout: home
nav_order: 2
parent: 7.1. Logique binaire & matÃ©riel PC
---

# ğŸ“˜ Chapitre 7.1.2 â€” OpÃ©rateurs 

## ğŸ“’ Glossaire minute
- **ET (AND, `&`)** : garde les bits mis Ã  1 **dans les deux** opÃ©randes.  
- **OU (OR, `|`)** : garde les bits Ã  1 **dans au moins un** opÃ©rande.  
- **XOR (`^`)** : 1 si les bits sont **diffÃ©rents** (toggle).  
- **NOT (`~`)** : inverse tous les bits (attention Ã  la **taille** en bits).  
- **DÃ©calages (`<<`, `>>`)** : multiplication/division par 2â¿ (cf. signe).  
- **Masque** : motif binaire pour **tester/poser/retirer/basculer** des bits (flags).  
- **LSB/MSB** : bit de poids faible/fort (droite/gauche dans lâ€™octet).

---

## ğŸ¯ Objectifs
- Savoir appliquer **ET/OU/XOR/NOT** sur des octets et des nibbles.  
- Comprendre lâ€™effet de `<<` et `>>` (zÃ©ro vs **extension de signe**).  
- MaÃ®triser les **masques** pour lire/modifier des **drapeaux** (flags) et extraire des champs.

## âœ… PrÃ©-requis
- 7.1.1 : conversions **binaire/hex/dÃ©cimal** (grouper par nibbles).

---

## 1) Tables de vÃ©ritÃ© (sur 1 bit)
| A | B | A **ET** B | A **OU** B | A **XOR** B | **NOT** A |
|:-:|:-:|:----------:|:----------:|:-----------:|:---------:|
| 0 | 0 | 0 | 0 | 0 | 1 |
| 0 | 1 | 0 | 1 | 1 | 1 |
| 1 | 0 | 0 | 1 | 1 | 0 |
| 1 | 1 | 1 | 1 | 0 | 0 |

> **Raccourci Hex** : faites les opÃ©rations **par nibble** (4 bits) en hex (ex. `0xA & 0xB = 0xA`).

---

## 2) OpÃ©rations sur octets (exemples)
Prenons :  
`A = 0x6D = 0110 1101â‚‚` (109)  
`B = 0x53 = 0101 0011â‚‚` (83)

- **ET** : `A & B = 0111?` â†’ non, calcul exact :  
  `0110 1101`  
  `0101 0011`  
  **&** â†’ `0100 0001` = **0x41** (65)

- **OU** : `A | B = 0111 1111` = **0x7F** (127)  
- **XOR** : `A ^ B = 0011 1110` = **0x3E** (62)  
- **NOT** (sur 8 bits) : `~A = 1001 0010` = **0x92** (146)

> **Attention** : `~` dÃ©pend de la **largeur** (8/16/32 bits). Toujours prÃ©ciser le contexte.

---

## 3) DÃ©calages : `<<` et `>>`
- `x << n` : dÃ©cale Ã  **gauche** â†’ **Ã— 2â¿** (remplit par **0** Ã  droite).  
- `x >> n` : dÃ©cale Ã  **droite** â†’ **Ã· 2â¿** (selon langage :  
  **logique** â†’ remplit par 0 ; **arithmÃ©tique** â†’ **propage le signe**).

Ex. `x = 0x1A = 0001 1010â‚‚` (26)  
- `x << 3 = 1101 0000â‚‚` = **0xD0** (208)  
- `x >> 2 = 0000 0110â‚‚` = **0x06** (6)

> **Astuce** : dÃ©composer/composer des **champs** (bitfields) avec dÃ©calages + masques.

---

## 4) Masques : tester/poser/retirer/basculer des **flags**
Convention : **bit0** = LSB (tout Ã  droite).

Imaginons des droits sur 3 bits :  
`bit0=READ`, `bit1=WRITE`, `bit2=EXEC`.  
`flags = 0b0000_0101` (READ + EXEC).

- **Tester** si READ actif :  
  `if (flags & (1 << 0)) { ... }` â†’ **vrai**

- **Poser** WRITE :  
  `flags |= (1 << 1)` â†’ `0b0000_0111`

- **Retirer** EXEC :  
  `flags &= ~(1 << 2)` â†’ `0b0000_0011`

- **Basculer** READ :  
  `flags ^= (1 << 0)` â†’ toggle du bit0

### 4.1 Extraire un **champ** (plusieurs bits)
Ex. `x = 0b1010_1101`, champ **3 bits** Ã  partir du **bit2** :  
`mask = 0b0001_1100`  
`val = (x & mask) >> 2`  â†’ isole le champ et le **rÃ©aligne**.

### 4.2 (Lien rÃ©seau) **Masques IPv4** (aperÃ§u)
- `/26` â†’ 255.255.255.**192** = `11111111.11111111.11111111.11000000`  
  Bits hÃ´te = 6 â†’ **62 hÃ´tes** utilisables (2â¶ âˆ’ 2).  
Utile en **C7.2** pour le **plan dâ€™adressage**.

---

## 5) Exercices (avec rÃ©ponses)
**E1.** `0xF0 & 0x3C = ?`  
â†’ `1111 0000 & 0011 1100 = 0011 0000` = **0x30**

**E2.** `0b0101_1010 ^ 0b0011_0011 = ?`  
â†’ `0110 1001` = **0x69**

**E3.** `x=0b0001_1010`, calculer `x<<2` et `x>>3`  
â†’ `x<<2 = 0110 1000` (**0x68**), `x>>3 = 0000 0011` (**0x03**)

**E4.** Activez les bits `0` et `3` de `flags=0b0000_0000`  
â†’ `flags |= (1<<0) | (1<<3)` â†’ `0b0000_1001`

**E5.** Extrayez le champ 4 bits `[bit4..bit7]` de `x=0b1101_0110`  
â†’ `mask=0b1111_0000`, `(x & mask) >> 4 = 0b1101` = **0xD** (13)

---

## ğŸ©¹ DÃ©pannage (erreurs frÃ©quentes)
- Confusion **logique** vs **bit-Ã -bit** (`&&`/`||` vs `&`/`|`).  
- Oublier la **largeur** lors de `~` (rÃ©sultat nÃ©gatif inattendu).  
- DÃ©calage **arithmÃ©tique** vs **logique** sur des **signÃ©s** (`>>` propage le signe).  
- Oublier de **grouper par 4 bits** avant dâ€™opÃ©rer en **hex**.

---

## ğŸ”§ Cheatsheet
- Tester bit *k* : `(x & (1<<k)) != 0`  
- Poser/Retirer/Basculer : `|= (1<<k)` / `&= ~(1<<k)` / `^= (1<<k)`  
- Extraire champ `[s..e]` : `((x >> s) & ((1 << (e-s+1)) - 1))`  
- Puissance de 2 via shift : `1 << n`

---

## âœ… Check-list (DoD)
- [ ] Je sais appliquer **ET/OU/XOR/NOT** sur des octets.  
- [ ] Je comprends la diffÃ©rence entre `>>` **logique** et **arithmÃ©tique**.  
- [ ] Je sais **tester/poser/retirer/basculer** un bit avec un **masque**.  
- [ ] Je peux **extraire** un champ multi-bits et le **rÃ©aligner**.

## ğŸ“¦ Livrables attendus
- Une **fiche mÃ©mo** (opÃ©rateurs, masques, exemples).  
- 10 **exercices** (dont 3 avec extraction de champ), corrigÃ©s et **annotÃ©s**.  

> **Ã‰tape suivante :** C7.1.3 (matÃ©riel) puis C7.2 (masques **rÃ©seau**, **CIDR**, plan dâ€™adressage).
```
