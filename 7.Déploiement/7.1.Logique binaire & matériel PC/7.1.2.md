---
title: 2. Opérateurs
permalink: /deploiement/c7-1/operateurs-decalages-masques/
layout: home
nav_order: 2
parent: 7.1. Logique binaire & matériel PC
---

# 📘 Chapitre 7.1.2 — Opérateurs 

## 📒 Glossaire minute
- **ET (AND, `&`)** : garde les bits mis à 1 **dans les deux** opérandes.  
- **OU (OR, `|`)** : garde les bits à 1 **dans au moins un** opérande.  
- **XOR (`^`)** : 1 si les bits sont **différents** (toggle).  
- **NOT (`~`)** : inverse tous les bits (attention à la **taille** en bits).  
- **Décalages (`<<`, `>>`)** : multiplication/division par 2ⁿ (cf. signe).  
- **Masque** : motif binaire pour **tester/poser/retirer/basculer** des bits (flags).  
- **LSB/MSB** : bit de poids faible/fort (droite/gauche dans l’octet).

---

## 🎯 Objectifs
- Savoir appliquer **ET/OU/XOR/NOT** sur des octets et des nibbles.  
- Comprendre l’effet de `<<` et `>>` (zéro vs **extension de signe**).  
- Maîtriser les **masques** pour lire/modifier des **drapeaux** (flags) et extraire des champs.

## ✅ Pré-requis
- 7.1.1 : conversions **binaire/hex/décimal** (grouper par nibbles).

---

## 1) Tables de vérité (sur 1 bit)
| A | B | A **ET** B | A **OU** B | A **XOR** B | **NOT** A |
|:-:|:-:|:----------:|:----------:|:-----------:|:---------:|
| 0 | 0 | 0 | 0 | 0 | 1 |
| 0 | 1 | 0 | 1 | 1 | 1 |
| 1 | 0 | 0 | 1 | 1 | 0 |
| 1 | 1 | 1 | 1 | 0 | 0 |

> **Raccourci Hex** : faites les opérations **par nibble** (4 bits) en hex (ex. `0xA & 0xB = 0xA`).

---

## 2) Opérations sur octets (exemples)
Prenons :  
`A = 0x6D = 0110 1101₂` (109)  
`B = 0x53 = 0101 0011₂` (83)

- **ET** : `A & B = 0111?` → non, calcul exact :  
  `0110 1101`  
  `0101 0011`  
  **&** → `0100 0001` = **0x41** (65)

- **OU** : `A | B = 0111 1111` = **0x7F** (127)  
- **XOR** : `A ^ B = 0011 1110` = **0x3E** (62)  
- **NOT** (sur 8 bits) : `~A = 1001 0010` = **0x92** (146)

> **Attention** : `~` dépend de la **largeur** (8/16/32 bits). Toujours préciser le contexte.

---

## 3) Décalages : `<<` et `>>`
- `x << n` : décale à **gauche** → **× 2ⁿ** (remplit par **0** à droite).  
- `x >> n` : décale à **droite** → **÷ 2ⁿ** (selon langage :  
  **logique** → remplit par 0 ; **arithmétique** → **propage le signe**).

Ex. `x = 0x1A = 0001 1010₂` (26)  
- `x << 3 = 1101 0000₂` = **0xD0** (208)  
- `x >> 2 = 0000 0110₂` = **0x06** (6)

> **Astuce** : décomposer/composer des **champs** (bitfields) avec décalages + masques.

---

## 4) Masques : tester/poser/retirer/basculer des **flags**
Convention : **bit0** = LSB (tout à droite).

Imaginons des droits sur 3 bits :  
`bit0=READ`, `bit1=WRITE`, `bit2=EXEC`.  
`flags = 0b0000_0101` (READ + EXEC).

- **Tester** si READ actif :  
  `if (flags & (1 << 0)) { ... }` → **vrai**

- **Poser** WRITE :  
  `flags |= (1 << 1)` → `0b0000_0111`

- **Retirer** EXEC :  
  `flags &= ~(1 << 2)` → `0b0000_0011`

- **Basculer** READ :  
  `flags ^= (1 << 0)` → toggle du bit0

### 4.1 Extraire un **champ** (plusieurs bits)
Ex. `x = 0b1010_1101`, champ **3 bits** à partir du **bit2** :  
`mask = 0b0001_1100`  
`val = (x & mask) >> 2`  → isole le champ et le **réaligne**.

### 4.2 (Lien réseau) **Masques IPv4** (aperçu)
- `/26` → 255.255.255.**192** = `11111111.11111111.11111111.11000000`  
  Bits hôte = 6 → **62 hôtes** utilisables (2⁶ − 2).  
Utile en **C7.2** pour le **plan d’adressage**.

---

## 5) Exercices (avec réponses)
**E1.** `0xF0 & 0x3C = ?`  
→ `1111 0000 & 0011 1100 = 0011 0000` = **0x30**

**E2.** `0b0101_1010 ^ 0b0011_0011 = ?`  
→ `0110 1001` = **0x69**

**E3.** `x=0b0001_1010`, calculer `x<<2` et `x>>3`  
→ `x<<2 = 0110 1000` (**0x68**), `x>>3 = 0000 0011` (**0x03**)

**E4.** Activez les bits `0` et `3` de `flags=0b0000_0000`  
→ `flags |= (1<<0) | (1<<3)` → `0b0000_1001`

**E5.** Extrayez le champ 4 bits `[bit4..bit7]` de `x=0b1101_0110`  
→ `mask=0b1111_0000`, `(x & mask) >> 4 = 0b1101` = **0xD** (13)

---

## 🩹 Dépannage (erreurs fréquentes)
- Confusion **logique** vs **bit-à-bit** (`&&`/`||` vs `&`/`|`).  
- Oublier la **largeur** lors de `~` (résultat négatif inattendu).  
- Décalage **arithmétique** vs **logique** sur des **signés** (`>>` propage le signe).  
- Oublier de **grouper par 4 bits** avant d’opérer en **hex**.

---

## 🔧 Cheatsheet
- Tester bit *k* : `(x & (1<<k)) != 0`  
- Poser/Retirer/Basculer : `|= (1<<k)` / `&= ~(1<<k)` / `^= (1<<k)`  
- Extraire champ `[s..e]` : `((x >> s) & ((1 << (e-s+1)) - 1))`  
- Puissance de 2 via shift : `1 << n`

---

## ✅ Check-list (DoD)
- [ ] Je sais appliquer **ET/OU/XOR/NOT** sur des octets.  
- [ ] Je comprends la différence entre `>>` **logique** et **arithmétique**.  
- [ ] Je sais **tester/poser/retirer/basculer** un bit avec un **masque**.  
- [ ] Je peux **extraire** un champ multi-bits et le **réaligner**.

## 📦 Livrables attendus
- Une **fiche mémo** (opérateurs, masques, exemples).  
- 10 **exercices** (dont 3 avec extraction de champ), corrigés et **annotés**.  

> **Étape suivante :** C7.1.3 (matériel) puis C7.2 (masques **réseau**, **CIDR**, plan d’adressage).
```
