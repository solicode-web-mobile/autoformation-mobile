---
title: 3. CPU, RAM, disque/SSD, bus
permalink: /deploiement/c7-1/cpu-ram-ssd-bus/
layout: home
nav_order: 3
parent: 7.1. Logique binaire & matériel PC
---

# 📘 Chapitre 7.1.3 — CPU, RAM, disque/SSD, bus & performances

## 📒 Glossaire minute
- **Cœur / Thread** : unité d’exécution physique / logique (SMT, ex. Hyper-Threading).
- **Fréquence / Turbo** : cadence de base / fréquence max courte (selon température & TDP).
- **IPC** : *Instructions Per Cycle* — quantité de travail par cycle.
- **Cache L1/L2/L3** : mémoires très rapides proches du CPU.
- **DDR4/DDR5** : générations de RAM (débit × canaux).
- **CAS** : latence (ex. CL40) — délai d’accès.
- **SATA / NVMe** : interfaces de stockage (SATA via contrôleur AHCI ; NVMe sur PCIe).
- **IOPS / Débit séquentiel** : opérations aléatoires / lecture-écriture linéaire.
- **PCIe** : bus d’extension (x1/x4/x16, Gen3/4/5…).

---

## 🎯 Objectifs
- Évaluer une config **CPU/RAM/Stockage** et repérer le **goulot d’étranglement**.
- Comprendre l’effet des **bus** (PCIe, mémoire) sur la **perf**.
- Savoir **mesurer** (outils système) et **argumenter** une recommandation.

## ✅ Pré-requis
- 7.1.1 (binaire/hex) et 7.1.2 (opérateurs/masques).
- Connaître les unités : Hz, B/s, GB/s, ms, IOPS.

---

## 1) CPU — cœurs, threads, IPC, cache
> Règle simple : **Perf ≈ IPC × Fréquence × Cœurs utiles** (scaling < 100% selon l’appli)

- **Cœurs / Threads** : plus de cœurs aident au **multitâche** et aux builds parallèles.
- **IPC & micro-archi** : à fréquence égale, un CPU récent fait **plus par cycle**.
- **Caches L1/L2/L3** : diminuent les accès RAM → **gains majeurs** sur code & données réutilisées.
- **Turbo & TDP** : la fréquence boost dépend du **refroidissement** & enveloppe thermique.
- **Intégrés** : iGPU utile pour l’affichage sans GPU dédié.

🔍 **Mesure**
- **Windows** : Gestionnaire des tâches → *Performance/Processeur* ; `wmic cpu get Name,NumberOfCores,NumberOfLogicalProcessors`
- **Linux** : `lscpu`, `top/htop`, `cat /proc/cpuinfo`

---

## 2) RAM — capacité, débit, latence, canaux
- **Capacité** : 8 Go (minimum), 16 Go (confort dev web), 32 Go+ (Docker multiples, VMs).
- **Débit** : DDR = transferts **doubles**/cycle. DDR5↑ débit vs DDR4.  
  **Canaux** : Dual-channel (2 barrettes identiques) → **+30-50%** débit mémoire réel.
- **Latence** : CAS (ex. CL40) — plus bas = mieux (à comparer **à fréquence égale**).
- **ECC** (serveur) : correction d’erreurs (stabilité/fiabilité).
- **Swap**/**Pagefile** : secours disque — si sollicité souvent ⇒ **manque de RAM**.

🔍 **Mesure**
- **Windows** : *Performance/Mémoire* ; `resmon` ; `wmic memorychip get`
- **Linux** : `free -h`, `vmstat 5`, `dmidecode -t memory`

---

## 3) Stockage — HDD vs SSD SATA vs SSD NVMe
| Support | Latence | Débit séquentiel (typ.) | IOPS aléatoires (typ.) | Usage recommandé |
|---|---|---|---|---|
| **HDD 7200 rpm** | ~10 ms | 150–220 MB/s | ~100–200 | Archives, gros médias |
| **SSD SATA** | ~0.05–0.1 ms | 400–550 MB/s | 10k–100k | Système, apps |
| **SSD NVMe PCIe 3.0 x4** | ~0.02 ms | 2.5–3.5 GB/s | 200k+ | Builds, VM, gros projets |
| **SSD NVMe PCIe 4.0 x4** | ~0.02 ms | 5–7 GB/s | 400k+ | Flux lourds, CI rapide |

- **Endurance (TBW)** : quantité de données écrites garantie (plus haut = mieux).
- **Thermal throttling** NVMe : prévoir **radiateur** sur M.2 en charge soutenue.
- **S.M.A.R.T.** : santé du disque.

🔍 **Mesure**
- **Windows** : *Gestionnaire de tâches/Disque*, `winsat disk` (ancien), utilitaires fabricants.
- **Linux** : `lsblk -o NAME,SIZE,TYPE,MOUNTPOINT`, `smartctl -a /dev/nvme0`, `hdparm -Tt /dev/sdX`, `fio` (bench)

---

## 4) Bus & interconnexions — PCIe, mémoire, SATA
### 4.1 PCI Express (par **voie/lane**, approx bi-directionnel agrégé)
| Gen | Par lane | x4 (NVMe courant) | x16 (GPU) |
|---|---:|---:|---:|
| **PCIe 3.0** | ~985 MB/s | ~3.9 GB/s | ~15.8 GB/s |
| **PCIe 4.0** | ~1.97 GB/s | ~7.9 GB/s | ~31.5 GB/s |
| **PCIe 5.0** | ~3.94 GB/s | ~15.8 GB/s | ~63 GB/s |

- **SATA III** : **6 Gb/s** ≈ **600 MB/s** max (limite des SSD SATA).
- **Mémoire** : canaux **A/B** (dual/quad) → multiplie le débit RAM.
- **DMI/Chipset** : lien CPU↔chipset — peut **saturer** si trop d’E/S simultanées.

---

## 5) Où se cache le goulot d’étranglement ?
- Boot & ouverture d’IDE **lents** → stockage (passer SATA → **NVMe**).
- Compilation **CPU 100%** sur tous cœurs → plus de **cœurs/IPC** utiles.
- Lag avec RAM **pleine** + swap → **ajouter de la RAM** ; vérifier conteneurs/VM.
- Copie fichiers réseau lente → vérifier **lien réseau**, **PCIe** de la NIC, **antivirus**.

---

## 6) Profils-type (exemples rapides)
- **Poste dev web** (équilibré) : 6–8 cœurs / 16–32 Go / NVMe Gen3/4 1 To / dual-channel.
- **Serveur CI** : 12–24 cœurs / 64 Go+ / NVMe Gen4 (RAID1) / réseau 2.5–10 GbE.
- **Budget upgrade** : +16 Go RAM **et** NVMe → gain **ressenti** maximal.

---

## 7) Commandes utiles (cheatsheet)
```bash
# Linux
lscpu
free -h
vmstat 5
lsblk -o NAME,SIZE,TYPE,MOUNTPOINT
smartctl -a /dev/nvme0
hdparm -Tt /dev/sda
fio --name=randread --rw=randread --bs=4k --iodepth=32 --size=1G --numjobs=1 --filename=/tmp/testfile

# Windows (PowerShell/cmd)
wmic cpu get Name,NumberOfCores,NumberOfLogicalProcessors
Get-CimInstance Win32_PhysicalMemory | ft Manufacturer,Speed,Capacity
winsat disk
````

---

## 🧪 Exercices (avec attentes)

1. **Diagnostiquer** un poste qui “rame” (captures CPU/RAM/Disque) et **conclure** (goulot + correctif).
2. **Mesurer** le débit d’un SSD (outil au choix) et comparer à la **fiche constructeur**.
3. **Comparer** single vs dual-channel (si possible) : même test, rapport de **% de gain**.

## 📦 Livrables attendus

* Tableau **spécifications** (CPU/RAM/Stockage/Bus) + **mesures** réelles.
* Rapport **diagnostic & recommandations** (court, argumenté).

## ✅ Check-list (DoD)

* [ ] Je sais lire **cœurs/threads/IPC/cache** et relier à mon usage.
* [ ] Je vérifie **capacité** & **canaux** de RAM et l’activité de **swap**.
* [ ] Je distingue **SATA** vs **NVMe** et j’interprète **IOPS** vs **séquentiel**.
* [ ] Je situe les limites **PCIe** et j’identifie le **bottleneck** principal.
