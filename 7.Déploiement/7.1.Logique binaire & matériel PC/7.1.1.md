---
title: 1. NumÃ©ration binaire/hex
layout: home
nav_order: 1
parent: 7.1. Logique binaire & matÃ©riel PC
permalink: /deploiement/c7-1/numeration/
code: 7.1.1
competence: C7
autoformation: "C7.1"
ua: "7.1.U1"
duree_h: 1.5
objectif: "Convertir dÃ©cimal â†” binaire â†” hex rapidement et sans erreur, avec ou sans calculatrice."
notions_nouvelles: ["Bit", "Octet", "Base", "Nibble", "MSB/LSB", "Notation 0b/0x"]
fil_rouge: "RepÃ¨res binaires pour tailles, flags et adresses dans le Blog/API et lâ€™app mobile"
livrable_chapitre: "Fiche mÃ©mo + 10 conversions mixtes corrigÃ©es et annotÃ©es"
alimentation_prototype: "MaÃ®trise des bases binaires pour paramÃ©trages (tailles, flags) lors des dÃ©mos N2"
alimentation_miniprojet: "PrÃ©pare les chapitres rÃ©seau (masques CIDR) et le debugging bas niveau N3"
---

# ğŸ“˜ Chapitre 7.1.1 â€” NumÃ©ration binaire/hex et conversions

## ğŸ“’ Glossaire minute
- **Bit** : plus petite unitÃ© (0 ou 1).  
- **Octet (Byte)** : 8 bits.  
- **Base** : systÃ¨me de numÃ©ration (binaire=2, dÃ©cimal=10, hexadÃ©cimal=16).  
- **Nibble** : groupe de 4 bits (Ã©quivaut Ã  1 chiffre **hex**).  
- **MSB/LSB** : bit de poids fort/faible (*Most/Least Significant Bit*).  
- **Notation** : `0b1010` (binaire), `173` (dÃ©cimal), `0xAD` (hex).

---

## ğŸ¯ Objectif
Savoir convertir **dÃ©cimal â†” binaire â†” hexadÃ©cimal** rapidement et sans erreur, avec et sans calculatrice.

## âœ… PrÃ©-requis
- ConnaÃ®tre les **puissances de 2** (1,2,4,8,16,32,64,128, â€¦)  
- Avoir une calculatrice en **mode programmeur** (optionnel mais pratique)

---

## 1) Rappel â€” reprÃ©sentation positionnelle
Un nombre en base `b` est une somme de puissances de `b`.

Ex. `101101â‚‚`  
`= 1Â·2âµ + 0Â·2â´ + 1Â·2Â³ + 1Â·2Â² + 0Â·2Â¹ + 1Â·2â° = 32 + 0 + 8 + 4 + 0 + 1 = 45â‚â‚€`

---

## 2) Table de correspondance (0 â†’ 15)
> 1 **nibble** (4 bits) â†” 1 chiffre **hex**. Grouper les bits **par 4** Ã  partir de la droite.

| DÃ©c | Bin (4b) | Hex |
|---:|:--------:|:---:|
| 0 | 0000 | 0 |
| 1 | 0001 | 1 |
| 2 | 0010 | 2 |
| 3 | 0011 | 3 |
| 4 | 0100 | 4 |
| 5 | 0101 | 5 |
| 6 | 0110 | 6 |
| 7 | 0111 | 7 |
| 8 | 1000 | 8 |
| 9 | 1001 | 9 |
| 10 | 1010 | A |
| 11 | 1011 | B |
| 12 | 1100 | C |
| 13 | 1101 | D |
| 14 | 1110 | E |
| 15 | 1111 | F |

---

## 3) DÃ©cimal â†’ Binaire (mÃ©thode des divisions par 2)
> Diviser par 2, **retenir le reste**, lire les restes **de bas en haut**.

Ex. `45â‚â‚€`  
```

45 Ã· 2 = 22 r1
22 Ã· 2 = 11 r0
11 Ã· 2 = 5  r1
5  Ã· 2 = 2  r1
2  Ã· 2 = 1  r0
1  Ã· 2 = 0  r1

```
Lecture des restes (bas â†’ haut) : **101101â‚‚**

---

## 4) Binaire â†’ DÃ©cimal (somme pondÃ©rÃ©e)
Ex. `101101â‚‚ = 1Â·2âµ + 0Â·2â´ + 1Â·2Â³ + 1Â·2Â² + 0Â·2Â¹ + 1Â·2â° = 45â‚â‚€`

---

## 5) Hex â†” Binaire (par nibbles)
- **Hex â†’ Bin** : remplacer chaque hex par 4 bits.  
  Ex. `0x2F = 0010 1111â‚‚`
- **Bin â†’ Hex** : grouper par 4 bits (Ã  droite), convertir chaque groupe.  
  Ex. `1101 0110â‚‚ = 0xD6`

---

## 6) DÃ©cimal â†” Hex (divisions par 16)
**DÃ©c â†’ Hex** : divisions successives par 16, lire les restes (0â€“15 â†’ 0â€“F).  
Ex. `250â‚â‚€`  
`250 Ã· 16 = 15 r10` â†’ `15 = F`, `10 = A` â†’ **0xFA**

**Hex â†’ DÃ©c** : somme pondÃ©rÃ©e en base 16.  
Ex. `0xFA = 15Â·16 + 10 = 250â‚â‚€`

---

## 7) ZÃ©ro-padding & largeurs usuelles
- **8 bits (octet)** : `0000 0000` â†’ `1111 1111` (0..255)  
- **16 bits** : `0x0000` â†’ `0xFFFF` (0..65535)  
- Toujours **aligner sur 4 bits** pour lâ€™hex (ex. `101â‚‚` â†’ `0101â‚‚` â†’ `0x5`)

---

## 8) Astuces & piÃ¨ges
- Toujours prÃ©ciser la **base** (`0b`, `0x` ou suffixes `_2`, `_16`).  
- En groupant par 4 bits, ne pas oublier de **complÃ©ter Ã  gauche** avec des zÃ©ros.  
- Pour vÃ©rifier : convertir **via lâ€™hex** est souvent plus rapide que dÃ©c â†” bin direct.

---

## ğŸ”§ Cheatsheet express
- **DÃ©c â†’ Bin** : divisions /2 + restes (basâ†’haut).  
- **Bin â†’ DÃ©c** : somme des puissances de 2 **oÃ¹ il y a des 1**.  
- **Bin â†” Hex** : grouper/dÃ©grouper **par 4 bits**.  
- **DÃ©c â†’ Hex** : divisions /16 + restes (0..F).  

---

## ğŸ§ª Exercices (avec rÃ©sultats)
1) `173â‚â‚€` â†’ **binaire** et **hex**  
â†’ `173 = 128 + 32 + 8 + 4 + 1` â†’ `1010 1101â‚‚` â†’ **0xAD**

2) `0b1101 0110` â†’ **dÃ©cimal** et **hex**  
â†’ `128+64+16+4+2 = 214` â†’ **214â‚â‚€**, **0xD6**

3) `0x3F` â†’ **binaire** et **dÃ©cimal**  
â†’ `0011 1111â‚‚` â†’ **63â‚â‚€**

4) Convertir `202â‚â‚€`  
â†’ `1100 1010â‚‚` â†’ **0xCA**

5) ComplÃ©ter en 8 bits : `0b1011` â†’ **`0000 1011`**

---

## âœ… Check-list (DoD)
- [ ] Je convertis **dÃ©cimal â†” binaire â†” hex** sans table externe.  
- [ ] Je groupe/complÃ¨te les bits **par 4** pour lâ€™hex.  
- [ ] Je peux vÃ©rifier un rÃ©sultat via une **deuxiÃ¨me mÃ©thode** (ex. passer par lâ€™hex).  

## ğŸ“¦ Livrables attendus
- Fiche mÃ©mo personnelle (**mÃ©thodes + exemples**).  
- 10 conversions mixtes (dÃ©câ†”binâ†”hex) **corrigÃ©es** et **annotÃ©es** (dÃ©marche).

> **Prochain chapitre :** **7.1.2 â€” OpÃ©rateurs (ET/OU/XOR), dÃ©calages & masques** pour manipuler les bits et prÃ©parer les **masques rÃ©seau**.
```
