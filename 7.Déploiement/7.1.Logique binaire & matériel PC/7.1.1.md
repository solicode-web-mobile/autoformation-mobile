---
title: 1. Numération binaire/hex
layout: home
nav_order: 1
parent: 7.1. Logique binaire & matériel PC
permalink: /deploiement/c7-1/numeration/
code: 7.1.1
competence: C7
autoformation: "C7.1"
ua: "7.1.U1"
duree_h: 1.5
objectif: "Convertir décimal ↔ binaire ↔ hex rapidement et sans erreur, avec ou sans calculatrice."
notions_nouvelles: ["Bit", "Octet", "Base", "Nibble", "MSB/LSB", "Notation 0b/0x"]
fil_rouge: "Repères binaires pour tailles, flags et adresses dans le Blog/API et l’app mobile"
livrable_chapitre: "Fiche mémo + 10 conversions mixtes corrigées et annotées"
alimentation_prototype: "Maîtrise des bases binaires pour paramétrages (tailles, flags) lors des démos N2"
alimentation_miniprojet: "Prépare les chapitres réseau (masques CIDR) et le debugging bas niveau N3"
---

# 📘 Chapitre 7.1.1 — Numération binaire/hex et conversions

## 📒 Glossaire minute
- **Bit** : plus petite unité (0 ou 1).  
- **Octet (Byte)** : 8 bits.  
- **Base** : système de numération (binaire=2, décimal=10, hexadécimal=16).  
- **Nibble** : groupe de 4 bits (équivaut à 1 chiffre **hex**).  
- **MSB/LSB** : bit de poids fort/faible (*Most/Least Significant Bit*).  
- **Notation** : `0b1010` (binaire), `173` (décimal), `0xAD` (hex).

---

## 🎯 Objectif
Savoir convertir **décimal ↔ binaire ↔ hexadécimal** rapidement et sans erreur, avec et sans calculatrice.

## ✅ Pré-requis
- Connaître les **puissances de 2** (1,2,4,8,16,32,64,128, …)  
- Avoir une calculatrice en **mode programmeur** (optionnel mais pratique)

---

## 1) Rappel — représentation positionnelle
Un nombre en base `b` est une somme de puissances de `b`.

Ex. `101101₂`  
`= 1·2⁵ + 0·2⁴ + 1·2³ + 1·2² + 0·2¹ + 1·2⁰ = 32 + 0 + 8 + 4 + 0 + 1 = 45₁₀`

---

## 2) Table de correspondance (0 → 15)
> 1 **nibble** (4 bits) ↔ 1 chiffre **hex**. Grouper les bits **par 4** à partir de la droite.

| Déc | Bin (4b) | Hex |
|---:|:--------:|:---:|
| 0 | 0000 | 0 |
| 1 | 0001 | 1 |
| 2 | 0010 | 2 |
| 3 | 0011 | 3 |
| 4 | 0100 | 4 |
| 5 | 0101 | 5 |
| 6 | 0110 | 6 |
| 7 | 0111 | 7 |
| 8 | 1000 | 8 |
| 9 | 1001 | 9 |
| 10 | 1010 | A |
| 11 | 1011 | B |
| 12 | 1100 | C |
| 13 | 1101 | D |
| 14 | 1110 | E |
| 15 | 1111 | F |

---

## 3) Décimal → Binaire (méthode des divisions par 2)
> Diviser par 2, **retenir le reste**, lire les restes **de bas en haut**.

Ex. `45₁₀`  
```

45 ÷ 2 = 22 r1
22 ÷ 2 = 11 r0
11 ÷ 2 = 5  r1
5  ÷ 2 = 2  r1
2  ÷ 2 = 1  r0
1  ÷ 2 = 0  r1

```
Lecture des restes (bas → haut) : **101101₂**

---

## 4) Binaire → Décimal (somme pondérée)
Ex. `101101₂ = 1·2⁵ + 0·2⁴ + 1·2³ + 1·2² + 0·2¹ + 1·2⁰ = 45₁₀`

---

## 5) Hex ↔ Binaire (par nibbles)
- **Hex → Bin** : remplacer chaque hex par 4 bits.  
  Ex. `0x2F = 0010 1111₂`
- **Bin → Hex** : grouper par 4 bits (à droite), convertir chaque groupe.  
  Ex. `1101 0110₂ = 0xD6`

---

## 6) Décimal ↔ Hex (divisions par 16)
**Déc → Hex** : divisions successives par 16, lire les restes (0–15 → 0–F).  
Ex. `250₁₀`  
`250 ÷ 16 = 15 r10` → `15 = F`, `10 = A` → **0xFA**

**Hex → Déc** : somme pondérée en base 16.  
Ex. `0xFA = 15·16 + 10 = 250₁₀`

---

## 7) Zéro-padding & largeurs usuelles
- **8 bits (octet)** : `0000 0000` → `1111 1111` (0..255)  
- **16 bits** : `0x0000` → `0xFFFF` (0..65535)  
- Toujours **aligner sur 4 bits** pour l’hex (ex. `101₂` → `0101₂` → `0x5`)

---

## 8) Astuces & pièges
- Toujours préciser la **base** (`0b`, `0x` ou suffixes `_2`, `_16`).  
- En groupant par 4 bits, ne pas oublier de **compléter à gauche** avec des zéros.  
- Pour vérifier : convertir **via l’hex** est souvent plus rapide que déc ↔ bin direct.

---

## 🔧 Cheatsheet express
- **Déc → Bin** : divisions /2 + restes (bas→haut).  
- **Bin → Déc** : somme des puissances de 2 **où il y a des 1**.  
- **Bin ↔ Hex** : grouper/dégrouper **par 4 bits**.  
- **Déc → Hex** : divisions /16 + restes (0..F).  

---

## 🧪 Exercices (avec résultats)
1) `173₁₀` → **binaire** et **hex**  
→ `173 = 128 + 32 + 8 + 4 + 1` → `1010 1101₂` → **0xAD**

2) `0b1101 0110` → **décimal** et **hex**  
→ `128+64+16+4+2 = 214` → **214₁₀**, **0xD6**

3) `0x3F` → **binaire** et **décimal**  
→ `0011 1111₂` → **63₁₀**

4) Convertir `202₁₀`  
→ `1100 1010₂` → **0xCA**

5) Compléter en 8 bits : `0b1011` → **`0000 1011`**

---

## ✅ Check-list (DoD)
- [ ] Je convertis **décimal ↔ binaire ↔ hex** sans table externe.  
- [ ] Je groupe/complète les bits **par 4** pour l’hex.  
- [ ] Je peux vérifier un résultat via une **deuxième méthode** (ex. passer par l’hex).  

## 📦 Livrables attendus
- Fiche mémo personnelle (**méthodes + exemples**).  
- 10 conversions mixtes (déc↔bin↔hex) **corrigées** et **annotées** (démarche).

> **Prochain chapitre :** **7.1.2 — Opérateurs (ET/OU/XOR), décalages & masques** pour manipuler les bits et préparer les **masques réseau**.
```
