---
title: 6. netstat/ss, test de port, pare-feu de base
permalink: /deploiement/netstat-ss-tests-parefeu/
layout: home
nav_order: 6
parent: 7.2. LAN & adressage IP
---

# 📘 Chapitre 7.2.6 — `netstat/ss`, test de port (`telnet`/`curl`), pare-feu de base

## 📒 Glossaire minute
- **Port** : point logique d’un service TCP/UDP (ex. HTTP **80**, HTTPS **443**, SSH **22**).
- **État TCP** : `LISTEN`, `ESTABLISHED`, `TIME_WAIT`, `CLOSE_WAIT`…
- **`netstat`** : outil historique pour connexions/ports (Windows/Linux — ancien).
- **`ss`** : remplaçant moderne de `netstat` sous Linux (plus rapide/précis).
- **`telnet`** : client TCP “brut” utile pour **tester l’ouverture** d’un port.
- **`curl`** : client HTTP(s)/TCP générique pour **tester une URL/port**.
- **Pare-feu** : filtre réseau local (Windows Defender Firewall, `ufw`/`firewalld`).

---

## 🎯 Objectifs
- Lister **qui écoute** (ports `LISTEN`) et **qui communique** (`ESTABLISHED`) sur la machine.
- Tester l’**ouverture d’un port** local/distant et **qualifier** la panne (service down, port fermé, filtrage).
- Réaliser les **réglages de base** d’un pare-feu (ouvrir/fermer un port, vérifier une règle).

## ✅ Pré-requis
- 7.2.3 (IPv4/CIDR/GW/DNS) • 7.2.5 (ping/trace) • notions OS (cmd/PowerShell/Bash).

---

## 1) Voir les ports & connexions

### 1.1 Windows — `netstat`
```powershell
# Ports en écoute + PID + résolution noms désactivée (plus lisible)
netstat -ano -p tcp
# Filtrer un port (ex. 8080)
netstat -ano | findstr :8080
````

> Associer **PID → Processus** : Gestionnaire des tâches → *Détails* (colonne PID).

**PowerShell (alternatif, moderne)**

```powershell
Get-NetTCPConnection | Sort-Object -Property State, LocalPort | Select-Object -First 20
# Ports en écoute uniquement
Get-NetTCPConnection -State Listen
```

### 1.2 Linux/macOS — `ss` (préféré) / `netstat`

```bash
# LISTEN TCP avec programme (requires sudo pour voir tous les noms)
sudo ss -ltnp
# Connexions établies
ss -tn state established
# Ports UDP à l'écoute
ss -lun
# Ancien (si dispo)
sudo netstat -lntp
```

**Lecture rapide**

* `LISTEN` = un service **attend** sur ce port.
* `ESTABLISHED` = une connexion **active**.
* `-n` = ne pas résoudre les noms (plus rapide).
* `-p` = afficher le **processus** (Linux).

---

## 2) Tester un port distant : `telnet` / `curl`

### 2.1 `telnet` (TCP brut)

```bash
# Linux/macOS (telnet installé)
telnet 192.168.10.20 80
# Windows (activer "Client Telnet" si absent)
telnet 192.168.10.20 443
```

**Interprétation**

* Écran vide/connexion établie ⇒ **port ouvert** (vous pouvez taper une requête HTTP manuelle).
* Message d’échec immédiat ⇒ **port fermé/host down**.
* Timeout ⇒ souvent **filtré** par un pare-feu.

### 2.2 `curl` (HTTP/S & tests TCP)

```bash
# Tester HTTP (en-têtes uniquement)
curl -I http://192.168.10.20:80
# Tester HTTPS (voir handshake)
curl -v https://example.com:443/
# Tester un service TCP non-HTTP (bannière si dispo)
curl telnet://192.168.10.20:25
```

> `curl -I` renvoie code **HTTP** + headers (200/301/403/503…). Très utile pour qualifier le **service** derrière le port.

**Bonus Windows (sans telnet)**

```powershell
# Test d’un port TCP (remonte aussi route/latence)
Test-NetConnection 192.168.10.20 -Port 443
```

---

## 3) Pare-feu — bases indispensables

### 3.1 Windows Defender Firewall

```powershell
# Voir l’état global
Get-NetFirewallProfile | Select-Object Name, Enabled

# Lister règles qui ouvrent un port (ex. 8080)
Get-NetFirewallRule | ?{ $_.Enabled -eq 'True' } | Get-NetFirewallPortFilter | ?{ $_.LocalPort -eq 8080 }

# Ouvrir un port TCP entrant 8080 (profil privé)
New-NetFirewallRule -DisplayName "App Web 8080" -Direction Inbound -Protocol TCP -LocalPort 8080 -Action Allow -Profile Private

# Supprimer la règle
Remove-NetFirewallRule -DisplayName "App Web 8080"
```

### 3.2 Linux — `ufw` (Ubuntu/Debian)

```bash
sudo ufw status verbose
sudo ufw allow 22/tcp        # SSH
sudo ufw allow 8080/tcp      # appli web locale
sudo ufw delete allow 8080/tcp
sudo ufw enable              # activer si inactif (avec prudence via accès console)
```

### 3.3 Linux — `firewalld` (RHEL/CentOS/Alma)

```bash
sudo firewall-cmd --state
sudo firewall-cmd --add-port=8080/tcp --permanent
sudo firewall-cmd --reload
sudo firewall-cmd --list-ports
```

> 🧩 **Règle d’or** : d’abord vérifier que **le service écoute** (`ss/netstat`), ensuite tester **connectivité** (`telnet/curl`), enfin **adapter le pare-feu** si nécessaire.

---

## 4) Procédure de diag “port fermé ?” (5 étapes)

1. **Local** sur la machine serveur

   * `ss -ltnp` (Linux) / `netstat -ano` (Windows) → le service **écoute-t-il** sur le **bon port** et **bonne IP** (`0.0.0.0` ou IP attendue) ?
2. **Local → Local**

   * `curl -I http://127.0.0.1:PORT` → si **OK** ici, l’appli tourne.
3. **Depuis un autre hôte du même LAN**

   * `telnet IP_SERVEUR PORT` ou `curl -v http://IP_SERVEUR:PORT` → si KO, suspecter **pare-feu** ou **route/VLAN**.
4. **Pare-feu**

   * Ouvrir le port (règle entrante) et **retester**.
5. **Chemin & NAT**

   * Si accès depuis WAN : vérifier **redirection NAT**/port-forwarding et **traceroute** (7.2.5).

---

## 5) Cas fréquents & correctifs

* **Service down / mauvais port** : `ss` ne montre pas `LISTEN` → corriger la config app, relancer service.
* **Écoute sur 127.0.0.1 uniquement** : accès distant impossible → lier à `0.0.0.0` ou IP LAN.
* **Pare-feu bloque** : `curl` timeout alors que `ss` montre `LISTEN` → ajouter règle (Windows/ufw/firewalld).
* **Port déjà utilisé** : conflit de PID (ex. autre service écoute 80) → changer port ou arrêter l’autre service.
* **NAT manquant** (accès externe) : port-forward sur routeur non configuré → ajouter redirection vers IP/LAN serveur.

---

## 6) Cheatsheet

### Lister écoute & connexions

```bash
# Linux
sudo ss -ltnp           # écoute TCP + programme
ss -tun state established
# Windows
netstat -ano | findstr LISTENING
Get-NetTCPConnection -State Listen
```

### Tests de port

```bash
telnet HOST 443
curl -I http://HOST:80
# Windows
Test-NetConnection HOST -Port 443
```

### Pare-feu

```bash
# Windows
New-NetFirewallRule -DisplayName "Open 8080" -Direction Inbound -Protocol TCP -LocalPort 8080 -Action Allow
# Ubuntu/Debian
sudo ufw allow 8080/tcp
# RHEL/CentOS
sudo firewall-cmd --add-port=8080/tcp --permanent && sudo firewall-cmd --reload
```

---

## 🧪 Exercices (avec attentes)

1. **Identifier** quel processus écoute sur `:8080` et donner son **PID** (Windows et Linux).
2. **Tester** l’accès à `http://IP_SERVEUR:8080` depuis un autre poste (telnet/curl) et **conclure**.
3. **Ouvrir/fermer** le port 8080 sur votre pare-feu, **documenter** la règle, **retester**.
4. **Conflit de port** : simuler deux services sur 8080 → corriger (changer port, vérifier écoute).

## 📦 Livrables attendus

* Journal de **diagnostic** (copies `ss/netstat`, `curl/telnet`, réglages pare-feu).
* Tableau **symptôme → cause → commande → correctif**.
* Mini-rapport “**Port 8080 indisponible**” (analyse + actions).

## ✅ Check-list (DoD)

* [ ] Je sais **qui écoute** et **où** (`ss`/`netstat` + PID/processus).
* [ ] Je teste un **port** local/distant (`telnet`/`curl`) et j’interprète **ouvert/fermé/filtré**.
* [ ] Je crée/supprime une **règle pare-feu** proprement (Windows/ufw/firewalld).
* [ ] Je mène une **procédure** en 5 étapes pour résoudre “port fermé”.

