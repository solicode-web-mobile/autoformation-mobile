---
title: 2. TLS/HTTPS
permalink: /deploiement/c7-3/tls-https-certificats/
layout: home
nav_order: 2
parent: Autoformation C7.3 — Serveur Web : principes & HTTP
---

# 📘 Chapitre 7.3.2 — **TLS/HTTPS** (certificats — aperçu)

## 📒 Glossaire minute
- **TLS** : couche de chiffrement au-dessus de TCP (successeur de SSL).  
- **Certificat X.509** : prouve l’identité d’un site (clé **publique**, **sujet**, **SAN**, **validité**, **CA**).  
- **Clé privée** : secrète, côté serveur (ne jamais la partager).  
- **CA / Chaîne** : certificat **feuille** signé par un **intermédiaire**, lui-même signé par une **racine**.  
- **SAN** (*Subject Alternative Name*) : liste des noms couverts par le certificat.  
- **SNI** : *Server Name Indication*, permet l’hébergement multi-sites HTTPS.  
- **ALPN** : négociation de protocole (ex. **h2** pour HTTP/2, **h3**/QUIC en UDP).  
- **OCSP stapling** : le serveur “agrafe” la preuve de validité → vérif plus rapide.  
- **HSTS** : force l’usage d’HTTPS côté client (en-tête `Strict-Transport-Security`).  
- **DV/OV/EV** : niveaux de validation (Domaine / Organisation / Étendue).  
- **ACME** : protocole d’émission auto (**Let’s Encrypt** via `certbot`).

---

## 🎯 Objectifs
- Comprendre **ce que sécurise TLS** (chiffrement, intégrité, authentification serveur).  
- Savoir **obtenir** un certificat (ACME/Let’s Encrypt) et **installer** la chaîne.  
- Configurer un **vhost HTTPS** (Apache/Nginx) + **redirection** HTTP→HTTPS.  
- Diagnostiquer les erreurs fréquentes (nom, expiration, chaîne incomplète, versions TLS).

## ✅ Pré-requis
- C7.2 (LAN/DNS) • C7.3.1 (HTTP, headers) • Bases terminal.

---

## 1) TLS — à quoi ça sert ?
- 🔒 **Confidentialité** : trafic chifré (observateur ne lit pas).  
- ✅ **Intégrité** : détection d’altération.  
- 🪪 **Authentification serveur** : certificat signé par une **CA de confiance**.

```mermaid
sequenceDiagram
  participant B as Navigateur
  participant S as Serveur
  B->>S: ClientHello (versions, suites, SNI, ALPN)
  S-->>B: ServerHello + Certificat (+ OCSP stapling)
  Note over B,S: Échange de clés → secret partagé
  B->>S: Requête HTTPS (chiffrée)
  S-->>B: Réponse HTTPS (chiffrée)
````

> **Versions** : n’utiliser que **TLS 1.2/1.3** ; désactiver TLS 1.0/1.1.

---

## 2) Certificats — anatomie & formats

* **Champs clés** : *Subject* + **SAN** (les noms couverts), *Issuer*, *Not Before/After* (validité), *Key Usage*.
* **Chaîne** : `feuille` + `intermédiaire(s)` + `racine` (déjà connue du navigateur).
* **Formats** :

  * **PEM** (`.pem`, `.crt`, `.cer`) : ASCII base64.
  * **KEY** : clé privée (PEM).
  * **PFX/P12** : conteneur binaire (clé + cert + chaîne, protégé par mot de passe).

🔎 **Vérifier un cert**

```bash
openssl x509 -in fullchain.pem -noout -text | less
```

---

## 3) Types & cas d’usage

* **DV (Domain Validation)** : le plus courant (Let’s Encrypt), automatisable.
* **OV/EV** : vérifs légales de l’organisation (moindrement utilisé pour projets pédagogiques).
* **Wildcard** `*.domaine.tld` : couvre tous les sous-domaines d’un niveau.
* **Auto-signé** : utile pour **tests internes** (non fiable côté navigateur).

---

## 4) Obtenir un certificat — **Let’s Encrypt** (ACME)

### Debian/Ubuntu (Apache)

```bash
sudo apt update && sudo apt install -y certbot python3-certbot-apache
sudo certbot --apache -d exemple.tld -d www.exemple.tld
# crée/installe cert + fullchain + redirection HTTPS + renouvellement
```

### Debian/Ubuntu (Nginx)

```bash
sudo apt install -y certbot python3-certbot-nginx
sudo certbot --nginx -d exemple.tld -d www.exemple.tld
```

### Renouvellement

* Unité systemd/cron auto après installation. Tester :

```bash
sudo certbot renew --dry-run
```

> **Pré-requis** : DNS du domaine pointe sur le serveur ; port **80** (HTTP) et **443** (HTTPS) accessibles.

---

## 5) Config minimale — **Apache** (aperçu)

```apache
<VirtualHost *:80>
  ServerName exemple.tld
  Redirect permanent / https://exemple.tld/
</VirtualHost>

<VirtualHost *:443>
  ServerName exemple.tld
  DocumentRoot /var/www/site/public

  SSLEngine on
  SSLCertificateFile      /etc/letsencrypt/live/exemple.tld/fullchain.pem
  SSLCertificateKeyFile   /etc/letsencrypt/live/exemple.tld/privkey.pem

  # HTTP/2
  Protocols h2 http/1.1

  # OCSP stapling (si chain fournie et conf validée)
  SSLUseStapling on
  SSLStaplingCache "shmcb:/var/run/ocsp(128000)"

  # Sécurité (basique)
  Header always set Strict-Transport-Security "max-age=15552000; includeSubDomains"
</VirtualHost>
```

> Activer modules nécessaires : `a2enmod ssl headers http2` puis `systemctl reload apache2`.

---

## 6) Bonnes pratiques **HTTPS**

* 🔁 **HTTP→HTTPS** partout (301).
* 📅 **Renouvellement auto** + alerte avant expiration.
* 🧱 **Chaîne complète** (`fullchain.pem`) côté serveur.
* 🧪 **Test** avec `curl -v https://domaine.tld/` et **DevTools** (onglet *Security*).
* 🛡️ **HSTS** (progressif), **OCSP stapling**, versions **TLS 1.2/1.3** uniquement.

---

## 7) Dépannage — erreurs fréquentes

* **ERR\_CERT\_COMMON\_NAME\_INVALID** : le nom demandé n’est **pas** dans **SAN** → regénérer cert.
* **Certificat expiré** : renouvellement KO → vérifier `certbot renew --dry-run`, permissions, cron/systemd.
* **Chaîne incomplète** : certains clients refusent → servir **fullchain** (feuille+intermédiaires).
* **Protocole obsolète** : TLS 1.0/1.1 → désactiver, forcer 1.2/1.3.
* **Horloge système** fausse → invalide la vérification → corriger NTP.
* **Mixed content** : page HTTPS charge ressources HTTP → corriger URLs.

🔧 **Outils**

```bash
# Inspection rapide
curl -I -v https://exemple.tld
# Détails cert & chaîne
openssl s_client -connect exemple.tld:443 -servername exemple.tld -showcerts </dev/null
```

---

## 8) Mini-procédure de mise en place

1. ✅ DNS → `A/AAAA` vers votre serveur.
2. ✅ Ports **80/443** ouverts (pare-feu/NAT).
3. 🔐 `certbot` (Apache/Nginx) → émission + **fullchain/privkey**.
4. 🌐 Redirection **HTTP→HTTPS**, activer **HTTP/2**.
5. 🧪 Vérifier avec `curl -v`, navigateur, et un scanner (ex. *testssl.sh* côté admin).

---

## 🧪 Exercices (avec attentes)

1. **Émettre** un cert DV Let’s Encrypt pour `votre-domaine.tld` (ou un domaine de labo), activer la **redirection**.
2. **Afficher** les infos du cert (dates, SAN, CA) via `openssl x509 -in fullchain.pem -noout -text`.
3. **Diagnostiquer** une erreur “chaîne incomplète” et corriger la config (utiliser `fullchain.pem`).
4. **Activer** HSTS, vérifier la présence de l’en-tête et expliquer le **risque** (verrouillage HTTPS).

## 📦 Livrables attendus

* Extrait **vhost HTTPS** (Apache/Nginx) + sortie `curl -v`.
* Capture **openssl s\_client** (chaîne complète) annotée.
* Note **opérations/renouvellement** (`certbot renew`) + mesures d’alerte.

## ✅ Check-list (DoD)

* [ ] Mon site force **HTTPS** (301) et n’accepte que **TLS 1.2/1.3**.
* [ ] Le certificat couvre **tous** les noms (**SAN**) et la **chaîne** est complète.
* [ ] Le **renouvellement** est automatique et testé.
* [ ] HSTS/OCSP stapling envisagés/activés ; **HTTP/2** opérationnel.
