---
title: 3. remember/saveable
layout: home
nav_order: 3
parent: 5.3. Android avec Compose
permalink: /android-compose-mvvm/remember-saveable/
code: 5.3.3
competence: C5
autoformation: "C5.3"
ua: "5.3.U2"
duree_h: 1.5
objectif: "Choisir oÃ¹ stocker lâ€™Ã©tat, le persister avec rememberSaveable et hoister les composants."
notions_nouvelles: ["remember", "rememberSaveable", "Saver", "State hoisting", "One-way data flow"]
fil_rouge: "HelloCounter â€” persistance de name/greeting/count"
livrable_chapitre: "Counter stateless + CounterHost saveable ; GreetingForm hoistÃ©e"
alimentation_prototype: "Ã‰tat fiable et testable pour N2"
alimentation_miniprojet: "Flux de donnÃ©es cohÃ©rent (sans Ã©tat dupliquÃ©) pour N3"
---


# ðŸ“˜ 5.3.3 - `remember` / `rememberSaveable`, *state hoisting*

## ðŸ“’ Glossaire minute
- **`remember`** : mÃ©morise une valeur **tant que** le composable reste dans lâ€™arbre (perd lâ€™Ã©tat Ã  la rotation/process kill).
- **`rememberSaveable`** : mÃ©morise **et** sauvegarde/restaure via `Bundle` (types primitifs, `Parcelable`, `Serializable`â€¦).
- **State hoisting** : remonter lâ€™**Ã©tat** et les **Ã©vÃ©nements** au **parent** (UI â€œdumbâ€/stateless), *single source of truth*.
- **One-way data flow** : `state â†’ UI â†’ events â†’ reducer` (VM ou parent met Ã  jour le state).

---

## âœ… Objectif
Savoir **oÃ¹** stocker lâ€™Ã©tat (local vs hoistÃ©), quand utiliser **`remember`** ou **`rememberSaveable`**, et Ã©crire des composables **stateless** rÃ©utilisables.

---

## 1) `remember` vs `rememberSaveable` (rappel express)

```kotlin
var text by remember { mutableStateOf("") }            // survit aux recompositions
var text2 by rememberSaveable { mutableStateOf("") }   // + survit rotation / process
````

**Quand ?**

* **`remember`** : Ã©tats **Ã©phÃ©mÃ¨res** (animation, focus, scroll) ou **dÃ©rivÃ©s** faciles Ã  recalculer.
* **`rememberSaveable`** : **entrÃ©e utilisateur**, sÃ©lections, *UI state* de formulaires/counters.

> Types non supportÃ©s ? Fournir un **`Saver`** (ex. `TextFieldValue.Saver`).

---

## 2) *State hoisting* : transformer un composable **stateful** en **stateless**

### A) Version *stateful* (Ã  Ã©viter pour la rÃ©utilisation)

```kotlin
@Composable
fun CounterStateful() {
  var count by rememberSaveable { mutableStateOf(0) }
  Row {
    IconButton(onClick = { if (count > 0) count-- }, enabled = count > 0) { Icon(Icons.Default.Remove, null) }
    Text("$count", style = MaterialTheme.typography.headlineSmall, modifier = Modifier.widthIn(min = 40.dp))
    IconButton(onClick = { count++ }) { Icon(Icons.Default.Add, null) }
  }
}
```

### B) Version **stateless** (recommandÃ©)

```kotlin
@Composable
fun Counter(
  value: Int,
  onIncrement: () -> Unit,
  onDecrement: () -> Unit,
  modifier: Modifier = Modifier
) {
  Row(modifier, verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(12.dp)) {
    IconButton(onClick = onDecrement, enabled = value > 0) { Icon(Icons.Default.Remove, null) }
    Text("$value", style = MaterialTheme.typography.headlineSmall, modifier = Modifier.widthIn(min = 40.dp))
    IconButton(onClick = onIncrement) { Icon(Icons.Default.Add, null) }
  }
}
```

### C) Parent **orchestrateur** (hoisting)

```kotlin
@Composable
fun CounterHost() {
  var count by rememberSaveable { mutableStateOf(0) }
  Counter(
    value = count,
    onIncrement = { count++ },
    onDecrement = { if (count > 0) count-- }
  )
}
```

> âœ… Avantages : testable, rÃ©utilisable, logique dâ€™Ã©tat **centralisÃ©e** (parent/VM).

---

## 3) Formulaire â€œPrÃ©nom + Bonjourâ€ (hoisting + saveable)

```kotlin
@Composable
fun GreetingForm(
  name: String,
  onNameChange: (String) -> Unit,
  onGreet: () -> Unit,
  enabled: Boolean,
  message: String?
) {
  Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
    OutlinedTextField(
      value = name,
      onValueChange = onNameChange,
      label = { Text(stringResource(R.string.label_firstname)) },
      placeholder = { Text(stringResource(R.string.ph_firstname)) },
      singleLine = true,
      modifier = Modifier.fillMaxWidth()
    )
    Button(onClick = onGreet, enabled = enabled, modifier = Modifier.fillMaxWidth()) {
      Text(stringResource(R.string.btn_greet))
    }
    message?.let { AssistChip(onClick = {}, label = { Text(it) }) }
  }
}

@Composable
fun GreetingHost() {
  var name by rememberSaveable { mutableStateOf("") }
  var greeting by rememberSaveable { mutableStateOf<String?>(null) }
  GreetingForm(
    name = name,
    onNameChange = { n -> name = n; if (n.isBlank()) greeting = null },
    onGreet = { if (name.isNotBlank()) greeting = stringResource(R.string.msg_greeting, name.trim()) },
    enabled = name.isNotBlank(),
    message = greeting
  )
}
```

---

## 4) `rememberSaveable` avec **`Saver`** (curseur `TextFieldValue`)

```kotlin
var field by rememberSaveable(stateSaver = TextFieldValue.Saver) {
  mutableStateOf(TextFieldValue(""))
}
// OutlinedTextField(value = field, onValueChange = { field = it })
```

Pour un type perso :

```kotlin
@Immutable data class UiId(val raw: String)
val UiIdSaver = Saver<UiId, String>(save = { it.raw }, restore = { UiId(it) })
var id by rememberSaveable(stateSaver = UiIdSaver) { mutableStateOf(UiId("init")) }
```

---

## 5) Bonnes pratiques (one-way data flow)

* **Stateless** par dÃ©faut : `value` + `onValueChange`.
* **Parent** (ou **ViewModel**) possÃ¨de lâ€™Ã©tat â†’ *single source of truth*.
* **Ã‰vÃ©nements** = lambdas simples (`onClick`, `onNameChange`).
* Ã‰viter de remonter des **types UI** profonds ; prÃ©fÃ©rez des **intents** (`onIncrement()`).

> Avec ViewModel : exposez un **`UiState` immuable** + mÃ©thodes dâ€™intent ; lâ€™Ã©cran observe via `collectAsState()`.

---

## 6) DÃ©rivÃ©s dâ€™Ã©tat & perf (optionnel)

```kotlin
val canGreet by remember(name) { mutableStateOf(name.isNotBlank()) }
// ou mieux, Ã©viter un nouveau state : calcul direct `val canGreet = name.isNotBlank()`

// Cas coÃ»teux â†’ `derivedStateOf`
val sorted by remember(items) { derivedStateOf { items.sorted() } }
```

---

## 7) PrÃ©views

```kotlin
@Preview(showBackground = true, widthDp = 360)
@Composable fun CounterPreview() { MaterialTheme { CounterHost() } }

@Preview(showBackground = true, widthDp = 360)
@Composable fun GreetingPreview() { MaterialTheme { GreetingHost() } }
```

---

## ðŸ§ª VÃ©rifications rapides

* [ ] Les composants exposent `value` **et** `onValueChange` (stateless).
* [ ] Le parent gÃ¨re lâ€™Ã©tat via **`rememberSaveable`** pour lâ€™entrÃ©e utilisateur.
* [ ] La rotation **conserve** `name`, `greeting`, `count`.
* [ ] Aucune duplication de *single source of truth* (pas dâ€™Ã©tats concurrents).

---

## ðŸ©¹ DÃ©pannage

* **Ã‰tat perdu Ã  la rotation** â†’ utiliser `rememberSaveable` (ou VM).
* **Boucle de recomposition** â†’ ne recrÃ©ez pas des lambdas/objets lourds sans `remember`.
* **Deux sources dâ€™Ã©tat** (enfant + parent) â†’ rendre lâ€™enfant **stateless**.
* **Types non sauvegardÃ©s** â†’ fournir un **`Saver`**.

---

## ðŸ“¦ Livrables attendus

* `Counter` **stateless** + `CounterHost` **saveable**.
* `GreetingForm` hoistÃ©e + host qui **persiste** lâ€™Ã©tat.
* (Optionnel) Exemple de `Saver` custom.

---

## âœ… DoD â€” Definition of Done

* [ ] Composables **stateless** (props `value` + callbacks).
* [ ] Parent/VM **unique dÃ©tenteur** de lâ€™Ã©tat.
* [ ] `rememberSaveable` appliquÃ© aux entrÃ©es utilisateur clÃ©s.
* [ ] PrÃ©views **affichables**.

---

## âš¡ Cheatsheet

```kotlin
// Local (Ã©phÃ©mÃ¨re)
var x by remember { mutableStateOf(0) }

// Persister UI input
var name by rememberSaveable { mutableStateOf("") }

// Stateless API
@Composable fun Field(value: String, onChange: (String) -> Unit) { /* â€¦ */ }

// Hoisting
@Composable fun Host() {
  var v by rememberSaveable { mutableStateOf("") }
  Field(value = v, onChange = { v = it })
}
```
