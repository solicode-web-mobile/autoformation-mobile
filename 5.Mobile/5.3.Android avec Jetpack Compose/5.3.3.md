---
title: 3. remember/saveable
layout: home
nav_order: 3
parent: 5.3. Android avec Compose
permalink: /android-compose-mvvm/remember-saveable/
code: 5.3.3
competence: C5
autoformation: "C5.3"
ua: "5.3.U2"
duree_h: 1.5
objectif: "Choisir où stocker l’état, le persister avec rememberSaveable et hoister les composants."
notions_nouvelles: ["remember", "rememberSaveable", "Saver", "State hoisting", "One-way data flow"]
fil_rouge: "HelloCounter — persistance de name/greeting/count"
livrable_chapitre: "Counter stateless + CounterHost saveable ; GreetingForm hoistée"
alimentation_prototype: "État fiable et testable pour N2"
alimentation_miniprojet: "Flux de données cohérent (sans état dupliqué) pour N3"
---


# 📘 5.3.3 - `remember` / `rememberSaveable`, *state hoisting*

## 📒 Glossaire minute
- **`remember`** : mémorise une valeur **tant que** le composable reste dans l’arbre (perd l’état à la rotation/process kill).
- **`rememberSaveable`** : mémorise **et** sauvegarde/restaure via `Bundle` (types primitifs, `Parcelable`, `Serializable`…).
- **State hoisting** : remonter l’**état** et les **événements** au **parent** (UI “dumb”/stateless), *single source of truth*.
- **One-way data flow** : `state → UI → events → reducer` (VM ou parent met à jour le state).

---

## ✅ Objectif
Savoir **où** stocker l’état (local vs hoisté), quand utiliser **`remember`** ou **`rememberSaveable`**, et écrire des composables **stateless** réutilisables.

---

## 1) `remember` vs `rememberSaveable` (rappel express)

```kotlin
var text by remember { mutableStateOf("") }            // survit aux recompositions
var text2 by rememberSaveable { mutableStateOf("") }   // + survit rotation / process
````

**Quand ?**

* **`remember`** : états **éphémères** (animation, focus, scroll) ou **dérivés** faciles à recalculer.
* **`rememberSaveable`** : **entrée utilisateur**, sélections, *UI state* de formulaires/counters.

> Types non supportés ? Fournir un **`Saver`** (ex. `TextFieldValue.Saver`).

---

## 2) *State hoisting* : transformer un composable **stateful** en **stateless**

### A) Version *stateful* (à éviter pour la réutilisation)

```kotlin
@Composable
fun CounterStateful() {
  var count by rememberSaveable { mutableStateOf(0) }
  Row {
    IconButton(onClick = { if (count > 0) count-- }, enabled = count > 0) { Icon(Icons.Default.Remove, null) }
    Text("$count", style = MaterialTheme.typography.headlineSmall, modifier = Modifier.widthIn(min = 40.dp))
    IconButton(onClick = { count++ }) { Icon(Icons.Default.Add, null) }
  }
}
```

### B) Version **stateless** (recommandé)

```kotlin
@Composable
fun Counter(
  value: Int,
  onIncrement: () -> Unit,
  onDecrement: () -> Unit,
  modifier: Modifier = Modifier
) {
  Row(modifier, verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(12.dp)) {
    IconButton(onClick = onDecrement, enabled = value > 0) { Icon(Icons.Default.Remove, null) }
    Text("$value", style = MaterialTheme.typography.headlineSmall, modifier = Modifier.widthIn(min = 40.dp))
    IconButton(onClick = onIncrement) { Icon(Icons.Default.Add, null) }
  }
}
```

### C) Parent **orchestrateur** (hoisting)

```kotlin
@Composable
fun CounterHost() {
  var count by rememberSaveable { mutableStateOf(0) }
  Counter(
    value = count,
    onIncrement = { count++ },
    onDecrement = { if (count > 0) count-- }
  )
}
```

> ✅ Avantages : testable, réutilisable, logique d’état **centralisée** (parent/VM).

---

## 3) Formulaire “Prénom + Bonjour” (hoisting + saveable)

```kotlin
@Composable
fun GreetingForm(
  name: String,
  onNameChange: (String) -> Unit,
  onGreet: () -> Unit,
  enabled: Boolean,
  message: String?
) {
  Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
    OutlinedTextField(
      value = name,
      onValueChange = onNameChange,
      label = { Text(stringResource(R.string.label_firstname)) },
      placeholder = { Text(stringResource(R.string.ph_firstname)) },
      singleLine = true,
      modifier = Modifier.fillMaxWidth()
    )
    Button(onClick = onGreet, enabled = enabled, modifier = Modifier.fillMaxWidth()) {
      Text(stringResource(R.string.btn_greet))
    }
    message?.let { AssistChip(onClick = {}, label = { Text(it) }) }
  }
}

@Composable
fun GreetingHost() {
  var name by rememberSaveable { mutableStateOf("") }
  var greeting by rememberSaveable { mutableStateOf<String?>(null) }
  GreetingForm(
    name = name,
    onNameChange = { n -> name = n; if (n.isBlank()) greeting = null },
    onGreet = { if (name.isNotBlank()) greeting = stringResource(R.string.msg_greeting, name.trim()) },
    enabled = name.isNotBlank(),
    message = greeting
  )
}
```

---

## 4) `rememberSaveable` avec **`Saver`** (curseur `TextFieldValue`)

```kotlin
var field by rememberSaveable(stateSaver = TextFieldValue.Saver) {
  mutableStateOf(TextFieldValue(""))
}
// OutlinedTextField(value = field, onValueChange = { field = it })
```

Pour un type perso :

```kotlin
@Immutable data class UiId(val raw: String)
val UiIdSaver = Saver<UiId, String>(save = { it.raw }, restore = { UiId(it) })
var id by rememberSaveable(stateSaver = UiIdSaver) { mutableStateOf(UiId("init")) }
```

---

## 5) Bonnes pratiques (one-way data flow)

* **Stateless** par défaut : `value` + `onValueChange`.
* **Parent** (ou **ViewModel**) possède l’état → *single source of truth*.
* **Événements** = lambdas simples (`onClick`, `onNameChange`).
* Éviter de remonter des **types UI** profonds ; préférez des **intents** (`onIncrement()`).

> Avec ViewModel : exposez un **`UiState` immuable** + méthodes d’intent ; l’écran observe via `collectAsState()`.

---

## 6) Dérivés d’état & perf (optionnel)

```kotlin
val canGreet by remember(name) { mutableStateOf(name.isNotBlank()) }
// ou mieux, éviter un nouveau state : calcul direct `val canGreet = name.isNotBlank()`

// Cas coûteux → `derivedStateOf`
val sorted by remember(items) { derivedStateOf { items.sorted() } }
```

---

## 7) Préviews

```kotlin
@Preview(showBackground = true, widthDp = 360)
@Composable fun CounterPreview() { MaterialTheme { CounterHost() } }

@Preview(showBackground = true, widthDp = 360)
@Composable fun GreetingPreview() { MaterialTheme { GreetingHost() } }
```

---

## 🧪 Vérifications rapides

* [ ] Les composants exposent `value` **et** `onValueChange` (stateless).
* [ ] Le parent gère l’état via **`rememberSaveable`** pour l’entrée utilisateur.
* [ ] La rotation **conserve** `name`, `greeting`, `count`.
* [ ] Aucune duplication de *single source of truth* (pas d’états concurrents).

---

## 🩹 Dépannage

* **État perdu à la rotation** → utiliser `rememberSaveable` (ou VM).
* **Boucle de recomposition** → ne recréez pas des lambdas/objets lourds sans `remember`.
* **Deux sources d’état** (enfant + parent) → rendre l’enfant **stateless**.
* **Types non sauvegardés** → fournir un **`Saver`**.

---

## 📦 Livrables attendus

* `Counter` **stateless** + `CounterHost` **saveable**.
* `GreetingForm` hoistée + host qui **persiste** l’état.
* (Optionnel) Exemple de `Saver` custom.

---

## ✅ DoD — Definition of Done

* [ ] Composables **stateless** (props `value` + callbacks).
* [ ] Parent/VM **unique détenteur** de l’état.
* [ ] `rememberSaveable` appliqué aux entrées utilisateur clés.
* [ ] Préviews **affichables**.

---

## ⚡ Cheatsheet

```kotlin
// Local (éphémère)
var x by remember { mutableStateOf(0) }

// Persister UI input
var name by rememberSaveable { mutableStateOf("") }

// Stateless API
@Composable fun Field(value: String, onChange: (String) -> Unit) { /* … */ }

// Hoisting
@Composable fun Host() {
  var v by rememberSaveable { mutableStateOf("") }
  Field(value = v, onChange = { v = it })
}
```
