---
title: 1. Composables
layout: home
nav_order: 1
parent: 5.3. Android avec Compose
permalink: /android-compose/composables/
code: 5.3.1
competence: C5
autoformation: "C5.3"
ua: "5.3.U1"
duree_h: 1.5
objectif: "Afficher texte, bouton, saisie et image puis prévisualiser l’écran avec @Preview."
notions_nouvelles: ["Composable", "Modifier", "@Preview", "TextField", "Button"]
fil_rouge: "HelloCounter — écran Hello + Compteur"
livrable_chapitre: "Écran combinant Text/Button/TextField/Image + 2 @Preview (Light/Dark)"
alimentation_prototype: "Briques UI de base prêtes pour la démo N2"
alimentation_miniprojet: "Composants réutilisables et préviews standardisées pour N3"
---


# 📘 5.3.1 - Composables essentiels

## 📒 Glossaire minute
- **Composable** : fonction annotée `@Composable` qui déclare un morceau d’UI.  
- **Modifier** : outil pour enchaîner des réglages visuels (taille, padding, clic, etc.).  
- **`@Preview`** : permet de visualiser un composable directement dans Android Studio, sans lancer l’app.  
- **State** : donnée qui change au cours du temps et qui déclenche la mise à jour automatique de l’UI.  
- **rememberSaveable** : fonction qui garde un état même si l’activité est recréée (ex. rotation d’écran).  

---

## 🎯 Objectif pédagogique
À partir de l’app **HelloCounter** déjà construite, comprendre :  
- comment un composable est défini,  
- comment il assemble d’autres composables,  
- comment l’état est géré avec `rememberSaveable`,  
- et comment prévisualiser un écran.

---

## 🧠 Explication à partir du code existant

### 1. `MainActivity`
Le point d’entrée de l’app. Elle applique le **thème** et appelle `MainScreen`.

```kotlin
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent { HelloCounterTheme { MainScreen() } }
    }
}
````

👉 Ici, `setContent { ... }` attend un **composable racine** : on passe `MainScreen`.

---

### 2. `MainScreen`

Un composable **écran** qui assemble deux sections : `DireBonjourSection` et `CompteurSection`.

```kotlin
@Composable
fun MainScreen(modifier: Modifier = Modifier) {
    Column(
        modifier = modifier.fillMaxSize().padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(24.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        DireBonjourSection()
        CompteurSection()
    }
}
```

👉 `Column` est lui-même un composable.
👉 `MainScreen` **ne dessine pas directement**, il **organise** d’autres composables.

---

### 3. `DireBonjourSection`

Un composable de section qui gère la **saisie du prénom** et l’affichage d’un **message**.

```kotlin
@Composable
fun DireBonjourSection(modifier: Modifier = Modifier) {
    var name by rememberSaveable { mutableStateOf("") }
    var greetingName by rememberSaveable { mutableStateOf<String?>(null) }

    Column(modifier = modifier.fillMaxWidth()) {
        OutlinedTextField(
            value = name,
            onValueChange = { ... },
            label = { Text(stringResource(R.string.label_firstname)) },
            placeholder = { Text(stringResource(R.string.ph_firstname)) }
        )

        Button(
            onClick = { greetingName = name.takeIf { it.isNotBlank() } },
            enabled = name.isNotBlank()
        ) {
            Text(stringResource(R.string.btn_greet))
        }

        if (greetingName != null) {
            AssistChip(onClick = { }, label = { Text("Bonjour $greetingName") })
        }
    }
}
```

👉 Ici, chaque élément (`OutlinedTextField`, `Button`, `AssistChip`) est un composable prêt à l’emploi.
👉 `DireBonjourSection` les combine pour former un **bloc fonctionnel**.

---

### 4. `CompteurSection`

Un composable qui gère un **compteur** avec boutons − et +.

```kotlin
@Composable
fun CompteurSection(modifier: Modifier = Modifier) {
    var count by rememberSaveable { mutableStateOf(0) }

    Row {
        IconButton(onClick = { if (count > 0) count-- }) {
            Icon(Icons.Filled.Remove, contentDescription = "Diminuer")
        }
        Text(text = "$count", style = MaterialTheme.typography.headlineSmall)
        IconButton(onClick = { count++ }) {
            Icon(Icons.Filled.Add, contentDescription = "Augmenter")
        }
    }
}
```

---













#### 🔎 Décomposition complète : `var count by rememberSaveable { mutableStateOf(0) }`

---

##### 1. `mutableStateOf(0)`

* Crée un **état observable** qui commence avec la valeur `0`.
* Type retourné : `MutableState<Int>`.
* À chaque fois que la valeur change (`state.value++`), Compose **recompose l’UI**.

---

##### 2. `rememberSaveable { ... }`

`rememberSaveable` est une fonction de Compose qui mémorise un état **et le sauvegarde automatiquement** si l’activité est recréée (rotation écran, changement de configuration).

Sa signature simplifiée :

```kotlin
fun <T : Any> rememberSaveable(
    saver: Saver<T, out Any>? = null,
    init: () -> T
): T
```

👉 Le dernier paramètre `init: () -> T` signifie : *“donne-moi une fonction qui crée la valeur initiale”*.

C’est pour ça qu’on écrit **`{ mutableStateOf(0) }`** → une **lambda** qui retourne un `MutableState<Int>`.

---

##### 🧩 Exemple hors Compose (lambda en argument)

```kotlin
fun execute(action: () -> Unit) {
    action() // exécute la lambda
}

fun main() {
    execute { println("Hello") }  // ici { println("Hello") } est une lambda
}
```

👉 Même principe : `rememberSaveable { mutableStateOf(0) }` passe une **lambda** qui initialise l’état.

---

##### 3. Le mot-clé `by` (délégation)

En Kotlin, `MutableState<T>` expose sa valeur via `.value`.
Sans délégation, il faut écrire `state.value`.

Exemple :

```kotlin
val countState = rememberSaveable { mutableStateOf(0) }
countState.value++   // accès manuel à .value
Text("Compteur : ${countState.value}")
```

Avec `by`, Kotlin permet de **déléguer la propriété** directement au `State`.

```kotlin
var count by rememberSaveable { mutableStateOf(0) }
count++   // équivalent à countState.value++
Text("Compteur : $count")
```

👉 Grâce à `by`, on manipule la variable comme une **var classique**, mais Compose continue à observer et re-render l’UI.

---

##### 4. Comparaison complète

| Sans délégation (`by`)      | Avec délégation (`by`) |
| --------------------------- | ---------------------- |
| val countState =            | var count by           |
| rememberSaveable {          | rememberSaveable {     |
| mutableStateOf(0) }         | mutableStateOf(0) }    |
|                             |                        |
| countState.value++          | count++                |
| Text("${countState.value}") | Text("$count")         |


👉 Les deux font **exactement la même chose**, mais la version avec `by` est **plus lisible**.

---

##### ✅ Résumé

* `mutableStateOf(0)` → crée un état observable (initialisé à 0).
* `rememberSaveable { ... }` → garde cet état même après recréation de l’activité.
* `{ }` → une **lambda** passée en argument (initialisation).
* `by` → délégation de propriété qui évite d’écrire `.value` partout.

Résultat :

```kotlin
var count by rememberSaveable { mutableStateOf(0) }
```

= *“Une variable compteur observable, initialisée à 0, sauvegardée automatiquement, et accessible comme une var classique.”*

 
 



### 5. `@Preview`

Un composable spécial pour tester l’UI dans Android Studio.

```kotlin
@Preview(showBackground = true, widthDp = 360)
@Composable
fun PreviewMainScreen() {
    HelloCounterTheme { MainScreen() }
}
```

👉 Ici, pas besoin de lancer l’appli : on voit directement `MainScreen` dans l’éditeur.

---

## 🧾 Résumé et points-clés

* Un **composable** est une fonction annotée `@Composable`.
* Un **écran** (`MainScreen`) est une composition de plusieurs composables internes.
* L’**état** se gère avec `rememberSaveable { mutableStateOf(...) }`.
* `by` simplifie l’accès à la valeur de l’état.
* `@Preview` permet de tester sans exécuter l’app.

---

## 📦 Livrable attendu

Un **schéma d’explication** (écrit ou graphique) qui montre le lien entre :

* `MainActivity` → lance `MainScreen`,
* `MainScreen` → assemble `DireBonjourSection` et `CompteurSection`,
* chaque composable interne → utilise des briques comme `Text`, `Button`, `OutlinedTextField`, `IconButton`.

---

## ✅ Definition of Done

* [ ] L’apprenant sait **identifier un composable**.
* [ ] L’apprenant comprend le rôle de `rememberSaveable`.
* [ ] L’apprenant peut expliquer `var count by rememberSaveable { mutableStateOf(0) }`.
* [ ] L’apprenant sait lire une Preview et distinguer ce qui s’exécute dans l’app réelle.

---

