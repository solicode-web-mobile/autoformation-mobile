---
title: 1. Composables
layout: home
nav_order: 1
parent: 5.3. Android avec Compose
permalink: /android-compose/composables/
code: 5.3.1
competence: C5
autoformation: "C5.3"
ua: "5.3.U1"
duree_h: 1.5
objectif: "Afficher texte, bouton, saisie et image puis prÃ©visualiser lâ€™Ã©cran avec @Preview."
notions_nouvelles: ["Composable", "Modifier", "@Preview", "TextField", "Button"]
fil_rouge: "HelloCounter â€” Ã©cran Hello + Compteur"
livrable_chapitre: "Ã‰cran combinant Text/Button/TextField/Image + 2 @Preview (Light/Dark)"
alimentation_prototype: "Briques UI de base prÃªtes pour la dÃ©mo N2"
alimentation_miniprojet: "Composants rÃ©utilisables et prÃ©views standardisÃ©es pour N3"
---


# ğŸ“˜ 5.3.1 - Composables essentiels

## ğŸ“’ Glossaire minute
- **Composable** : fonction annotÃ©e `@Composable` qui dÃ©clare un morceau dâ€™UI.  
- **Modifier** : outil pour enchaÃ®ner des rÃ©glages visuels (taille, padding, clic, etc.).  
- **`@Preview`** : permet de visualiser un composable directement dans Android Studio, sans lancer lâ€™app.  
- **State** : donnÃ©e qui change au cours du temps et qui dÃ©clenche la mise Ã  jour automatique de lâ€™UI.  
- **rememberSaveable** : fonction qui garde un Ã©tat mÃªme si lâ€™activitÃ© est recrÃ©Ã©e (ex. rotation dâ€™Ã©cran).  

---

## ğŸ¯ Objectif pÃ©dagogique
Ã€ partir de lâ€™app **HelloCounter** dÃ©jÃ  construite, comprendre :  
- comment un composable est dÃ©fini,  
- comment il assemble dâ€™autres composables,  
- comment lâ€™Ã©tat est gÃ©rÃ© avec `rememberSaveable`,  
- et comment prÃ©visualiser un Ã©cran.

---

## ğŸ§  Explication Ã  partir du code existant

### 1. `MainActivity`
Le point dâ€™entrÃ©e de lâ€™app. Elle applique le **thÃ¨me** et appelle `MainScreen`.

```kotlin
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent { HelloCounterTheme { MainScreen() } }
    }
}
````

ğŸ‘‰ Ici, `setContent { ... }` attend un **composable racine** : on passe `MainScreen`.

---

### 2. `MainScreen`

Un composable **Ã©cran** qui assemble deux sections : `DireBonjourSection` et `CompteurSection`.

```kotlin
@Composable
fun MainScreen(modifier: Modifier = Modifier) {
    Column(
        modifier = modifier.fillMaxSize().padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(24.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        DireBonjourSection()
        CompteurSection()
    }
}
```

ğŸ‘‰ `Column` est lui-mÃªme un composable.
ğŸ‘‰ `MainScreen` **ne dessine pas directement**, il **organise** dâ€™autres composables.

---

### 3. `DireBonjourSection`

Un composable de section qui gÃ¨re la **saisie du prÃ©nom** et lâ€™affichage dâ€™un **message**.

```kotlin
@Composable
fun DireBonjourSection(modifier: Modifier = Modifier) {
    var name by rememberSaveable { mutableStateOf("") }
    var greetingName by rememberSaveable { mutableStateOf<String?>(null) }

    Column(modifier = modifier.fillMaxWidth()) {
        OutlinedTextField(
            value = name,
            onValueChange = { ... },
            label = { Text(stringResource(R.string.label_firstname)) },
            placeholder = { Text(stringResource(R.string.ph_firstname)) }
        )

        Button(
            onClick = { greetingName = name.takeIf { it.isNotBlank() } },
            enabled = name.isNotBlank()
        ) {
            Text(stringResource(R.string.btn_greet))
        }

        if (greetingName != null) {
            AssistChip(onClick = { }, label = { Text("Bonjour $greetingName") })
        }
    }
}
```

ğŸ‘‰ Ici, chaque Ã©lÃ©ment (`OutlinedTextField`, `Button`, `AssistChip`) est un composable prÃªt Ã  lâ€™emploi.
ğŸ‘‰ `DireBonjourSection` les combine pour former un **bloc fonctionnel**.

---

### 4. `CompteurSection`

Un composable qui gÃ¨re un **compteur** avec boutons âˆ’ et +.

```kotlin
@Composable
fun CompteurSection(modifier: Modifier = Modifier) {
    var count by rememberSaveable { mutableStateOf(0) }

    Row {
        IconButton(onClick = { if (count > 0) count-- }) {
            Icon(Icons.Filled.Remove, contentDescription = "Diminuer")
        }
        Text(text = "$count", style = MaterialTheme.typography.headlineSmall)
        IconButton(onClick = { count++ }) {
            Icon(Icons.Filled.Add, contentDescription = "Augmenter")
        }
    }
}
```

---













#### ğŸ” DÃ©composition complÃ¨te : `var count by rememberSaveable { mutableStateOf(0) }`

---

##### 1. `mutableStateOf(0)`

* CrÃ©e un **Ã©tat observable** qui commence avec la valeur `0`.
* Type retournÃ© : `MutableState<Int>`.
* Ã€ chaque fois que la valeur change (`state.value++`), Compose **recompose lâ€™UI**.

---

##### 2. `rememberSaveable { ... }`

`rememberSaveable` est une fonction de Compose qui mÃ©morise un Ã©tat **et le sauvegarde automatiquement** si lâ€™activitÃ© est recrÃ©Ã©e (rotation Ã©cran, changement de configuration).

Sa signature simplifiÃ©e :

```kotlin
fun <T : Any> rememberSaveable(
    saver: Saver<T, out Any>? = null,
    init: () -> T
): T
```

ğŸ‘‰ Le dernier paramÃ¨tre `init: () -> T` signifie : *â€œdonne-moi une fonction qui crÃ©e la valeur initialeâ€*.

Câ€™est pour Ã§a quâ€™on Ã©crit **`{ mutableStateOf(0) }`** â†’ une **lambda** qui retourne un `MutableState<Int>`.

---

##### ğŸ§© Exemple hors Compose (lambda en argument)

```kotlin
fun execute(action: () -> Unit) {
    action() // exÃ©cute la lambda
}

fun main() {
    execute { println("Hello") }  // ici { println("Hello") } est une lambda
}
```

ğŸ‘‰ MÃªme principe : `rememberSaveable { mutableStateOf(0) }` passe une **lambda** qui initialise lâ€™Ã©tat.

---

##### 3. Le mot-clÃ© `by` (dÃ©lÃ©gation)

En Kotlin, `MutableState<T>` expose sa valeur via `.value`.
Sans dÃ©lÃ©gation, il faut Ã©crire `state.value`.

Exemple :

```kotlin
val countState = rememberSaveable { mutableStateOf(0) }
countState.value++   // accÃ¨s manuel Ã  .value
Text("Compteur : ${countState.value}")
```

Avec `by`, Kotlin permet de **dÃ©lÃ©guer la propriÃ©tÃ©** directement au `State`.

```kotlin
var count by rememberSaveable { mutableStateOf(0) }
count++   // Ã©quivalent Ã  countState.value++
Text("Compteur : $count")
```

ğŸ‘‰ GrÃ¢ce Ã  `by`, on manipule la variable comme une **var classique**, mais Compose continue Ã  observer et re-render lâ€™UI.

---

##### 4. Comparaison complÃ¨te

| Sans dÃ©lÃ©gation (`by`)      | Avec dÃ©lÃ©gation (`by`) |
| --------------------------- | ---------------------- |
| val countState =            | var count by           |
| rememberSaveable {          | rememberSaveable {     |
| mutableStateOf(0) }         | mutableStateOf(0) }    |
|                             |                        |
| countState.value++          | count++                |
| Text("${countState.value}") | Text("$count")         |


ğŸ‘‰ Les deux font **exactement la mÃªme chose**, mais la version avec `by` est **plus lisible**.

---

##### âœ… RÃ©sumÃ©

* `mutableStateOf(0)` â†’ crÃ©e un Ã©tat observable (initialisÃ© Ã  0).
* `rememberSaveable { ... }` â†’ garde cet Ã©tat mÃªme aprÃ¨s recrÃ©ation de lâ€™activitÃ©.
* `{ }` â†’ une **lambda** passÃ©e en argument (initialisation).
* `by` â†’ dÃ©lÃ©gation de propriÃ©tÃ© qui Ã©vite dâ€™Ã©crire `.value` partout.

RÃ©sultat :

```kotlin
var count by rememberSaveable { mutableStateOf(0) }
```

= *â€œUne variable compteur observable, initialisÃ©e Ã  0, sauvegardÃ©e automatiquement, et accessible comme une var classique.â€*

 
 



### 5. `@Preview`

Un composable spÃ©cial pour tester lâ€™UI dans Android Studio.

```kotlin
@Preview(showBackground = true, widthDp = 360)
@Composable
fun PreviewMainScreen() {
    HelloCounterTheme { MainScreen() }
}
```

ğŸ‘‰ Ici, pas besoin de lancer lâ€™appli : on voit directement `MainScreen` dans lâ€™Ã©diteur.

---

## ğŸ§¾ RÃ©sumÃ© et points-clÃ©s

* Un **composable** est une fonction annotÃ©e `@Composable`.
* Un **Ã©cran** (`MainScreen`) est une composition de plusieurs composables internes.
* Lâ€™**Ã©tat** se gÃ¨re avec `rememberSaveable { mutableStateOf(...) }`.
* `by` simplifie lâ€™accÃ¨s Ã  la valeur de lâ€™Ã©tat.
* `@Preview` permet de tester sans exÃ©cuter lâ€™app.

---

## ğŸ“¦ Livrable attendu

Un **schÃ©ma dâ€™explication** (Ã©crit ou graphique) qui montre le lien entre :

* `MainActivity` â†’ lance `MainScreen`,
* `MainScreen` â†’ assemble `DireBonjourSection` et `CompteurSection`,
* chaque composable interne â†’ utilise des briques comme `Text`, `Button`, `OutlinedTextField`, `IconButton`.

---

## âœ… Definition of Done

* [ ] Lâ€™apprenant sait **identifier un composable**.
* [ ] Lâ€™apprenant comprend le rÃ´le de `rememberSaveable`.
* [ ] Lâ€™apprenant peut expliquer `var count by rememberSaveable { mutableStateOf(0) }`.
* [ ] Lâ€™apprenant sait lire une Preview et distinguer ce qui sâ€™exÃ©cute dans lâ€™app rÃ©elle.

---

