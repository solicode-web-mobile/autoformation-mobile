---
title: 5. ViewModel & UiState
layout: home
nav_order: 5
parent: 5.3. Android avec Compose
permalink: /android-compose/viewmodel-ui-state/
code: 5.3.5
competence: C5
autoformation: "C5.3"
ua: "5.3.U3"
duree_h: 2
objectif: "Mettre en place ViewModel + StateFlow + intents avec UI stateless et flux unidirectionnel."
notions_nouvelles: ["ViewModel", "UiState immuable", "StateFlow", "collectAsState", "Intents"]
fil_rouge: "HelloCounter â€” VM avec intents et gestion dâ€™erreurs"
livrable_chapitre: "MainViewModel + MainScreenStateless + MainScreenVM (collectAsState)"
alimentation_prototype: "Source dâ€™Ã©tat unique pour la dÃ©mo N2"
alimentation_miniprojet: "Architecture UDF testable pour N3"
---


# ðŸ“˜ 5.3.5 - `ViewModel`, Ã©tat immuable (UI state) et *intents* dâ€™actions

## ðŸ“’ Glossaire minute
- **ViewModel** : dÃ©tient la logique & lâ€™**Ã©tat** survivant aux changements de config.  
- **UI state** : `data class` **immuable** reprÃ©sentant lâ€™Ã©cran (source unique de vÃ©ritÃ©).  
- **Intent** : action utilisateur/Ã©vÃ©nement (ex. `onIncrement()`, `onLoad()`).  
- **StateFlow** : flux **chaud** dâ€™Ã©tat observÃ© par lâ€™UI (`collectAsState()`).

---

## âœ… Objectif
Mettre en place un **flux unidirectionnel** :  
`Intents (UI) â†’ ViewModel (rÃ©duit) â†’ UiState (StateFlow) â†’ Compose rend lâ€™UI`.

---

## ðŸ”§ PrÃ©-requis
- Compose de base (5.3.1â€“5.3.3).  
- Kotlin essentiel (data class, copy).

---

## 1) ModÃ©liser lâ€™UI **immuable**

```kotlin
// UiState.kt
data class UiState(
  val name: String = "",
  val greeting: String? = null,
  val count: Int = 0,
  val loading: Boolean = false,
  val error: String? = null
)
````

> ðŸ”’ `val` + **`copy`** pour chaque mise Ã  jour â†’ pas de mutation surprenante.

---

## 2) DÃ©finir des **intents** (API claire)

Deux styles possibles â€” **mÃ©thodes** ou **intents scellÃ©s**. On commence simple :

```kotlin
// MainViewModel.kt (signature des intents)
interface MainIntents {
  fun onNameChange(newName: String)
  fun onGreet()
  fun onIncrement()
  fun onDecrement()
  fun clearError()
}
```

---

## 3) ImplÃ©menter le **ViewModel** (rÃ©ducteur dâ€™Ã©tat)

```kotlin
class MainViewModel : ViewModel(), MainIntents {

  private val _ui = MutableStateFlow(UiState())
  val ui: StateFlow<UiState> = _ui

  override fun onNameChange(newName: String) {
    val cleaned = newName.trim()
    _ui.update { s ->
      s.copy(
        name = newName,                                   // garder la saisie
        greeting = if (cleaned.isNotEmpty()) s.greeting else null,
        error = null
      )
    }
  }

  override fun onGreet() {
    _ui.update { s ->
      val cleaned = s.name.trim()
      if (cleaned.isEmpty()) s.copy(error = "Le prÃ©nom est vide.")
      else s.copy(greeting = "Bonjour, $cleaned !", error = null)
    }
  }

  override fun onIncrement() {
    _ui.update { it.copy(count = it.count + 1) }
  }

  override fun onDecrement() {
    _ui.update { it.copy(count = (it.count - 1).coerceAtLeast(0)) }
  }

  override fun clearError() { _ui.update { it.copy(error = null) } }

  // (Exemple dâ€™effet asynchrone)
  fun fakeLoad() = viewModelScope.launch {
    _ui.update { it.copy(loading = true, error = null) }
    delay(500)
    _ui.update { it.copy(loading = false) }
  }
}
```

> `MutableStateFlow.update { â€¦ }` garantit une **seule Ã©criture atomique** de lâ€™Ã©tat.

---

## 4) Ã‰cran Compose : **observe** & **dÃ©clenche** les intents

```kotlin
@Composable
fun MainScreenVM(
  vm: MainViewModel = androidx.lifecycle.viewmodel.compose.viewModel()
) {
  val state by vm.ui.collectAsState() // ou collectAsStateWithLifecycle si ajoutÃ©

  MainScreenStateless(
    state = state,
    onNameChange = vm::onNameChange,
    onGreet = vm::onGreet,
    onInc = vm::onIncrement,
    onDec = vm::onDecrement,
    onDismissError = vm::clearError
  )
}

// UI "dumb" : rend en fonction du state et expose des callbacks
@Composable
fun MainScreenStateless(
  state: UiState,
  onNameChange: (String) -> Unit,
  onGreet: () -> Unit,
  onInc: () -> Unit,
  onDec: () -> Unit,
  onDismissError: () -> Unit,
  modifier: Modifier = Modifier
) {
  Column(
    modifier = modifier.fillMaxSize().padding(16.dp),
    verticalArrangement = Arrangement.spacedBy(16.dp)
  ) {
    OutlinedTextField(
      value = state.name,
      onValueChange = onNameChange,
      label = { Text("PrÃ©nom") },
      singleLine = true,
      modifier = Modifier.fillMaxWidth()
    )

    Button(
      onClick = onGreet,
      enabled = state.name.isNotBlank(),
      modifier = Modifier.fillMaxWidth()
    ) { Text("Dire bonjour") }

    state.greeting?.let {
      AssistChip(onClick = {}, label = { Text(it) })
    }

    Text("Compteur", style = MaterialTheme.typography.titleMedium)
    Row(verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(12.dp)) {
      IconButton(onClick = onDec, enabled = state.count > 0) { Icon(Icons.Default.Remove, null) }
      Text("${state.count}", style = MaterialTheme.typography.headlineSmall, modifier = Modifier.widthIn(min = 40.dp))
      IconButton(onClick = onInc) { Icon(Icons.Default.Add, null) }
    }

    if (state.loading) LinearProgressIndicator(Modifier.fillMaxWidth())

    state.error?.let { msg ->
      Snackbar(
        action = {
          TextButton(onClick = onDismissError) { Text("OK") }
        }
      ) { Text(msg) }
    }
  }
}
```

> Lâ€™UI **ne stocke pas** lâ€™Ã©tat global : elle **observe** `ui` et **appelle** des intents.

---

## 5) Variante **intents scellÃ©s** (facultatif)

```kotlin
sealed interface Action {
  data class NameChanged(val value: String) : Action
  data object Greet : Action
  data object Inc : Action
  data object Dec : Action
  data object ClearError : Action
}

class VM2 : ViewModel() {
  private val _ui = MutableStateFlow(UiState()); val ui: StateFlow<UiState> = _ui
  fun dispatch(a: Action) = _ui.update { s ->
    when (a) {
      is Action.NameChanged -> s.copy(name = a.value, error = null, greeting = s.greeting?.takeIf { a.value.isNotBlank() })
      Action.Greet -> s.name.trim().takeIf { it.isNotEmpty() }?.let { s.copy(greeting = "Bonjour, $it !") } ?: s.copy(error = "Le prÃ©nom est vide.")
      Action.Inc -> s.copy(count = s.count + 1)
      Action.Dec -> s.copy(count = (s.count - 1).coerceAtLeast(0))
      Action.ClearError -> s.copy(error = null)
    }
  }
}
```

> Utile si vous souhaitez un **rÃ©ducteur unique** et une **tracabilitÃ©** (log/analytics).

---

## 6) DÃ©pendances utiles (rappel)

```kts
dependencies {
  implementation("androidx.lifecycle:lifecycle-viewmodel-compose:<latest>")
  implementation("androidx.lifecycle:lifecycle-runtime-compose:<latest>") // pour collectAsStateWithLifecycle
  implementation("androidx.compose.material3:material3:<latest>")
}
```

---

## ðŸ§ª VÃ©rifications rapides

* [ ] Le **ViewModel** expose un **`StateFlow<UiState>`**.
* [ ] Lâ€™UI **observe** avec `collectAsState()` et **nâ€™Ã©dite pas** lâ€™Ã©tat directement.
* [ ] Les **intents** sont des **mÃ©thodes claires** (ou un `dispatch(Action)`).
* [ ] Les rÃ¨gles mÃ©tier (ex. `count â‰¥ 0`, bouton dÃ©sactivÃ© si nom vide) sont **dans le VM**.

---

## ðŸ©¹ DÃ©pannage

* **Ã‰tats incohÃ©rents** â†’ *single source of truth* : UI **stateless**, VM **unique dÃ©tenteur**.
* **Boucles de recomposition** â†’ Ã©vitez de recrÃ©er des objets lourds sans `remember` cÃ´tÃ© UI.
* **Erreur non effaÃ§able** â†’ ajoutez un intent `clearError()` et appelez-le depuis lâ€™UI.
* **Perte dâ€™Ã©tat Ã  la rotation** â†’ lâ€™Ã©tat est dans le **VM** â†’ vÃ©rifiez que vous crÃ©ez le **mÃªme** `ViewModel` (pas en Preview).

---

## ðŸ“¦ Livrables attendus

* `UiState` immuable (`data class`).
* `MainViewModel` avec **intents** (`onNameChange/onGreet/onIncrement/onDecrement/clearError`).
* `MainScreenStateless` + `MainScreenVM` qui **observe** et **dÃ©clenche** les intents.

---

## âœ… DoD â€” Definition of Done

* [ ] Flux **unidirectionnel** opÃ©rationnel (Intents â†’ VM â†’ UiState â†’ UI).
* [ ] `UiState` **immutables** ; mises Ã  jour via `copy`.
* [ ] UI **sans** logique mÃ©tier (stateless), VM **orchestrateur**.
* [ ] RÃ¨gles mÃ©tier & erreurs gÃ©rÃ©es cÃ´tÃ© VM ; UI affiche proprement.

---

## âš¡ Cheatsheet

```kotlin
// State
data class UiState(val count: Int = 0, val error: String? = null)

// VM
class VM: ViewModel() {
  private val _ui = MutableStateFlow(UiState())
  val ui: StateFlow<UiState> = _ui
  fun inc() = _ui.update { it.copy(count = it.count + 1) }
  fun dec() = _ui.update { it.copy(count = (it.count - 1).coerceAtLeast(0)) }
  fun clearError() = _ui.update { it.copy(error = null) }
}

// UI
val s by vm.ui.collectAsState()
Button(onClick = vm::inc) { Text("+") }
Text("${s.count}")
```
