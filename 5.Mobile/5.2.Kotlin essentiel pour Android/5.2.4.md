---
title: 4. Data class & copy
layout: home
nav_order: 4
parent: 5.2. Kotlin essentiel pour Android
permalink: /kotlin-essentiel/data-class-copy/
code: 5.2.4
competence: C5
autoformation: "C5.2"
ua: "5.2.U2"
duree_h: 1.5
objectif: "Modeliser un etat immuable avec data class, le mettre a jour via copy et utiliser la destructuration."
notions_nouvelles: ["data class", "copy", "equals/hashCode", "componentN (destructuration)", "Immutabilite"]
fil_rouge: "App Mobile Compose + API Blog Laravel"
livrable_chapitre: "UiState + fonctions onIncrement/onNameChanged basées sur copy + exemples de destructuration"
alimentation_prototype: "Etat d’ecran Compose immuable et facile a observer"
alimentation_miniprojet: "Socle MVVM leger (StateFlow/ViewModel) oriente etat"
---


# 📘 5.2.4 — `data class`, `copy`, déstructuration

## 📒 Glossaire minute
- **`data class`** : génère `equals/hashCode/toString`, `copy`, `componentN` (déstructuration).
- **Immutabilité** : préférer **`val`** dans le constructeur → états prévisibles.
- **`copy`** : crée une **nouvelle instance** en modifiant **quelques champs**.
- **Déstructuration** : extraire les propriétés via `val (a, b) = obj`.

---

## ✅ Objectif
Modéliser un **UI state** clair avec `data class`, le **mettre à jour immuablement** avec `copy`, et utiliser la **déstructuration** pour écrire un code lisible (notamment avec `Pair`, `Map.Entry`, `Triple`).

---

## 1) Créer une `data class` (UI state)

```kotlin
data class UiState(
  val name: String = "",
  val greeting: String? = null,
  val count: Int = 0,
  val loading: Boolean = false
)
````

**Bénéfices auto-générés**

* `equals/hashCode` **structurels** (pratique pour tests).
* `toString()` lisible pour logs.
* `copy(...)` et `componentN()`.

> 🔒 **Conseil** : mettez **`val`** par défaut. Passez un champ en `var` **uniquement** si vous avez une raison forte.

---

## 2) Mettre à jour l’état avec `copy` (immutabilité)

```kotlin
fun onIncrement(ui: UiState) = ui.copy(count = ui.count + 1)

fun onSetName(ui: UiState, raw: String): UiState {
  val cleaned = raw.trim()
  return ui.copy(
    name = cleaned,
    greeting = if (cleaned.isNotEmpty()) "Bonjour, $cleaned !" else null
  )
}

fun setLoading(ui: UiState, value: Boolean) = ui.copy(loading = value)
```

> `copy` est **peu coûteux** et sûr ; on évite les mutations surprises.

---

## 3) Déstructuration — `componentN`

### Sur vos `data class`

```kotlin
val ui = UiState(name = "Ada", count = 2)
val (name, greeting, count, loading) = ui
println("$name • $count • loading=$loading")
```

### Sur `Pair` / `Triple`

```kotlin
val (w, h) = 360 to 640
val (x, y, z) = Triple(1, 2, 3)
```

### Sur entrées de Map

```kotlin
val map = mapOf("kotlin" to 1, "compose" to 2)
for ((key, value) in map) println("$key → $value")
```

> Ignorer une valeur : `val (needed, _) = pair`.

---

## 4) Niveaux imbriqués (copie en profondeur *manuelle*)

```kotlin
data class Profile(val name: String = "", val age: Int = 0)
data class Ui(val profile: Profile = Profile(), val tags: List<String> = emptyList())

// Mettre à jour un champ imbriqué
fun rename(ui: Ui, newName: String) =
  ui.copy(profile = ui.profile.copy(name = newName))

// Ajouter un tag (liste immuable → créer une nouvelle liste)
fun addTag(ui: Ui, t: String) =
  ui.copy(tags = ui.tags + t)
```

> ⚠️ `copy` est un **copier-coller superficiel** (shallow copy). Si un champ contient une **collection mutable**, changer la collection affectera **toutes** les références. Utilisez **listes immuables** (`List`) ou créez une nouvelle instance (`+`, `.toList()`).

---

## 5) Utilisation en ViewModel (schéma léger)

```kotlin
class MainViewModel : ViewModel() {
  private val _ui = MutableStateFlow(UiState())
  val ui: StateFlow<UiState> = _ui

  fun onIncrement() = _ui.update { it.copy(count = it.count + 1) }
  fun onDecrement() = _ui.update { it.copy(count = (it.count - 1).coerceAtLeast(0)) }
  fun onNameChanged(raw: String) = _ui.update { onSetName(it, raw) }
}
```

> Avec Compose, l’UI **observe** `ui` et se **recompose** quand l’instance change.

---

## 6) Égalité structurelle & collections

```kotlin
val a = UiState(name = "Ada", count = 1)
val b = UiState(name = "Ada", count = 1)
check(a == b)                // true : même contenu

val set = setOf(a, b)        // taille 1 : hashCode structurel
```

---

## 7) Exemples utiles (compact)

```kotlin
// Normaliser un nom et augmenter un compteur si non vide
fun greetAndInc(ui: UiState, raw: String) =
  ui.copy(
    name = raw.trim(),
    greeting = raw.trim().takeIf { it.isNotEmpty() }?.let { "Bonjour, $it !" },
    count = ui.count + 1
  )

// Mapper une liste de DTO → data class domaine
data class TodoDto(val id: Long?, val title: String?)
data class Todo(val id: Long, val title: String)

fun TodoDto.toDomain() = Todo(
  id = id ?: 0L,
  title = title?.trim().takeUnless { it.isNullOrEmpty() } ?: "(sans titre)"
)
```

---

## 🧪 Vérifications rapides

* [ ] Vous modélisez l’état avec **`data class`** (valeurs par défaut utiles).
* [ ] Vous mettez à jour avec **`copy`** (pas de mutation directe).
* [ ] Vous savez **déstructurer** vos objets, `Pair`, `Map.Entry`.
* [ ] Vous gérez correctement les **niveaux imbriqués** (copy en profondeur manuelle si besoin).

---

## 🩹 Erreurs fréquentes & correctifs

* ❌ Champs en `var` sans raison → ✅ **`val` par défaut**.
* ❌ Modifier la **même** liste mutable dans plusieurs états → ✅ créer une **nouvelle liste** (`+`, `toList()`).
* ❌ Oublier les **valeurs par défaut** → ✅ facilite la construction de l’état initial.
* ❌ Comparer par référence (`===`) au lieu de valeur → ✅ `==` (data class).

---

## 📦 Livrables attendus

* `UiState` (data class) avec valeurs par défaut.
* Fonctions `onIncrement/onDecrement/onNameChanged` basées sur **`copy`**.
* Un exemple de **déstructuration** (`Pair`, `Map`) dans un petit utilitaire/log.

---

## ✅ DoD — Definition of Done

* [ ] État **immutables** via `data class` + `val`.
* [ ] Mises à jour **pures** avec `copy` (incluant un champ imbriqué).
* [ ] Déstructuration utilisée à bon escient (lisibilité, pas d’abus).
* [ ] Petits tests vérifiant `equals/hashCode` structurels.

---

## ⚡ Cheatsheet

```kotlin
data class UiState(val name: String = "", val count: Int = 0, val greeting: String? = null)

val next = state.copy(count = state.count + 1)

val (name, count, greeting) = next

// Copie imbriquée
state.copy(profile = state.profile.copy(name = "Ada"))

// Déstructuration Map
for ((k, v) in map) println("$k → $v")
```
