---
title: 4. Data class & copy
layout: home
nav_order: 4
parent: 5.2. Kotlin essentiel pour Android
permalink: /kotlin-essentiel/data-class-copy/
code: 5.2.4
competence: C5
autoformation: "C5.2"
ua: "5.2.U2"
duree_h: 1.5
objectif: "Modeliser un etat immuable avec data class, le mettre a jour via copy et utiliser la destructuration."
notions_nouvelles: ["data class", "copy", "equals/hashCode", "componentN (destructuration)", "Immutabilite"]
fil_rouge: "App Mobile Compose + API Blog Laravel"
livrable_chapitre: "UiState + fonctions onIncrement/onNameChanged basÃ©es sur copy + exemples de destructuration"
alimentation_prototype: "Etat dâ€™ecran Compose immuable et facile a observer"
alimentation_miniprojet: "Socle MVVM leger (StateFlow/ViewModel) oriente etat"
---


# ğŸ“˜ 5.2.4 â€” `data class`, `copy`, dÃ©structuration

## ğŸ“’ Glossaire minute
- **`data class`** : gÃ©nÃ¨re `equals/hashCode/toString`, `copy`, `componentN` (dÃ©structuration).
- **ImmutabilitÃ©** : prÃ©fÃ©rer **`val`** dans le constructeur â†’ Ã©tats prÃ©visibles.
- **`copy`** : crÃ©e une **nouvelle instance** en modifiant **quelques champs**.
- **DÃ©structuration** : extraire les propriÃ©tÃ©s via `val (a, b) = obj`.

---

## âœ… Objectif
ModÃ©liser un **UI state** clair avec `data class`, le **mettre Ã  jour immuablement** avec `copy`, et utiliser la **dÃ©structuration** pour Ã©crire un code lisible (notamment avec `Pair`, `Map.Entry`, `Triple`).

---

## 1) CrÃ©er une `data class` (UI state)

```kotlin
data class UiState(
  val name: String = "",
  val greeting: String? = null,
  val count: Int = 0,
  val loading: Boolean = false
)
````

**BÃ©nÃ©fices auto-gÃ©nÃ©rÃ©s**

* `equals/hashCode` **structurels** (pratique pour tests).
* `toString()` lisible pour logs.
* `copy(...)` et `componentN()`.

> ğŸ”’ **Conseil** : mettez **`val`** par dÃ©faut. Passez un champ en `var` **uniquement** si vous avez une raison forte.

---

## 2) Mettre Ã  jour lâ€™Ã©tat avec `copy` (immutabilitÃ©)

```kotlin
fun onIncrement(ui: UiState) = ui.copy(count = ui.count + 1)

fun onSetName(ui: UiState, raw: String): UiState {
  val cleaned = raw.trim()
  return ui.copy(
    name = cleaned,
    greeting = if (cleaned.isNotEmpty()) "Bonjour, $cleaned !" else null
  )
}

fun setLoading(ui: UiState, value: Boolean) = ui.copy(loading = value)
```

> `copy` est **peu coÃ»teux** et sÃ»r ; on Ã©vite les mutations surprises.

---

## 3) DÃ©structuration â€” `componentN`

### Sur vos `data class`

```kotlin
val ui = UiState(name = "Ada", count = 2)
val (name, greeting, count, loading) = ui
println("$name â€¢ $count â€¢ loading=$loading")
```

### Sur `Pair` / `Triple`

```kotlin
val (w, h) = 360 to 640
val (x, y, z) = Triple(1, 2, 3)
```

### Sur entrÃ©es de Map

```kotlin
val map = mapOf("kotlin" to 1, "compose" to 2)
for ((key, value) in map) println("$key â†’ $value")
```

> Ignorer une valeur : `val (needed, _) = pair`.

---

## 4) Niveaux imbriquÃ©s (copie en profondeur *manuelle*)

```kotlin
data class Profile(val name: String = "", val age: Int = 0)
data class Ui(val profile: Profile = Profile(), val tags: List<String> = emptyList())

// Mettre Ã  jour un champ imbriquÃ©
fun rename(ui: Ui, newName: String) =
  ui.copy(profile = ui.profile.copy(name = newName))

// Ajouter un tag (liste immuable â†’ crÃ©er une nouvelle liste)
fun addTag(ui: Ui, t: String) =
  ui.copy(tags = ui.tags + t)
```

> âš ï¸ `copy` est un **copier-coller superficiel** (shallow copy). Si un champ contient une **collection mutable**, changer la collection affectera **toutes** les rÃ©fÃ©rences. Utilisez **listes immuables** (`List`) ou crÃ©ez une nouvelle instance (`+`, `.toList()`).

---

## 5) Utilisation en ViewModel (schÃ©ma lÃ©ger)

```kotlin
class MainViewModel : ViewModel() {
  private val _ui = MutableStateFlow(UiState())
  val ui: StateFlow<UiState> = _ui

  fun onIncrement() = _ui.update { it.copy(count = it.count + 1) }
  fun onDecrement() = _ui.update { it.copy(count = (it.count - 1).coerceAtLeast(0)) }
  fun onNameChanged(raw: String) = _ui.update { onSetName(it, raw) }
}
```

> Avec Compose, lâ€™UI **observe** `ui` et se **recompose** quand lâ€™instance change.

---

## 6) Ã‰galitÃ© structurelle & collections

```kotlin
val a = UiState(name = "Ada", count = 1)
val b = UiState(name = "Ada", count = 1)
check(a == b)                // true : mÃªme contenu

val set = setOf(a, b)        // taille 1 : hashCode structurel
```

---

## 7) Exemples utiles (compact)

```kotlin
// Normaliser un nom et augmenter un compteur si non vide
fun greetAndInc(ui: UiState, raw: String) =
  ui.copy(
    name = raw.trim(),
    greeting = raw.trim().takeIf { it.isNotEmpty() }?.let { "Bonjour, $it !" },
    count = ui.count + 1
  )

// Mapper une liste de DTO â†’ data class domaine
data class TodoDto(val id: Long?, val title: String?)
data class Todo(val id: Long, val title: String)

fun TodoDto.toDomain() = Todo(
  id = id ?: 0L,
  title = title?.trim().takeUnless { it.isNullOrEmpty() } ?: "(sans titre)"
)
```

---

## ğŸ§ª VÃ©rifications rapides

* [ ] Vous modÃ©lisez lâ€™Ã©tat avec **`data class`** (valeurs par dÃ©faut utiles).
* [ ] Vous mettez Ã  jour avec **`copy`** (pas de mutation directe).
* [ ] Vous savez **dÃ©structurer** vos objets, `Pair`, `Map.Entry`.
* [ ] Vous gÃ©rez correctement les **niveaux imbriquÃ©s** (copy en profondeur manuelle si besoin).

---

## ğŸ©¹ Erreurs frÃ©quentes & correctifs

* âŒ Champs en `var` sans raison â†’ âœ… **`val` par dÃ©faut**.
* âŒ Modifier la **mÃªme** liste mutable dans plusieurs Ã©tats â†’ âœ… crÃ©er une **nouvelle liste** (`+`, `toList()`).
* âŒ Oublier les **valeurs par dÃ©faut** â†’ âœ… facilite la construction de lâ€™Ã©tat initial.
* âŒ Comparer par rÃ©fÃ©rence (`===`) au lieu de valeur â†’ âœ… `==` (data class).

---

## ğŸ“¦ Livrables attendus

* `UiState` (data class) avec valeurs par dÃ©faut.
* Fonctions `onIncrement/onDecrement/onNameChanged` basÃ©es sur **`copy`**.
* Un exemple de **dÃ©structuration** (`Pair`, `Map`) dans un petit utilitaire/log.

---

## âœ… DoD â€” Definition of Done

* [ ] Ã‰tat **immutables** via `data class` + `val`.
* [ ] Mises Ã  jour **pures** avec `copy` (incluant un champ imbriquÃ©).
* [ ] DÃ©structuration utilisÃ©e Ã  bon escient (lisibilitÃ©, pas dâ€™abus).
* [ ] Petits tests vÃ©rifiant `equals/hashCode` structurels.

---

## âš¡ Cheatsheet

```kotlin
data class UiState(val name: String = "", val count: Int = 0, val greeting: String? = null)

val next = state.copy(count = state.count + 1)

val (name, count, greeting) = next

// Copie imbriquÃ©e
state.copy(profile = state.profile.copy(name = "Ada"))

// DÃ©structuration Map
for ((k, v) in map) println("$k â†’ $v")
```
