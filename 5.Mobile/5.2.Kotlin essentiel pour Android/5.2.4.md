---
title: 4. Data class & copy
layout: home
nav_order: 4
parent: 5.2. Kotlin essentiel pour Android
permalink: /kotlin-essentiel/data-class-copy/
code: 5.2.4
competence: C5
autoformation: "C5.2"
ua: "5.2.U2"
duree_h: 1.5
objectif: "Modeliser un etat immuable avec data class, le mettre a jour via copy et utiliser la destructuration."
notions_nouvelles: ["data class", "copy", "equals/hashCode", "componentN (destructuration)", "Immutabilite"]
fil_rouge: "App Mobile Compose + API Blog Laravel"
livrable_chapitre: "UiState + fonctions onIncrement/onNameChanged basées sur copy + exemples de destructuration"
alimentation_prototype: "Etat d’ecran Compose immuable et facile a observer"
alimentation_miniprojet: "Socle MVVM leger (StateFlow/ViewModel) oriente etat"
---


# 📘 5.2.4 — Classe normale vs `data class`

## 📒 Glossaire minute

* **Classe normale (`class`)** : ne génère rien d’automatique. Par défaut, `==` compare **les références** (même objet en mémoire).
* **`data class`** : génère automatiquement `equals`/`hashCode` **structurels**, `toString`, `copy` et `componentN` (déstructuration).
* **`copy`** : crée une **nouvelle instance** en changeant certaines propriétés.
* **Déstructuration** : `val (a, b) = objet` grâce à `component1()`, `component2()`, etc.

> 🎯 But : savoir **écrire les deux** (classique vs data), **observer les différences** et **choisir en connaissance de cause**.

---

## 🛠 Tutoriel pas-à-pas (chaque étape a son `main` prêt à exécuter)

### Étape 1 — Classe normale : comportement par défaut

**Explication.**
Une classe Kotlin “classique” ne génère rien :

* `==` compare la **référence** (équivalent de `===` si `equals` n’est pas redéfini).
* `toString()` n’est pas lisible (nom + hash).
* Pas de `copy`, pas de déstructuration automatique.

```kotlin
// Main.kt — Étape 1
class PersonClassic(val name: String, val age: Int)

fun main() {
    val p1 = PersonClassic("Ada", 36)
    val p2 = PersonClassic("Ada", 36)

    println("p1 == p2 ? ${p1 == p2}")       // false (références différentes)
    println("toString(): $p1")              // PersonClassic@1a2b3c (peu lisible)
}
```

---

### Étape 2 — Data class : égalité structurelle, toString lisible

**Explication.**
Avec `data class`, `==` compare le **contenu** (propriétés du constructeur primaire).
`toString()` est lisible et utile pour les logs.

```kotlin
// Main.kt — Étape 2
data class PersonData(val name: String, val age: Int)

fun main() {
    val p1 = PersonData("Ada", 36)
    val p2 = PersonData("Ada", 36)

    println("p1 == p2 ? ${p1 == p2}")       // true (même contenu)
    println("toString(): $p1")              // PersonData(name=Ada, age=36)
}
```

---

### Étape 3 — `copy` et déstructuration (seulement avec data class)

**Explication.**

* `copy` crée un **nouvel objet** en changeant certains champs.
* La **déstructuration** marche grâce aux `componentN` générés.

```kotlin
// Main.kt — Étape 3
data class PersonData(val name: String, val age: Int)

fun main() {
    val p1 = PersonData("Ada", 36)

    val p2 = p1.copy(age = 37)              // nouvelle instance
    println("p1: $p1")
    println("p2: $p2")

    val (n, a) = p2                         // déstructuration
    println("name=$n, age=$a")
}
```

---

### Étape 4 — Comment “imiter” une data class… à la main (classe normale)

**Explication.**
Pour obtenir un comportement similaire avec une classe normale, tu dois **écrire toi-même** `equals`, `hashCode`, `toString`, et une fonction de copie. C’est **verbeux** et source d’erreurs → d’où l’intérêt des `data class`.

```kotlin
// Main.kt — Étape 4
class PersonClassic(val name: String, val age: Int) {
    // Copie manuelle
    fun copy(name: String = this.name, age: Int = this.age) = PersonClassic(name, age)

    // toString lisible
    override fun toString(): String = "PersonClassic(name=$name, age=$age)"

    // Égalité structurelle
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is PersonClassic) return false
        return name == other.name && age == other.age
    }

    // Cohérent avec equals
    override fun hashCode(): Int = 31 * name.hashCode() + age
}

fun main() {
    val p1 = PersonClassic("Ada", 36)
    val p2 = PersonClassic("Ada", 36)
    val p3 = p1.copy(age = 37)

    println("p1 == p2 ? ${p1 == p2}")       // true (car equals redéfini)
    println("p1: $p1")
    println("p3: $p3")
}
```

> 🔎 Conclusion : `data class` t’épargne ce **boilerplate** (et les oublis).

---

### Étape 5 — Effet dans les collections (Set/Map)

**Explication.**
Les **Set/Map** s’appuient sur `equals/hashCode`.

* Classe normale **sans** overrides → deux objets “égaux visuellement” sont **différents** pour le Set.
* `data class` → une seule entrée (égalité structurelle).

```kotlin
// Main.kt — Étape 5
class PersonClassic(val name: String, val age: Int) // sans overrides
data class PersonData(val name: String, val age: Int)

fun main() {
    val s1 = setOf(
        PersonClassic("Ada", 36),
        PersonClassic("Ada", 36)
    )
    println("Set (classique, sans overrides) taille = ${s1.size}") // 2

    val s2 = setOf(
        PersonData("Ada", 36),
        PersonData("Ada", 36)
    )
    println("Set (data class) taille = ${s2.size}")                 // 1
}
```

---

### Étape 6 — Rappels & règles des `data class`

**Explication.**

* Doit avoir **au moins une** propriété dans le **constructeur primaire** marquée `val`/`var`.
* `equals/hashCode`/`copy`/`componentN` sont **basés sur ces propriétés du constructeur primaire**.
* Ne peut pas être `abstract`, `open`, `sealed`, `inner`.
* Tu peux ajouter des propriétés secondaires (hors constructeur), **elles ne participent pas** à l’égalité/hash.
* Immutabilité recommandée : privilégier `val` (et collections non mutables) ; utilise `copy` pour créer un nouvel objet.

> 📝 Astuce : si tu veux **inclure/exclure** un champ de l’égalité, place-le (ou non) dans le **constructeur primaire**.

---

## 🧪 Vérifications rapides

* [ ] Tu as une **classe normale** et tu observes `==` (référence) + `toString` peu lisible.
* [ ] Tu as une **data class** et tu observes `==` (structurel), `toString` lisible, `copy`, **déstructuration**.
* [ ] Tu as testé l’effet sur **Set/Map**.
* [ ] Tu sais **quand** préférer `data class` (objets de données/valeur) vs **classe classique** (comportements spécifiques, héritage, etc.).

---

## 🩹 Erreurs fréquentes & correctifs

* ❌ Oublier `val/var` dans le **constructeur primaire** d’une `data class`.
  → ✅ Obligatoire pour générer les fonctions.
* ❌ Penser que `==` compare le contenu pour **toutes** les classes.
  → ✅ **Seulement** si `equals` est redéfini (automatique en `data class`).
* ❌ Mettre des champs **importants hors** constructeur primaire dans une `data class`.
  → ✅ Ils ne seront pas pris en compte par `equals/hashCode`.
* ❌ Utiliser des **collections mutables** et les partager.
  → ✅ Préfère `List`/`Map` immuables et recrée une nouvelle instance si besoin.

---

## 📦 Livrable attendu

Un repo (ou dossier) contenant :

1. `PersonClassic.kt` (classe normale) **avec démonstration** : `equals/hashCode` par défaut **puis** version avec overrides **+** une fonction `copy` manuelle.
2. `PersonData.kt` (`data class`) **avec démonstration** : `copy`, déstructuration et usage dans `Set/Map`.
3. Un ou plusieurs fichiers `Main.kt` (un `main` par étape) montrant les **sorties attendues** (commentaires).

---

## ✅ Definition of Done (DoD)

* [ ] L’apprenant sait **créer** une **classe normale** et une **`data class`**.
* [ ] Il/elle **explique** la différence d’égalité (`==` référence vs structurelle).
* [ ] Il/elle **démontre** `toString`, `copy`, déstructuration, Set/Map.
* [ ] Le code **s’exécute** et montre les **différences** (captures/logs fournis).

---

## ⚡ Cheatsheet

```kotlin
// Classe normale : par défaut, == compare la RÉFÉRENCE
class P(val name: String, val age: Int)

// Data class : == compare le CONTENU, et génère toString/copy/componentN
data class D(val name: String, val age: Int)

val d1 = D("Ada", 36)
val d2 = d1.copy(age = 37)
val (n, a) = d2
println("$n • $a")
```

