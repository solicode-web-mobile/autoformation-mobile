---
title: 4. Data class & copy
layout: home
nav_order: 4
parent: 5.2. Kotlin essentiel pour Android
permalink: /kotlin-essentiel/data-class-copy/
code: 5.2.4
competence: C5
autoformation: "C5.2"
ua: "5.2.U2"
duree_h: 1.5
objectif: "Modeliser un etat immuable avec data class, le mettre a jour via copy et utiliser la destructuration."
notions_nouvelles: ["data class", "copy", "equals/hashCode", "componentN (destructuration)", "Immutabilite"]
fil_rouge: "App Mobile Compose + API Blog Laravel"
livrable_chapitre: "UiState + fonctions onIncrement/onNameChanged basÃ©es sur copy + exemples de destructuration"
alimentation_prototype: "Etat dâ€™ecran Compose immuable et facile a observer"
alimentation_miniprojet: "Socle MVVM leger (StateFlow/ViewModel) oriente etat"
---


# ğŸ“˜ 5.2.4 â€” Classe normale vs `data class`

## ğŸ“’ Glossaire minute

* **Classe normale (`class`)** : ne gÃ©nÃ¨re rien dâ€™automatique. Par dÃ©faut, `==` compare **les rÃ©fÃ©rences** (mÃªme objet en mÃ©moire).
* **`data class`** : gÃ©nÃ¨re automatiquement `equals`/`hashCode` **structurels**, `toString`, `copy` et `componentN` (dÃ©structuration).
* **`copy`** : crÃ©e une **nouvelle instance** en changeant certaines propriÃ©tÃ©s.
* **DÃ©structuration** : `val (a, b) = objet` grÃ¢ce Ã  `component1()`, `component2()`, etc.

> ğŸ¯ But : savoir **Ã©crire les deux** (classique vs data), **observer les diffÃ©rences** et **choisir en connaissance de cause**.

---

## ğŸ›  Tutoriel pas-Ã -pas (chaque Ã©tape a son `main` prÃªt Ã  exÃ©cuter)

### Ã‰tape 1 â€” Classe normale : comportement par dÃ©faut

**Explication.**
Une classe Kotlin â€œclassiqueâ€ ne gÃ©nÃ¨re rien :

* `==` compare la **rÃ©fÃ©rence** (Ã©quivalent de `===` si `equals` nâ€™est pas redÃ©fini).
* `toString()` nâ€™est pas lisible (nom + hash).
* Pas de `copy`, pas de dÃ©structuration automatique.

```kotlin
// Main.kt â€” Ã‰tape 1
class PersonClassic(val name: String, val age: Int)

fun main() {
    val p1 = PersonClassic("Ada", 36)
    val p2 = PersonClassic("Ada", 36)

    println("p1 == p2 ? ${p1 == p2}")       // false (rÃ©fÃ©rences diffÃ©rentes)
    println("toString(): $p1")              // PersonClassic@1a2b3c (peu lisible)
}
```

---

### Ã‰tape 2 â€” Data class : Ã©galitÃ© structurelle, toString lisible

**Explication.**
Avec `data class`, `==` compare le **contenu** (propriÃ©tÃ©s du constructeur primaire).
`toString()` est lisible et utile pour les logs.

```kotlin
// Main.kt â€” Ã‰tape 2
data class PersonData(val name: String, val age: Int)

fun main() {
    val p1 = PersonData("Ada", 36)
    val p2 = PersonData("Ada", 36)

    println("p1 == p2 ? ${p1 == p2}")       // true (mÃªme contenu)
    println("toString(): $p1")              // PersonData(name=Ada, age=36)
}
```

---

### Ã‰tape 3 â€” `copy` et dÃ©structuration (seulement avec data class)

**Explication.**

* `copy` crÃ©e un **nouvel objet** en changeant certains champs.
* La **dÃ©structuration** marche grÃ¢ce aux `componentN` gÃ©nÃ©rÃ©s.

```kotlin
// Main.kt â€” Ã‰tape 3
data class PersonData(val name: String, val age: Int)

fun main() {
    val p1 = PersonData("Ada", 36)

    val p2 = p1.copy(age = 37)              // nouvelle instance
    println("p1: $p1")
    println("p2: $p2")

    val (n, a) = p2                         // dÃ©structuration
    println("name=$n, age=$a")
}
```

---

### Ã‰tape 4 â€” Comment â€œimiterâ€ une data classâ€¦ Ã  la main (classe normale)

**Explication.**
Pour obtenir un comportement similaire avec une classe normale, tu dois **Ã©crire toi-mÃªme** `equals`, `hashCode`, `toString`, et une fonction de copie. Câ€™est **verbeux** et source dâ€™erreurs â†’ dâ€™oÃ¹ lâ€™intÃ©rÃªt des `data class`.

```kotlin
// Main.kt â€” Ã‰tape 4
class PersonClassic(val name: String, val age: Int) {
    // Copie manuelle
    fun copy(name: String = this.name, age: Int = this.age) = PersonClassic(name, age)

    // toString lisible
    override fun toString(): String = "PersonClassic(name=$name, age=$age)"

    // Ã‰galitÃ© structurelle
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is PersonClassic) return false
        return name == other.name && age == other.age
    }

    // CohÃ©rent avec equals
    override fun hashCode(): Int = 31 * name.hashCode() + age
}

fun main() {
    val p1 = PersonClassic("Ada", 36)
    val p2 = PersonClassic("Ada", 36)
    val p3 = p1.copy(age = 37)

    println("p1 == p2 ? ${p1 == p2}")       // true (car equals redÃ©fini)
    println("p1: $p1")
    println("p3: $p3")
}
```

> ğŸ” Conclusion : `data class` tâ€™Ã©pargne ce **boilerplate** (et les oublis).

---

### Ã‰tape 5 â€” Effet dans les collections (Set/Map)

**Explication.**
Les **Set/Map** sâ€™appuient sur `equals/hashCode`.

* Classe normale **sans** overrides â†’ deux objets â€œÃ©gaux visuellementâ€ sont **diffÃ©rents** pour le Set.
* `data class` â†’ une seule entrÃ©e (Ã©galitÃ© structurelle).

```kotlin
// Main.kt â€” Ã‰tape 5
class PersonClassic(val name: String, val age: Int) // sans overrides
data class PersonData(val name: String, val age: Int)

fun main() {
    val s1 = setOf(
        PersonClassic("Ada", 36),
        PersonClassic("Ada", 36)
    )
    println("Set (classique, sans overrides) taille = ${s1.size}") // 2

    val s2 = setOf(
        PersonData("Ada", 36),
        PersonData("Ada", 36)
    )
    println("Set (data class) taille = ${s2.size}")                 // 1
}
```

---

### Ã‰tape 6 â€” Rappels & rÃ¨gles des `data class`

**Explication.**

* Doit avoir **au moins une** propriÃ©tÃ© dans le **constructeur primaire** marquÃ©e `val`/`var`.
* `equals/hashCode`/`copy`/`componentN` sont **basÃ©s sur ces propriÃ©tÃ©s du constructeur primaire**.
* Ne peut pas Ãªtre `abstract`, `open`, `sealed`, `inner`.
* Tu peux ajouter des propriÃ©tÃ©s secondaires (hors constructeur), **elles ne participent pas** Ã  lâ€™Ã©galitÃ©/hash.
* ImmutabilitÃ© recommandÃ©e : privilÃ©gier `val` (et collections non mutables) ; utilise `copy` pour crÃ©er un nouvel objet.

> ğŸ“ Astuce : si tu veux **inclure/exclure** un champ de lâ€™Ã©galitÃ©, place-le (ou non) dans le **constructeur primaire**.

---

## ğŸ§ª VÃ©rifications rapides

* [ ] Tu as une **classe normale** et tu observes `==` (rÃ©fÃ©rence) + `toString` peu lisible.
* [ ] Tu as une **data class** et tu observes `==` (structurel), `toString` lisible, `copy`, **dÃ©structuration**.
* [ ] Tu as testÃ© lâ€™effet sur **Set/Map**.
* [ ] Tu sais **quand** prÃ©fÃ©rer `data class` (objets de donnÃ©es/valeur) vs **classe classique** (comportements spÃ©cifiques, hÃ©ritage, etc.).

---

## ğŸ©¹ Erreurs frÃ©quentes & correctifs

* âŒ Oublier `val/var` dans le **constructeur primaire** dâ€™une `data class`.
  â†’ âœ… Obligatoire pour gÃ©nÃ©rer les fonctions.
* âŒ Penser que `==` compare le contenu pour **toutes** les classes.
  â†’ âœ… **Seulement** si `equals` est redÃ©fini (automatique en `data class`).
* âŒ Mettre des champs **importants hors** constructeur primaire dans une `data class`.
  â†’ âœ… Ils ne seront pas pris en compte par `equals/hashCode`.
* âŒ Utiliser des **collections mutables** et les partager.
  â†’ âœ… PrÃ©fÃ¨re `List`/`Map` immuables et recrÃ©e une nouvelle instance si besoin.

---

## ğŸ“¦ Livrable attendu

Un repo (ou dossier) contenant :

1. `PersonClassic.kt` (classe normale) **avec dÃ©monstration** : `equals/hashCode` par dÃ©faut **puis** version avec overrides **+** une fonction `copy` manuelle.
2. `PersonData.kt` (`data class`) **avec dÃ©monstration** : `copy`, dÃ©structuration et usage dans `Set/Map`.
3. Un ou plusieurs fichiers `Main.kt` (un `main` par Ã©tape) montrant les **sorties attendues** (commentaires).

---

## âœ… Definition of Done (DoD)

* [ ] Lâ€™apprenant sait **crÃ©er** une **classe normale** et une **`data class`**.
* [ ] Il/elle **explique** la diffÃ©rence dâ€™Ã©galitÃ© (`==` rÃ©fÃ©rence vs structurelle).
* [ ] Il/elle **dÃ©montre** `toString`, `copy`, dÃ©structuration, Set/Map.
* [ ] Le code **sâ€™exÃ©cute** et montre les **diffÃ©rences** (captures/logs fournis).

---

## âš¡ Cheatsheet

```kotlin
// Classe normale : par dÃ©faut, == compare la RÃ‰FÃ‰RENCE
class P(val name: String, val age: Int)

// Data class : == compare le CONTENU, et gÃ©nÃ¨re toString/copy/componentN
data class D(val name: String, val age: Int)

val d1 = D("Ada", 36)
val d2 = d1.copy(age = 37)
val (n, a) = d2
println("$n â€¢ $a")
```

