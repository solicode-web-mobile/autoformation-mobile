---
title: 6. Bonnes pratiques
layout: home
nav_order: 6
parent: 5.2. Kotlin essentiel pour Android
permalink: /kotlin-essentiel/bonnes-pratiques/
code: 5.2.6
competence: C5
autoformation: "C5.2"
ua: "5.2.U3"
duree_h: 1.5
objectif: "Produire un code Android/Compose simple, testable et maintenable (immutabilite, fonctions pures, Keep It Simple, Stupid)."
notions_nouvelles: ["Immutabilite", "Fonction pure", "Keep It Simple, Stupid", "Reducer UiState", "StateFlow/ViewModel (aperÃ§u)"]
fil_rouge: "App Mobile Compose + API Blog Laravel"
livrable_chapitre: "UiState + reducers (startLoading/setItems/setError), utilitaires parseCount/greet avec tests, mini-exemple Compose"
alimentation_prototype: "Qualite de code et testabilite du prototype"
alimentation_miniprojet: "Base maintenable et evolutive pour lâ€™application"
---


# ğŸ“˜ 5.2.6 - Bonnes pratiques

## ğŸ“’ Rappels essentiels
- **LisibilitÃ© avant tout** : le code doit Ãªtre facile Ã  lire et comprendre.  
- **Noms clairs** : variables, fonctions et classes dÃ©crivent leur rÃ´le.  
- **ResponsabilitÃ© unique** : une fonction ou une classe = une seule tÃ¢che.  
- **POO** : utiliser des classes pour modÃ©liser des objets du monde rÃ©el.  
- **ImmutabilitÃ©** : privilÃ©gier `val` et `data class` pour Ã©viter les erreurs.  

---

## Ã‰tape 1 â€” Bien nommer son code

```kotlin
// âŒ Mauvais
fun d(x: Int): Int = x * 2

// âœ… Bon
fun double(value: Int): Int = value * 2
````

> Un nom clair vaut mieux quâ€™un commentaire.

---

## Ã‰tape 2 â€” Une fonction = une responsabilitÃ©

```kotlin
// âŒ Mauvais : trop de choses Ã  la fois
fun processUser(name: String, age: Int) {
    println("Bonjour $name")
    if (age >= 18) println("Majeur") else println("Mineur")
}

// âœ… Bon : chaque fonction fait une seule chose
fun greet(name: String) = println("Bonjour, $name")

fun checkAge(age: Int) =
    if (age >= 18) "Majeur" else "Mineur"

fun main() {
    greet("Sara")
    println(checkAge(20))
}
```

---

## Ã‰tape 3 â€” Utiliser des classes pour modÃ©liser

```kotlin
class Person(val name: String, val age: Int) {
    fun isAdult() = age >= 18
}

fun main() {
    val p = Person("Ali", 20)
    println("${p.name} est adulte ? ${p.isAdult()}")
}
```

> Une classe reprÃ©sente un concept prÃ©cis (`Person`, `Article`, `Todo`).

---

## Ã‰tape 4 â€” PrÃ©fÃ©rer `val` et lâ€™immuabilitÃ©

```kotlin
data class Counter(val count: Int = 0) {
    fun increment() = copy(count = count + 1)
}

fun main() {
    val c1 = Counter()
    val c2 = c1.increment()
    println(c1) // Counter(count=0)
    println(c2) // Counter(count=1)
}
```

> Avec `val` et `copy`, on Ã©vite les effets de bord imprÃ©visibles.

---

## Ã‰tape 5 â€” RÃ©sumÃ© du principe de responsabilitÃ© unique

* Une **fonction** = une seule action.
* Une **classe** = un seul rÃ´le (modÃ©liser un concept).
* Si une fonction/classe commence Ã  faire trop de choses â†’ il faut **sÃ©parer**.

---

## ğŸ§ª VÃ©rifications rapides

* [ ] Mes variables/fonctions ont des **noms explicites**.
* [ ] Chaque fonction fait **une seule chose**.
* [ ] Mes classes reprÃ©sentent des concepts clairs.
* [ ] Jâ€™utilise `val` par dÃ©faut et `copy` pour mettre Ã  jour.

---

## ğŸ“¦ Livrables attendus

* Une classe `Person` avec fonction `isAdult()`.
* Deux fonctions simples (`greet`, `checkAge`).
* Une `data class Counter` avec fonction `increment()`.

---

 