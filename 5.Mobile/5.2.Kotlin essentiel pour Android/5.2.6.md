---
title: 6. Bonnes pratiques
layout: home
nav_order: 6
parent: 5.2. Kotlin essentiel pour Android
permalink: /kotlin-essentiel/bonnes-pratiques/
code: 5.2.6
competence: C5
autoformation: "C5.2"
ua: "5.2.U3"
duree_h: 1.5
objectif: "Produire un code Android/Compose simple, testable et maintenable (immutabilite, fonctions pures, Keep It Simple, Stupid)."
notions_nouvelles: ["Immutabilite", "Fonction pure", "Keep It Simple, Stupid", "Reducer UiState", "StateFlow/ViewModel (aperçu)"]
fil_rouge: "App Mobile Compose + API Blog Laravel"
livrable_chapitre: "UiState + reducers (startLoading/setItems/setError), utilitaires parseCount/greet avec tests, mini-exemple Compose"
alimentation_prototype: "Qualite de code et testabilite du prototype"
alimentation_miniprojet: "Base maintenable et evolutive pour l’application"
---


# 📘 5.2.6 - Bonnes pratiques

## 📒 Rappels essentiels
- **Lisibilité avant tout** : le code doit être facile à lire et comprendre.  
- **Noms clairs** : variables, fonctions et classes décrivent leur rôle.  
- **Responsabilité unique** : une fonction ou une classe = une seule tâche.  
- **POO** : utiliser des classes pour modéliser des objets du monde réel.  
- **Immutabilité** : privilégier `val` et `data class` pour éviter les erreurs.  

---

## Étape 1 — Bien nommer son code

```kotlin
// ❌ Mauvais
fun d(x: Int): Int = x * 2

// ✅ Bon
fun double(value: Int): Int = value * 2
````

> Un nom clair vaut mieux qu’un commentaire.

---

## Étape 2 — Une fonction = une responsabilité

```kotlin
// ❌ Mauvais : trop de choses à la fois
fun processUser(name: String, age: Int) {
    println("Bonjour $name")
    if (age >= 18) println("Majeur") else println("Mineur")
}

// ✅ Bon : chaque fonction fait une seule chose
fun greet(name: String) = println("Bonjour, $name")

fun checkAge(age: Int) =
    if (age >= 18) "Majeur" else "Mineur"

fun main() {
    greet("Sara")
    println(checkAge(20))
}
```

---

## Étape 3 — Utiliser des classes pour modéliser

```kotlin
class Person(val name: String, val age: Int) {
    fun isAdult() = age >= 18
}

fun main() {
    val p = Person("Ali", 20)
    println("${p.name} est adulte ? ${p.isAdult()}")
}
```

> Une classe représente un concept précis (`Person`, `Article`, `Todo`).

---

## Étape 4 — Préférer `val` et l’immuabilité

```kotlin
data class Counter(val count: Int = 0) {
    fun increment() = copy(count = count + 1)
}

fun main() {
    val c1 = Counter()
    val c2 = c1.increment()
    println(c1) // Counter(count=0)
    println(c2) // Counter(count=1)
}
```

> Avec `val` et `copy`, on évite les effets de bord imprévisibles.

---

## Étape 5 — Résumé du principe de responsabilité unique

* Une **fonction** = une seule action.
* Une **classe** = un seul rôle (modéliser un concept).
* Si une fonction/classe commence à faire trop de choses → il faut **séparer**.

---

## 🧪 Vérifications rapides

* [ ] Mes variables/fonctions ont des **noms explicites**.
* [ ] Chaque fonction fait **une seule chose**.
* [ ] Mes classes représentent des concepts clairs.
* [ ] J’utilise `val` par défaut et `copy` pour mettre à jour.

---

## 📦 Livrables attendus

* Une classe `Person` avec fonction `isAdult()`.
* Deux fonctions simples (`greet`, `checkAge`).
* Une `data class Counter` avec fonction `increment()`.

---

 