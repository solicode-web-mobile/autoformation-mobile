---
title: 5. Collections
layout: home
nav_order: 5
parent: 5.2. Kotlin essentiel pour Android
permalink: /kotlin-essentiel/collections/
code: 5.2.5
competence: C5
autoformation: "C5.2"
ua: "5.2.U3"
duree_h: 1.5
objectif: "Manipuler List/Set/Map de facon lisible et sure avec les operations idiomatiques."
notions_nouvelles: ["List/Set/Map (immutables/mutables)", "map/filter/mapNotNull", "sumOf/sortedBy", "distinctBy", "groupBy/associateBy", "getOrElse"]
fil_rouge: "App Mobile Compose + API Blog Laravel"
livrable_chapitre: "`filterAndSort`, `asSections`, `stats` + 1‚Äì2 tests et exemple Map avec acces sur"
alimentation_prototype: "Listes filtrees/tries pour ecrans (Todo/Articles)"
alimentation_miniprojet: "Sectionnement et agregats (stats UI) performants"
---


# üìò 5.2.5 ‚Äî `List/Set/Map`

## üìí Glossaire minute

* **`List<T>`** : s√©quence **ordonn√©e**, doublons autoris√©s.
* **`Set<T>`** : ensemble **sans doublons** (√©galit√© structurelle).
* **`Map<K,V>`** : association cl√©‚Üívaleur (cl√©s **uniques**).
* **Immuable** (par d√©faut) : `listOf`, `setOf`, `mapOf`.
* **Mutable** (√† limiter) : `mutableListOf`, `mutableSetOf`, `mutableMapOf`.
* **Op√©rations cl√©s** : `map`, `filter`, `mapNotNull`, `sumOf`, `sortedBy`, `distinctBy`, `groupBy`, `associateBy`, `getOrElse`.

---

## ‚úÖ Objectif p√©dagogique

Savoir **choisir** la bonne collection, **it√©rer** lisiblement et appliquer les **transformations idiomatiques**, avec des **acc√®s Map s√ªrs** (sans NPE(NullPointerException)).

---

## üõ† Tutoriel pas-√†-pas (console)

> üí° Copie chaque bloc dans un fichier `Main.kt` et ex√©cute. Les √©tapes sont ind√©pendantes.

### √âtape 1 ‚Äî D√©clarer & choisir (immuable d‚Äôabord)

**Explication.**
On pr√©f√®re l‚Äô**immuable** pour √©viter les effets de bord. On ne passe en **mutable** que quand on **doit** modifier *localement*.

```kotlin
// Main.kt ‚Äî √âtape 1
fun main() {
    val tags: List<String> = listOf("android", "kotlin", "compose") // immuable
    val bag: MutableList<Int> = mutableListOf(1, 2, 2)              // modifiable

    val uniq: Set<String> = setOf("kotlin", "kotlin", "compose")    // {"kotlin","compose"}
    val counts: MutableMap<String, Int> = mutableMapOf("done" to 3)

    println("tags=$tags")
    println("bag avant: $bag")
    bag.add(2)
    println("bag apr√®s: $bag")
    println("uniq=$uniq")
    println("counts=$counts")
}
```

---

### √âtape 2 ‚Äî It√©rations idiomatiques

**Explication.**
Utilise la **d√©structuration** et `withIndex()` ; r√©serve `for`/`break` aux cas n√©cessaires, sinon pr√©f√®re les **op√©rateurs**.

```kotlin
// Main.kt ‚Äî √âtape 2
fun main() {
    val tags = listOf("Kotlin", "Compose", "Flow")

    // for-each simple
    for (t in tags) println("tag=$t")

    // index + valeur
    for ((i, t) in tags.withIndex()) println("$i ‚Üí $t")

    // D√©structuration Map
    val counts = mapOf("done" to 3, "todo" to 5)
    for ((k, v) in counts) println("$k = $v")

    // Version fonctionnelle
    tags.forEach { println("‚Ä¢ $it") }
}
```

---

### √âtape 3 ‚Äî Transformations essentielles

**Explication.**
`filter` **s√©lectionne**, `map` **projette**, `sumOf` **additionne**, `sortedBy` **trie**, `distinctBy` **retire des doublons selon une cl√©**, `groupBy` **regroupe**, `associateBy` **indexe**.

```kotlin
// Main.kt ‚Äî √âtape 3
data class Todo(val id: Long, val title: String, val done: Boolean)

fun main() {
    val todos = listOf(
        Todo(1, "√âtudier Kotlin", true),
        Todo(2, "√âcrire UI Compose", false),
        Todo(3, "Tests", true),
        Todo(4, "√âtudier Kotlin", false) // doublon de title pour distinctBy
    )

    // Filtrer + projeter
    val doneTitles: List<String> = todos.filter { it.done }.map { it.title }
    println("doneTitles=$doneTitles")

    // Sommes & comptes
    val totalDone = todos.count { it.done }
    val totalChars = todos.sumOf { it.title.length }
    val avgTitle = todos.map { it.title.length }.average()
    println("done=$totalDone, chars=$totalChars, avg=$avgTitle")

    // Tri & unicit√©
    val sorted = todos.sortedBy { it.title.lowercase() }
    val distinctByTitle = todos.distinctBy { it.title }
    println("sorted=${sorted.map { it.title }}")
    println("distinctByTitle=${distinctByTitle.map { it.title }}")

    // Groupement & indexation
    val byDone: Map<Boolean, List<Todo>> = todos.groupBy { it.done }
    val byId: Map<Long, Todo> = todos.associateBy { it.id }
    println("byDone keys=${byDone.keys}")
    println("byId keys=${byId.keys}")

    // Nettoyage des nulls
    val maybeIds: List<Long?> = listOf(1, null, 2)
    val ids: List<Long> = maybeIds.filterNotNull()
    println("ids=$ids")

    // Conversion personnalis√©e -> Map<K,V>
    val kv: Map<String, Int> = todos.associate { it.title to it.title.length }
    println("kv=$kv")
}
```

---

### √âtape 4 ‚Äî `Map` : acc√®s **s√ªr** (√©viter les NPE)

**Explication.**

* `getOrElse(k) { d√©faut }` √©value un **d√©faut calcul√©**.
* `m[k] ?: d√©faut` donne un **d√©faut constant**.
* `getValue(k)` **jette** si absent (utiliser seulement si la cl√© est garantie).

```kotlin
// Main.kt ‚Äî √âtape 4
fun main() {
    val m = mapOf("x" to 1)

    val v1 = m.getOrElse("y") { 0 } // d√©faut calcul√©
    val v2 = m["y"] ?: 0            // d√©faut constant
    val v3 = m.getValue("x")        // 1 (pr√©sent)

    println("v1=$v1, v2=$v2, v3=$v3")

    // D√©mo toMap et cl√©s dupliqu√©es : derni√®re valeur conserv√©e
    val pairs = listOf("a" to 1, "a" to 9, "b" to 2)
    val toMap = pairs.toMap()
    println("toMap=$toMap") // {a=9, b=2}

    // Quand l‚Äôunicit√© est importante, pr√©f√®re associateBy
    data class User(val id: Long, val name: String)
    val users = listOf(User(1, "Ali"), User(2, "Sara"), User(1, "Ali (dupliqu√©)"))
    val byId = users.associateBy { it.id }
    println("byId=$byId") // garde le dernier id=1
}
```

---

### √âtape 5 ‚Äî Recettes r√©utilisables (console)

**Explication.**

Trois utilitaires g√©n√©riques que tu r√©emploieras plus tard (filtrage/tri, sectionnement, statistiques). Ici on reste **console**, avec un `main` de d√©monstration.

```kotlin
// Main.kt ‚Äî √âtape 5
data class Todo(val id: Long, val title: String, val done: Boolean)

fun filterAndSort(todos: List<Todo>, q: String): List<Todo> =
    todos
        .filter { it.title.contains(q.trim(), ignoreCase = true) }
        .sortedBy { it.title.lowercase() }

data class Section(val header: String, val items: List<Todo>)
fun asSections(todos: List<Todo>): List<Section> =
    todos.groupBy { if (it.done) "Termin√©es" else "√Ä faire" }
         .map { (h, items) -> Section(h, items.sortedBy { it.title }) }

data class Stats(val total: Int, val done: Int, val ratio: Double)
fun stats(todos: List<Todo>): Stats {
    val total = todos.size
    val done = todos.count { it.done }
    val ratio = if (total == 0) 0.0 else done.toDouble() / total
    return Stats(total, done, ratio)
}

fun main() {
    val todos = listOf(
        Todo(1, "Lire Kotlin", true),
        Todo(2, "Coder utils", false),
        Todo(3, "√âcrire tests", true),
        Todo(4, "Composer UI", false)
    )

    val filtered = filterAndSort(todos, "kotlin")
    println("filtered=${filtered.map { it.title }}")

    val sections = asSections(todos)
    println("sections=${sections.map { it.header to it.items.map { t -> t.title } }}")

    val st = stats(todos)
    println("stats=$st")

    // mini-tests simples
    check(filtered.size == 1)
    check(st.total == 4 && st.done == 2 && st.ratio == 0.5)
}
```

---

### √âtape 6 ‚Äî Performance & lisibilit√© (bonus)

**Explication.**
Sur des **grosses listes**, `asSequence()` √©vite des listes interm√©diaires et peut court-circuiter (ex. `firstOrNull`). Sur de **petites listes UI**, l‚Äôint√©r√™t est faible‚Äîpriorise la **lisibilit√©**.

```kotlin
// Main.kt ‚Äî √âtape 6 (bonus)
data class Blob(val size: Int, val id: Int)

fun main() {
    val blobs = (1..1000).map { Blob(size = it, id = it) }

    // Sans s√©quence : cr√©e des listes interm√©diaires
    val firstBig1 = blobs.filter { it.size > 900 }.map { it.id }.firstOrNull()
    println("firstBig1=$firstBig1")

    // Avec s√©quence : plus paresseux
    val firstBig2 = blobs.asSequence().filter { it.size > 900 }.map { it.id }.firstOrNull()
    println("firstBig2=$firstBig2")
}
```

---

## üß™ V√©rifications rapides

* [ ] Tu **choisis** immuable par d√©faut (`listOf`, `setOf`, `mapOf`).
* [ ] Tu sais **it√©rer** (`withIndex`, d√©structuration Map).
* [ ] Tu ma√Ætrises `map/filter/mapNotNull/sumOf/sortedBy/distinctBy`.
* [ ] Tu sais **regrouper/indexer** (`groupBy`, `associateBy`).
* [ ] Tu acc√®des √† `Map` **sans NPE** (`getOrElse`, `?:`, `getValue` si garanti).

---

## ü©π Erreurs fr√©quentes & correctifs

* ‚ùå Tout √©crire en **mutable** ‚Üí ‚úÖ **Immuable** + reconstruire.
* ‚ùå `!!` sur `Map` ‚Üí ‚úÖ `getOrElse` / `?:` / `getValue`.
* ‚ùå Tri sensible √† la casse ‚Üí ‚úÖ `sortedBy { it.lowercase() }`.
* ‚ùå `toMap()` avec cl√©s dupliqu√©es sans y penser ‚Üí ‚úÖ `groupBy`/`associateBy`.
* ‚ùå Modifier une collection pendant l‚Äôit√©ration ‚Üí ‚úÖ travailler sur une **copie** (`toMutableList()`).

---


## ‚ö° Cheatsheet

```kotlin
// Bases
val l = listOf(1,2,3); val s = setOf(1,1,2); val m = mapOf("a" to 1)

// It√©rations
for ((i, v) in l.withIndex()) {}
for ((k, v) in m) {}

// Ops cl√©s
l.filter { it > 1 }.map { it * 10 }.sumOf { it }   // 50
l.distinct().sorted()

// Group & index
data class Todo(val id: Long, val title: String, val done: Boolean)
val byKey = l.groupBy { it % 2 }      // 0‚Üí[2], 1‚Üí[1,3]
val index  = listOf(
  Todo(1,"A",true), Todo(2,"B",false)
).associateBy { it.id }

// Map safe
val v = m["x"] ?: 0
```
