---
title: 2. Null-safety
layout: home
nav_order: 2
parent: 5.2. Kotlin essentiel pour Android
permalink: /kotlin-essentiel/null-safety/
code: 5.2.2
competence: C5
autoformation: "C5.2"
ua: "5.2.U1"
duree_h: 1.5
objectif: "Eviter les NPE avec T?, safe calls, Elvis, let et safe cast dans les flux Android."
notions_nouvelles: ["T?", "?.", "?: (Elvis)", "let", "as?", "toIntOrNull", "requireNotNull", "Platform type"]
fil_rouge: "App Mobile Compose + API Blog Laravel"
livrable_chapitre: "Utilitaires null-safe (parseCount, greet), Intent/Bundle sans !!, tests rapides"
alimentation_prototype: "Securise les entrees UI/Intent et les parsings"
alimentation_miniprojet: "Contrats DTO propres et mapping vers le domaine"
---


# üìò 5.2.2 ‚Äî Null-safety 


## üìí Glossaire minute

* **Type nullable** `T?` : peut √™tre `null`.
* **Safe call** `obj?.m()` : n‚Äôappelle que si non nul (sinon `null`).
* **Elvis** `a ?: b` : si `a` est `null`, renvoie `b`.
* **Scope** `obj?.let { ... }` : ex√©cute le bloc **seulement** si non nul.
* **Non-null assertion** `obj!!` : *jure* que non nul ‚Üí `NPE` si faux (‚ö†Ô∏è).
* **Safe cast** `x as? T` : renvoie `null` si le cast √©choue.

---

## ‚úÖ Objectif

√âcrire du code **s√ªr** et **lisible** sans `NullPointerException` : choisir correctement `T` vs `T?`, cha√Æner `?.` + `?:`, utiliser `let`, **√©viter `!!`**, et traiter proprement les valeurs optionnelles courantes (saisie utilisateur, conversions num√©riques, listes).

---

## 1) Choisir `T` ou `T?`

* Par d√©faut : **non nullable** (`val name: String = "‚Ä¶"`) pour √©viter les `null` inutiles.
* Nullable **seulement si** la valeur peut vraiment manquer (`val nickname: String?`).

```kotlin
// Non-nullables (pr√©f√©r√©)
val title: String = "Kotlin"
val count: Int = 0

// Nullables (optionnels)
val nickname: String? = null
val maybeNumber: Int? = null
```

---

## 2) Safe call `?.` + Elvis `?:` (duo gagnant)

```kotlin
val name: String? = readLine() // peut √™tre null

// Longueur ou 0 si null
val len = name?.length ?: 0

// Message si nom non vide, sinon cha√Æne vide
val greeting = name?.trim()
  ?.takeIf { it.isNotEmpty() }
  ?.let { "Bonjour, $it !" }
  ?: ""
```

> Astuce : `takeIf` garde la valeur si la condition est vraie (sinon `null`).

---

## 3) `let` pour scoper un non-null

```kotlin
val maybeText: String? = " Kotlin "

maybeText?.let { text ->
  val cleaned = text.trim()
  println("Texte nettoy√©: $cleaned")
}
// Si null, rien ne s'affiche
```

**Early-return lisible (dans une fonction)**

```kotlin
fun proceedOrReturn() {
  val token: String = readLine()
    ?.trim()
    ?.takeIf { it.isNotEmpty() }
    ?: return  // on stoppe proprement si token absent

  println("Token: $token")
}
```

---

## 4) √âviter `!!` (et quoi faire √† la place)

**√Ä √©viter**

```kotlin
val s: String? = null
val len = s!!.length // ‚ùå crash si null
```

**Alternatives s√ªres**

```kotlin
val s: String? = null

// 1) Valeur de secours
val len = s?.length ?: 0

// 2) V√©rifier avant usage (promotion smart-cast)
val t: String? = "Hello"
if (t != null) {
  println(t.length) // t est non nul ici
}

// 3) Exiger explicitement (si vous √™tes s√ªr)
val ok = requireNotNull("Kotlin") { "doit √™tre non null" }
```

> **R√®gle** : `!!` uniquement si **logiquement impossible** d‚Äô√™tre null **ET** d√©j√† v√©rifi√©.

---

## 5) Safe cast `as?` & collections

```kotlin
val any: Any = "42"
val asInt: Int? = (any as? String)?.toIntOrNull()   // 42, sinon null

val emails: List<String?> = listOf("a@b", null, "c@d")
val nonNullEmails: List<String> = emails.filterNotNull()

val ints = listOf("1", "x", "2").mapNotNull { it.toIntOrNull() } // [1, 2]
```

---

## 6) Cas courants (base d√©j√† vue)

### A) Lecture et normalisation de texte (console)

```kotlin
fun greet(input: String?): String =
  input
    ?.trim()
    ?.takeIf { it.isNotEmpty() }
    ?.let { "Bonjour, $it !" }
    ?: ""
```

### B) Conversion s√ªre en nombre

```kotlin
fun parseCount(input: String?): Int =
  input?.trim()?.toIntOrNull()?.coerceAtLeast(0) ?: 0
```

### C) Acc√®s de liste sans risque

```kotlin
fun safeAt(xs: List<Int>, index: Int): Int =
  xs.getOrNull(index) ?: -1
```

### D) Pipeline simple sur une liste nullable

```kotlin
fun upperIfPresent(xs: List<String>?): List<String> =
  xs?.map { it.uppercase() } ?: emptyList()
```

---

## üß™ V√©rifications rapides 

Copiez-collez dans un `fun main()` pour voir le r√©sultat :

```kotlin
fun main() {
  println(greet(null))          // ""
  println(greet("  Ada "))      // "Bonjour, Ada !"

  println(parseCount(null))     // 0
  println(parseCount("-5"))     // 0
  println(parseCount(" 12 "))   // 12

  println(safeAt(listOf(10,20), 1))  // 20
  println(safeAt(listOf(10,20), 9))  // -1

  println(upperIfPresent(listOf("a","b"))) // [A, B]
  println(upperIfPresent(null))            // []
}
```

---

## ü©π Erreurs fr√©quentes & correctifs

* ‚ùå Tout d√©clarer en `T?` ‚Üí üå± **non-nullable par d√©faut**, `?` seulement si n√©cessaire.
* ‚ùå Encha√Æner `!!` ‚Üí ‚úÖ utilisez `?:`, `if (x != null)`, `requireNotNull` au bon endroit.
* ‚ùå Oublier `toIntOrNull()` ‚Üí ‚úÖ √©vitez les `NumberFormatException`.
* ‚ùå Empiler des `let {}` inutilement ‚Üí ‚úÖ pr√©f√©rez `?.` + `?:` simples.

---

## üì¶ Livrables attendus

* Petites fonctions utilitaires null-safe :

  * `greet(input: String?): String`,
  * `parseCount(input: String?): Int`,
  * `safeAt(xs: List<Int>, index: Int): Int`.
* Exemples d‚Äôutilisation **sans `!!`** (console).
* Un court `main()` qui **affiche** les r√©sultats pour v√©rification.

---

## ‚úÖ DoD ‚Äî Definition of Done

* [ ] Aucun `!!` injustifi√©.
* [ ] `?.` + `?:` ma√Ætris√©s, `let` utilis√© **√† bon escient**.
* [ ] Conversions s√ªres (`toIntOrNull`) + valeurs par d√©faut claires.
* [ ] D√©monstrations ex√©cutables dans un `main()`.

---

## ‚ö° Cheatsheet

```kotlin
// Safe call + Elvis
val textLen = text?.length ?: 0

// Scope seulement si non nul
maybe?.let { use(it) }

// Early return dans une fonction
fun f(s: String?) {
  val v = s?.trim()?.takeIf { it.isNotEmpty() } ?: return
  println(v)
}

// Safe cast + conversion s√ªre
val n = (any as? String)?.toIntOrNull() ?: 0

// Collections
val clean: List<String> = dirty.filterNotNull()
val nums: List<Int> = strings.mapNotNull { it.toIntOrNull() }
```
