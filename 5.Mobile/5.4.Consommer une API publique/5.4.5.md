---
title: 5. Mise à jour optimiste
layout: home
nav_order: 5
parent: 5.4. Consommer une API
permalink: /android-api/write-optimistic/
code: 5.4.5
competence: C5
autoformation: "C5.4"
ua: "5.4.U3"
duree_h: 1.5
objectif: "Implémenter POST/PATCH/DELETE en mise à jour optimiste avec rollback et Undo."
notions_nouvelles: ["Optimistic UI", "Rollback", "Temp ID", "Snackbar Undo", "Mises à jour immuables"]
fil_rouge: "App Mobile Compose + API Blog Laravel"
livrable_chapitre: "TodosVM (add/toggle/delete/undo) + UI avec Snackbar Undo"
alimentation_prototype: "Interactions fluides sans attendre le serveur"
alimentation_miniprojet: "Robustesse en cas d’échecs réseau"
---

# 📘 Chapitre 5.4.5 — **POST** (ajouter), **PATCH** (compléter), **DELETE** (supprimer) — *mise à jour optimiste* + rollback

## 📒 Glossaire minute
- **Mise à jour optimiste** : on **met à jour l’UI immédiatement** (sans attendre le serveur) pour une sensation de fluidité.  
- **Rollback** : si la requête **échoue**, on **revient** à l’état précédent.  
- **Temp ID** : identifiant **provisoire** (ex. négatif) en attendant l’`id` réel du serveur.  
- **Undo** : possibilité de **revenir** sur une suppression (souvent via **snackbar**).

---

## 🎯 Objectif pédagogique
Implémenter **POST/PATCH/DELETE** avec un flux **optimiste** :  
1) **Mettre à jour l’UI** tout de suite,  
2) **Appeler** l’API,  
3) **Consolider** (succès) ou **rollback** (échec) + **snackbar** utile.

---

## 1) Pré-requis
- `ApiService`, `TodoRepository` et `UiState` vus en **5.4.1 → 5.4.4**.  
- Modèle minimal :

```kotlin
data class Todo(
  val id: Int? = null,
  val userId: Int,
  val title: String,
  val completed: Boolean = false
)

data class TodoCreate(val userId: Int, val title: String, val completed: Boolean = false)
typealias TodoPatch = Map<String, @JvmSuppressWildcards Any?>
````

---

## 2) ViewModel — opérations optimistes (POST / PATCH / DELETE)

```kotlin
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.launch

class TodosVM(
  private val repo: TodoRepository = TodoRepository(NetworkModule.api),
  private val currentUserId: Int = 10
) : ViewModel() {

  var state by mutableStateOf<UiState<List<Todo>>>(UiState.Loading)
    private set

  // Pour Undo de la dernière suppression réussie
  private var lastDeleted: Todo? = null

  init { load() }

  fun load() {
    state = UiState.Loading
    viewModelScope.launch {
      val res = repo.list()
      state = res.fold(
        onSuccess = { UiState.Success(it) },
        onFailure = { UiState.Error(it.message ?: "Erreur réseau", ::load) }
      )
    }
  }

  // ----- Helpers immutables -----
  private inline fun mutate(block: (List<Todo>) -> List<Todo>) {
    val current = (state as? UiState.Success)?.data ?: return
    state = UiState.Success(block(current))
  }

  // Génère un ID temporaire négatif pour un item fraîchement ajouté
  private var tempIdSeq = -1
  private fun nextTempId(): Int = tempIdSeq--

  // ----- POST (ajouter) — Optimiste + consolidation/rollback -----
  fun add(title: String) {
    if (title.isBlank()) return
    val temp = Todo(id = nextTempId(), userId = currentUserId, title = title, completed = false)

    // 1) UI immédiate
    mutate { list -> list.toMutableList().apply { add(0, temp) } }

    // 2) Appel réseau
    viewModelScope.launch {
      val result = repo.create(TodoCreate(userId = temp.userId, title = temp.title, completed = temp.completed))
      result.fold(
        onSuccess = { created ->
          // 3a) Consolider : remplacer l'item temporaire par l'item serveur
          mutate { list ->
            list.map { if (it.id == temp.id) created else it }
          }
        },
        onFailure = {
          // 3b) Rollback : retirer l'item temporaire ajouté
          mutate { list -> list.filterNot { it.id == temp.id } }
          state = UiState.Error(it.message ?: "Ajout impossible", retry = { add(title) })
        }
      )
    }
  }

  // ----- PATCH (compléter) — Optimiste + rollback -----
  fun toggleCompleted(id: Int, newCompleted: Boolean) {
    val before = (state as? UiState.Success)?.data?.firstOrNull { it.id == id } ?: return

    // 1) UI immédiate
    mutate { list -> list.map { if (it.id == id) it.copy(completed = newCompleted) else it } }

    // 2) Réseau
    viewModelScope.launch {
      val result = repo.patch(id, mapOf("completed" to newCompleted))
      result.fold(
        onSuccess = { /* rien : l'UI reflète déjà le nouvel état */ },
        onFailure = {
          // 3) Rollback
          mutate { list -> list.map { if (it.id == id) before else it } }
          state = UiState.Error(it.message ?: "Mise à jour impossible", retry = { toggleCompleted(id, newCompleted) })
        }
      )
    }
  }

  // ----- DELETE (supprimer) — Optimiste + rollback + Undo -----
  fun delete(id: Int) {
    val removed = (state as? UiState.Success)?.data?.firstOrNull { it.id == id } ?: return

    // 1) UI immédiate
    mutate { list -> list.filterNot { it.id == id } }

    // 2) Appel réseau
    viewModelScope.launch {
      val result = repo.delete(id)
      result.fold(
        onSuccess = {
          // 3a) Garde pour Undo (recréation si l'utilisateur annule)
          lastDeleted = removed
          // (La UI peut afficher un snackbar "Supprimé — Annuler")
        },
        onFailure = {
          // 3b) Rollback (réinsérer l'élément)
          mutate { list -> list.toMutableList().apply { add(0, removed) } }
          state = UiState.Error(it.message ?: "Suppression impossible", retry = { delete(id) })
        }
      )
    }
  }

  // ----- Undo pour DELETE réussi -----
  fun undoDelete() {
    val snapshot = lastDeleted ?: return
    lastDeleted = null
    // UI optimiste : réinsérer de suite (avec id temporaire pour l'interface)
    val temp = snapshot.copy(id = nextTempId())
    mutate { list -> list.toMutableList().apply { add(0, temp) } }

    viewModelScope.launch {
      val res = repo.create(TodoCreate(snapshot.userId, snapshot.title, snapshot.completed))
      res.fold(
        onSuccess = { created -> mutate { list -> list.map { if (it.id == temp.id) created else it } } },
        onFailure = {
          // Rollback si la recréation échoue
          mutate { list -> list.filterNot { it.id == temp.id } }
          state = UiState.Error(it.message ?: "Annulation impossible", retry = ::undoDelete)
        }
      )
    }
  }
}
```

---

## 3) UI — actions & **Snackbar** (Undo suppression)

```kotlin
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp

@Composable
fun TodosRoute(vm: TodosVM = androidx.lifecycle.viewmodel.compose.viewModel()) {
  val state = vm.state
  val snackbarHost = remember { SnackbarHostState() }

  // Snackbars pour erreurs (facultatif)
  LaunchedEffect(state) {
    if (state is UiState.Error) snackbarHost.showSnackbar(state.message)
  }

  Scaffold(
    snackbarHost = { SnackbarHost(hostState = snackbarHost) },
    floatingActionButton = {
      // Exemple *ajout rapide* (titre fixe pour la démo)
      FloatingActionButton(onClick = { vm.add("Nouvelle TODO") }) {
        Text("+")
      }
    }
  ) { padding ->
    Box(Modifier.padding(padding)) {
      when (state) {
        is UiState.Loading -> LoadingView()
        is UiState.Error   -> ErrorView(message = state.message, onRetry = { vm.load() })
        is UiState.Success -> {
          val items = state.data
          if (items.isEmpty()) {
            EmptyView("Aucune TODO", "Ajoutez un élément ou rechargez.", onRetry = { vm.load() })
          } else {
            TodosList(
              items = items,
              onToggle = { id, checked -> vm.toggleCompleted(id, checked) },
              onDelete = { id ->
                vm.delete(id)
                // Affiche Undo si la suppression a réussi côté réseau (VM enregistrera lastDeleted)
                // NB: on montre immédiatement; pour être strict, on peut écouter un "event" success.
                LaunchedEffect(Unit) {
                  val res = snackbarHost.showSnackbar(
                    message = "Supprimé",
                    actionLabel = "Annuler",
                    withDismissAction = true
                  )
                  if (res == SnackbarResult.ActionPerformed) vm.undoDelete()
                }
              }
            )
          }
        }
      }
    }
  }
}

@Composable
fun TodosList(
  items: List<Todo>,
  onToggle: (id: Int, checked: Boolean) -> Unit,
  onDelete: (id: Int) -> Unit,
  modifier: Modifier = Modifier
) {
  LazyColumn(
    modifier = modifier.fillMaxSize().padding(12.dp),
    verticalArrangement = Arrangement.spacedBy(8.dp)
  ) {
    items(items, key = { it.id ?: it.hashCode() }) { todo ->
      TodoRow(todo, onToggle = onToggle, onDelete = onDelete)
    }
  }
}

@Composable
private fun TodoRow(
  todo: Todo,
  onToggle: (id: Int, checked: Boolean) -> Unit,
  onDelete: (id: Int) -> Unit
) {
  Card {
    Row(
      Modifier.fillMaxWidth().padding(12.dp),
      verticalAlignment = Alignment.CenterVertically
    ) {
      Checkbox(
        checked = todo.completed,
        onCheckedChange = { checked -> todo.id?.let { onToggle(it, checked) } }
      )
      Spacer(Modifier.width(12.dp))
      Column(Modifier.weight(1f)) {
        Text(todo.title, style = MaterialTheme.typography.titleMedium, maxLines = 1, overflow = TextOverflow.Ellipsis)
        Text("User #${todo.userId} • id=${todo.id ?: "temp"}", style = MaterialTheme.typography.bodySmall)
      }
      IconButton(
        onClick = { todo.id?.let(onDelete) },
        enabled = todo.id != null // on évite de supprimer un item sans id serveur en cours de POST
      ) {
        Icon(Icons.Default.Delete, contentDescription = "Supprimer")
      }
    }
  }
}
```

---

## ✅ Check-list

* [ ] **POST** : ajout **optimiste** (tempId) → **remplacement** par l’item serveur.
* [ ] **PATCH** : bascule **optimiste** (`completed`) → **rollback** si échec.
* [ ] **DELETE** : retrait **optimiste** → **rollback** si échec, **Undo** si succès.
* [ ] **Snackbar** informatif ; messages clairs & action **Annuler** pour DELETE.
* [ ] Mutations **immutables** (copie de liste) pour éviter les artefacts UI.

---

## 🩹 Dépannage

* **Écran figé** : vérifier que les appels réseau sont dans `viewModelScope.launch` et que l’API est `suspend`.
* **ID dupliqués** : utilisez des **tempId négatifs** jusqu’au retour du serveur.
* **Undo n’insère rien** : `lastDeleted` peut être `null` si vous avez appelé `undoDelete()` plusieurs fois ; gérez le cas.
* **PATCH a “ré-clignoté”** : c’est le **rollback** → inspecter l’erreur (timeout/offline).
* **DELETE sur item en POST** : désactiver le bouton tant que `id` serveur est `null`.

---

## 🧪 Exercices

1. Remplacer la `FloatingActionButton` par un **champ de saisie** (`TextField`) + bouton **Ajouter** (valider vide/espaces).
2. Étendre `toggleCompleted` pour **optimiser** : si plusieurs toggles rapides, agréger les PATCH (debounce) avant envoi.
3. Ajouter une **barre d’erreur non bloquante** (Snackbar) qui propose **Réessayer** après rollback sur POST/PATCH.
4. Bonus : stocker les **opérations en file** (Queue) avec un **état “pending”** sur les items (spinner à droite).
