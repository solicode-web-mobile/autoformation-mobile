---
title: 5. Mise √† jour optimiste
layout: home
nav_order: 5
parent: 5.4. Consommer une API
permalink: /android-api/write-optimistic/
code: 5.4.5
competence: C5
autoformation: "C5.4"
ua: "5.4.U3"
duree_h: 1.5
objectif: "Impl√©menter POST/PATCH/DELETE en mise √† jour optimiste avec rollback et Undo."
notions_nouvelles: ["Optimistic UI", "Rollback", "Temp ID", "Snackbar Undo", "Mises √† jour immuables"]
fil_rouge: "App Mobile Compose + API Blog Laravel"
livrable_chapitre: "TodosVM (add/toggle/delete/undo) + UI avec Snackbar Undo"
alimentation_prototype: "Interactions fluides sans attendre le serveur"
alimentation_miniprojet: "Robustesse en cas d‚Äô√©checs r√©seau"
---

# üìò Chapitre 5.4.5 ‚Äî **POST** (ajouter), **PATCH** (compl√©ter), **DELETE** (supprimer) ‚Äî *mise √† jour optimiste* + rollback

## üìí Glossaire minute
- **Mise √† jour optimiste** : on **met √† jour l‚ÄôUI imm√©diatement** (sans attendre le serveur) pour une sensation de fluidit√©.  
- **Rollback** : si la requ√™te **√©choue**, on **revient** √† l‚Äô√©tat pr√©c√©dent.  
- **Temp ID** : identifiant **provisoire** (ex. n√©gatif) en attendant l‚Äô`id` r√©el du serveur.  
- **Undo** : possibilit√© de **revenir** sur une suppression (souvent via **snackbar**).

---

## üéØ Objectif p√©dagogique
Impl√©menter **POST/PATCH/DELETE** avec un flux **optimiste** :  
1) **Mettre √† jour l‚ÄôUI** tout de suite,  
2) **Appeler** l‚ÄôAPI,  
3) **Consolider** (succ√®s) ou **rollback** (√©chec) + **snackbar** utile.

---

## 1) Pr√©-requis
- `ApiService`, `TodoRepository` et `UiState` vus en **5.4.1 ‚Üí 5.4.4**.  
- Mod√®le minimal :

```kotlin
data class Todo(
  val id: Int? = null,
  val userId: Int,
  val title: String,
  val completed: Boolean = false
)

data class TodoCreate(val userId: Int, val title: String, val completed: Boolean = false)
typealias TodoPatch = Map<String, @JvmSuppressWildcards Any?>
````

---

## 2) ViewModel ‚Äî op√©rations optimistes (POST / PATCH / DELETE)

```kotlin
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.launch

class TodosVM(
  private val repo: TodoRepository = TodoRepository(NetworkModule.api),
  private val currentUserId: Int = 10
) : ViewModel() {

  var state by mutableStateOf<UiState<List<Todo>>>(UiState.Loading)
    private set

  // Pour Undo de la derni√®re suppression r√©ussie
  private var lastDeleted: Todo? = null

  init { load() }

  fun load() {
    state = UiState.Loading
    viewModelScope.launch {
      val res = repo.list()
      state = res.fold(
        onSuccess = { UiState.Success(it) },
        onFailure = { UiState.Error(it.message ?: "Erreur r√©seau", ::load) }
      )
    }
  }

  // ----- Helpers immutables -----
  private inline fun mutate(block: (List<Todo>) -> List<Todo>) {
    val current = (state as? UiState.Success)?.data ?: return
    state = UiState.Success(block(current))
  }

  // G√©n√®re un ID temporaire n√©gatif pour un item fra√Æchement ajout√©
  private var tempIdSeq = -1
  private fun nextTempId(): Int = tempIdSeq--

  // ----- POST (ajouter) ‚Äî Optimiste + consolidation/rollback -----
  fun add(title: String) {
    if (title.isBlank()) return
    val temp = Todo(id = nextTempId(), userId = currentUserId, title = title, completed = false)

    // 1) UI imm√©diate
    mutate { list -> list.toMutableList().apply { add(0, temp) } }

    // 2) Appel r√©seau
    viewModelScope.launch {
      val result = repo.create(TodoCreate(userId = temp.userId, title = temp.title, completed = temp.completed))
      result.fold(
        onSuccess = { created ->
          // 3a) Consolider : remplacer l'item temporaire par l'item serveur
          mutate { list ->
            list.map { if (it.id == temp.id) created else it }
          }
        },
        onFailure = {
          // 3b) Rollback : retirer l'item temporaire ajout√©
          mutate { list -> list.filterNot { it.id == temp.id } }
          state = UiState.Error(it.message ?: "Ajout impossible", retry = { add(title) })
        }
      )
    }
  }

  // ----- PATCH (compl√©ter) ‚Äî Optimiste + rollback -----
  fun toggleCompleted(id: Int, newCompleted: Boolean) {
    val before = (state as? UiState.Success)?.data?.firstOrNull { it.id == id } ?: return

    // 1) UI imm√©diate
    mutate { list -> list.map { if (it.id == id) it.copy(completed = newCompleted) else it } }

    // 2) R√©seau
    viewModelScope.launch {
      val result = repo.patch(id, mapOf("completed" to newCompleted))
      result.fold(
        onSuccess = { /* rien : l'UI refl√®te d√©j√† le nouvel √©tat */ },
        onFailure = {
          // 3) Rollback
          mutate { list -> list.map { if (it.id == id) before else it } }
          state = UiState.Error(it.message ?: "Mise √† jour impossible", retry = { toggleCompleted(id, newCompleted) })
        }
      )
    }
  }

  // ----- DELETE (supprimer) ‚Äî Optimiste + rollback + Undo -----
  fun delete(id: Int) {
    val removed = (state as? UiState.Success)?.data?.firstOrNull { it.id == id } ?: return

    // 1) UI imm√©diate
    mutate { list -> list.filterNot { it.id == id } }

    // 2) Appel r√©seau
    viewModelScope.launch {
      val result = repo.delete(id)
      result.fold(
        onSuccess = {
          // 3a) Garde pour Undo (recr√©ation si l'utilisateur annule)
          lastDeleted = removed
          // (La UI peut afficher un snackbar "Supprim√© ‚Äî Annuler")
        },
        onFailure = {
          // 3b) Rollback (r√©ins√©rer l'√©l√©ment)
          mutate { list -> list.toMutableList().apply { add(0, removed) } }
          state = UiState.Error(it.message ?: "Suppression impossible", retry = { delete(id) })
        }
      )
    }
  }

  // ----- Undo pour DELETE r√©ussi -----
  fun undoDelete() {
    val snapshot = lastDeleted ?: return
    lastDeleted = null
    // UI optimiste : r√©ins√©rer de suite (avec id temporaire pour l'interface)
    val temp = snapshot.copy(id = nextTempId())
    mutate { list -> list.toMutableList().apply { add(0, temp) } }

    viewModelScope.launch {
      val res = repo.create(TodoCreate(snapshot.userId, snapshot.title, snapshot.completed))
      res.fold(
        onSuccess = { created -> mutate { list -> list.map { if (it.id == temp.id) created else it } } },
        onFailure = {
          // Rollback si la recr√©ation √©choue
          mutate { list -> list.filterNot { it.id == temp.id } }
          state = UiState.Error(it.message ?: "Annulation impossible", retry = ::undoDelete)
        }
      )
    }
  }
}
```

---

## 3) UI ‚Äî actions & **Snackbar** (Undo suppression)

```kotlin
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp

@Composable
fun TodosRoute(vm: TodosVM = androidx.lifecycle.viewmodel.compose.viewModel()) {
  val state = vm.state
  val snackbarHost = remember { SnackbarHostState() }

  // Snackbars pour erreurs (facultatif)
  LaunchedEffect(state) {
    if (state is UiState.Error) snackbarHost.showSnackbar(state.message)
  }

  Scaffold(
    snackbarHost = { SnackbarHost(hostState = snackbarHost) },
    floatingActionButton = {
      // Exemple *ajout rapide* (titre fixe pour la d√©mo)
      FloatingActionButton(onClick = { vm.add("Nouvelle TODO") }) {
        Text("+")
      }
    }
  ) { padding ->
    Box(Modifier.padding(padding)) {
      when (state) {
        is UiState.Loading -> LoadingView()
        is UiState.Error   -> ErrorView(message = state.message, onRetry = { vm.load() })
        is UiState.Success -> {
          val items = state.data
          if (items.isEmpty()) {
            EmptyView("Aucune TODO", "Ajoutez un √©l√©ment ou rechargez.", onRetry = { vm.load() })
          } else {
            TodosList(
              items = items,
              onToggle = { id, checked -> vm.toggleCompleted(id, checked) },
              onDelete = { id ->
                vm.delete(id)
                // Affiche Undo si la suppression a r√©ussi c√¥t√© r√©seau (VM enregistrera lastDeleted)
                // NB: on montre imm√©diatement; pour √™tre strict, on peut √©couter un "event" success.
                LaunchedEffect(Unit) {
                  val res = snackbarHost.showSnackbar(
                    message = "Supprim√©",
                    actionLabel = "Annuler",
                    withDismissAction = true
                  )
                  if (res == SnackbarResult.ActionPerformed) vm.undoDelete()
                }
              }
            )
          }
        }
      }
    }
  }
}

@Composable
fun TodosList(
  items: List<Todo>,
  onToggle: (id: Int, checked: Boolean) -> Unit,
  onDelete: (id: Int) -> Unit,
  modifier: Modifier = Modifier
) {
  LazyColumn(
    modifier = modifier.fillMaxSize().padding(12.dp),
    verticalArrangement = Arrangement.spacedBy(8.dp)
  ) {
    items(items, key = { it.id ?: it.hashCode() }) { todo ->
      TodoRow(todo, onToggle = onToggle, onDelete = onDelete)
    }
  }
}

@Composable
private fun TodoRow(
  todo: Todo,
  onToggle: (id: Int, checked: Boolean) -> Unit,
  onDelete: (id: Int) -> Unit
) {
  Card {
    Row(
      Modifier.fillMaxWidth().padding(12.dp),
      verticalAlignment = Alignment.CenterVertically
    ) {
      Checkbox(
        checked = todo.completed,
        onCheckedChange = { checked -> todo.id?.let { onToggle(it, checked) } }
      )
      Spacer(Modifier.width(12.dp))
      Column(Modifier.weight(1f)) {
        Text(todo.title, style = MaterialTheme.typography.titleMedium, maxLines = 1, overflow = TextOverflow.Ellipsis)
        Text("User #${todo.userId} ‚Ä¢ id=${todo.id ?: "temp"}", style = MaterialTheme.typography.bodySmall)
      }
      IconButton(
        onClick = { todo.id?.let(onDelete) },
        enabled = todo.id != null // on √©vite de supprimer un item sans id serveur en cours de POST
      ) {
        Icon(Icons.Default.Delete, contentDescription = "Supprimer")
      }
    }
  }
}
```

---

## ‚úÖ Check-list

* [ ] **POST** : ajout **optimiste** (tempId) ‚Üí **remplacement** par l‚Äôitem serveur.
* [ ] **PATCH** : bascule **optimiste** (`completed`) ‚Üí **rollback** si √©chec.
* [ ] **DELETE** : retrait **optimiste** ‚Üí **rollback** si √©chec, **Undo** si succ√®s.
* [ ] **Snackbar** informatif ; messages clairs & action **Annuler** pour DELETE.
* [ ] Mutations **immutables** (copie de liste) pour √©viter les artefacts UI.

---

## ü©π D√©pannage

* **√âcran fig√©** : v√©rifier que les appels r√©seau sont dans `viewModelScope.launch` et que l‚ÄôAPI est `suspend`.
* **ID dupliqu√©s** : utilisez des **tempId n√©gatifs** jusqu‚Äôau retour du serveur.
* **Undo n‚Äôins√®re rien** : `lastDeleted` peut √™tre `null` si vous avez appel√© `undoDelete()` plusieurs fois ; g√©rez le cas.
* **PATCH a ‚Äúr√©-clignot√©‚Äù** : c‚Äôest le **rollback** ‚Üí inspecter l‚Äôerreur (timeout/offline).
* **DELETE sur item en POST** : d√©sactiver le bouton tant que `id` serveur est `null`.

---

## üß™ Exercices

1. Remplacer la `FloatingActionButton` par un **champ de saisie** (`TextField`) + bouton **Ajouter** (valider vide/espaces).
2. √âtendre `toggleCompleted` pour **optimiser** : si plusieurs toggles rapides, agr√©ger les PATCH (debounce) avant envoi.
3. Ajouter une **barre d‚Äôerreur non bloquante** (Snackbar) qui propose **R√©essayer** apr√®s rollback sur POST/PATCH.
4. Bonus : stocker les **op√©rations en file** (Queue) avec un **√©tat ‚Äúpending‚Äù** sur les items (spinner √† droite).
