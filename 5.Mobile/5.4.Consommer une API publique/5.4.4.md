---
title: 4. États UI + Retry
layout: home
nav_order: 4
parent: 5.4. Consommer une API
permalink: /android-api/ui-states-retry/
code: 5.4.4
competence: C5
autoformation: "C5.4"
ua: "5.4.U2"
duree_h: 1.5
objectif: "Factoriser loading/empty/error et le Retry via vues réutilisables."
notions_nouvelles: ["StateContainer", "Loading/Empty/Error", "Snackbar", "Scaffold"]
fil_rouge: "App Mobile Compose + API Blog Laravel"
livrable_chapitre: "StateContainer + vues Loading/Empty/Error réutilisables + Previews"
alimentation_prototype: "Pattern d’états commun pour écrans réseau"
alimentation_miniprojet: "Librairie UI partagée"
---


# 📘 Chapitre 5.4.4 — États UI (*loading / empty / error*) + **Retry**

## 📒 Glossaire minute
- **UiState** : contrat d’affichage de l’écran (`Loading`, `Success(data)`, `Error`).
- **Empty state** : écran “liste vide” avec message et action utile.
- **Retry** : callback utilisateur pour relancer la requête après un échec.
- **Scaffold/Snackbar** : composant Material pour afficher des messages non bloquants.

---

## 🎯 Objectif pédagogique
Centraliser le rendu des **trois états** principaux d’un écran connecté (*loading / empty / error*) avec un **bouton Retry**, et **réutiliser** ce motif facilement.

---

## 1) Rappel — `UiState` générique
> Même base que dans 5.4.1–5.4.3.

```kotlin
sealed interface UiState<out T> {
  object Loading : UiState<Nothing>
  data class Success<T>(val data: T) : UiState<T>
  data class Error(val message: String, val retry: () -> Unit) : UiState<Nothing>
}
````

---

## 2) Vues réutilisables : Loading / Empty / Error

```kotlin
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp

@Composable
fun LoadingView(modifier: Modifier = Modifier) {
  Box(modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
    CircularProgressIndicator()
  }
}

@Composable
fun EmptyView(
  title: String,
  hint: String? = null,
  onRetry: (() -> Unit)? = null,
  modifier: Modifier = Modifier
) {
  Column(
    modifier.fillMaxSize().padding(24.dp),
    verticalArrangement = Arrangement.spacedBy(12.dp, Alignment.CenterVertically),
    horizontalAlignment = Alignment.CenterHorizontally
  ) {
    Text(title, style = MaterialTheme.typography.titleMedium)
    if (hint != null) Text(hint, style = MaterialTheme.typography.bodyMedium)
    if (onRetry != null) OutlinedButton(onClick = onRetry) { Text("Recharger") }
  }
}

@Composable
fun ErrorView(
  message: String,
  onRetry: () -> Unit,
  modifier: Modifier = Modifier
) {
  Column(
    modifier.fillMaxSize().padding(24.dp),
    verticalArrangement = Arrangement.spacedBy(12.dp, Alignment.CenterVertically),
    horizontalAlignment = Alignment.CenterHorizontally
  ) {
    Text("Une erreur est survenue", style = MaterialTheme.typography.titleMedium)
    Text(message, style = MaterialTheme.typography.bodyMedium)
    Button(onClick = onRetry) { Text("Réessayer") }
  }
}
```

---

## 3) **StateContainer** générique (réutilisable partout)

> Détermine automatiquement *empty* pour les **listes** (`Collection<*>`).

```kotlin
import androidx.compose.runtime.Composable

@Composable
fun <T> StateContainer(
  state: UiState<T>,
  emptyTitle: String = "Aucune donnée",
  emptyHint: String? = "Ajoutez un élément ou réessayez.",
  // L’UI finale à afficher quand c’est un succès non-vide
  success: @Composable (T) -> Unit
) {
  when (state) {
    is UiState.Loading -> LoadingView()
    is UiState.Error   -> ErrorView(message = state.message, onRetry = state.retry)
    is UiState.Success -> {
      val data = state.data
      val isEmptyList = (data is Collection<*>) && data.isEmpty()
      if (isEmptyList) {
        EmptyView(
          title = emptyTitle,
          hint = emptyHint,
          onRetry = state.retry // dispo via fermeture si vous la stockez ailleurs
        )
      } else {
        success(data)
      }
    }
  }
}
```

> 💡 Si votre `UiState.Success` ne transporte **pas** de `retry`, vous pouvez aussi passer un `onRetry: (() -> Unit)?` à `StateContainer` et le propager à `EmptyView`.

---

## 4) Exemple d’usage avec la liste `/todos`

> Réutilise la `TodosList` du **chapitre 5.4.3**.

```kotlin
import androidx.compose.runtime.Composable
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.Card
import androidx.compose.material3.Text
import androidx.compose.ui.text.style.TextOverflow

@Composable
fun TodosList(items: List<Todo>, modifier: Modifier = Modifier) {
  LazyColumn(
    modifier = modifier.fillMaxSize().padding(12.dp),
    verticalArrangement = Arrangement.spacedBy(8.dp)
  ) {
    items(items, key = { it.id ?: it.hashCode() }) { todo ->
      Card { Text(todo.title, maxLines = 1, overflow = TextOverflow.Ellipsis, modifier = Modifier.padding(12.dp)) }
    }
  }
}

@Composable
fun TodosScreenWithContainer(state: UiState<List<Todo>>) {
  StateContainer(
    state = state,
    emptyTitle = "Aucune tâche",
    emptyHint  = "Créez votre première TODO ou appuyez sur Recharger."
  ) { data ->
    TodosList(data)
  }
}
```

---

## 5) Variante avec **Snackbar** (optionnelle)

> Affiche un **snackbar** quand l’état devient `Error`, en plus de l’écran d’erreur.

```kotlin
import androidx.compose.material3.*
import androidx.compose.runtime.*
import android.content.res.Configuration

@Composable
fun TodosRoute(vm: TodosViewModel = androidx.lifecycle.viewmodel.compose.viewModel()) {
  val snackbarHost = remember { SnackbarHostState() }
  val state = vm.state

  LaunchedEffect(state) {
    if (state is UiState.Error) {
      snackbarHost.showSnackbar(state.message)
    }
  }

  Scaffold(snackbarHost = { SnackbarHost(snackbarHost) }) { padding ->
    Box(Modifier.padding(padding)) {
      when (state) {
        is UiState.Loading -> LoadingView()
        is UiState.Error   -> ErrorView(message = state.message, onRetry = { vm.load() })
        is UiState.Success -> {
          if (state.data.isEmpty())
            EmptyView("Aucune tâche", "Essayez de recharger.", onRetry = { vm.load() })
          else
            TodosList(state.data)
        }
      }
    }
  }
}
```

---

## 6) Previews

```kotlin
import androidx.compose.ui.tooling.preview.Preview

private val sample = listOf(
  Todo(id = 1, userId = 10, title = "Lire la doc Retrofit", completed = false),
  Todo(id = 2, userId = 10, title = "Brancher /todos", completed = true),
)

@Preview(showBackground = true, widthDp = 360)
@Composable
fun Preview_Loading() { LoadingView() }

@Preview(showBackground = true, widthDp = 360)
@Composable
fun Preview_Empty() { EmptyView("Aucune donnée", "Ajoutez un élément ou rechargez.", onRetry = {}) }

@Preview(showBackground = true, widthDp = 360)
@Composable
fun Preview_Error() { ErrorView("Timeout / Offline", onRetry = {}) }

@Preview(showBackground = true, widthDp = 360)
@Composable
fun Preview_Success() { TodosScreenWithContainer(UiState.Success(sample)) }
```

---

## ✅ Check-list

* [ ] **Loading** visible pendant la requête.
* [ ] **Empty** clair et actionnable (message + bouton).
* [ ] **Error** explicite + **Retry** qui relance la charge.
* [ ] **Container** réutilisable (autres écrans/lists).
* [ ] **Previews** pour chaque état (pas de réseau).

---

## 🩹 Dépannage

* **Retry ne fait rien** → vérifier que le `retry` appelle bien `viewModel.load()`.
* **Empty jamais affiché** → votre `Success` ne transporte pas une **liste** vide ? Vérifiez `isEmpty()`.
* **Snackbar invisible** → assurez-vous d’avoir un `Scaffold` avec `SnackbarHost` et un `LaunchedEffect` sur l’état.

---

## 🧪 Exercices

1. Factorisez `StateContainer` dans un module `ui/common`. Réutilisez-le sur un **2ᵉ écran**.
2. Ajoutez une **icône** (Material) différente pour *Empty* et *Error*.
3. Rendez `EmptyView` **slot-based** (paramètres `title`, `hint`, et **slot** `actions`).
