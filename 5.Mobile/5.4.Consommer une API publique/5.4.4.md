---
title: 4. Ã‰tats UI + Retry
layout: home
nav_order: 4
parent: 5.4. Consommer une API
permalink: /android-api/ui-states-retry/
code: 5.4.4
competence: C5
autoformation: "C5.4"
ua: "5.4.U2"
duree_h: 1.5
objectif: "Factoriser loading/empty/error et le Retry via vues rÃ©utilisables."
notions_nouvelles: ["StateContainer", "Loading/Empty/Error", "Snackbar", "Scaffold"]
fil_rouge: "App Mobile Compose + API Blog Laravel"
livrable_chapitre: "StateContainer + vues Loading/Empty/Error rÃ©utilisables + Previews"
alimentation_prototype: "Pattern dâ€™Ã©tats commun pour Ã©crans rÃ©seau"
alimentation_miniprojet: "Librairie UI partagÃ©e"
---


# ðŸ“˜ Chapitre 5.4.4 â€” Ã‰tats UI (*loading / empty / error*) + **Retry**

## ðŸ“’ Glossaire minute
- **UiState** : contrat dâ€™affichage de lâ€™Ã©cran (`Loading`, `Success(data)`, `Error`).
- **Empty state** : Ã©cran â€œliste videâ€ avec message et action utile.
- **Retry** : callback utilisateur pour relancer la requÃªte aprÃ¨s un Ã©chec.
- **Scaffold/Snackbar** : composant Material pour afficher des messages non bloquants.

---

## ðŸŽ¯ Objectif pÃ©dagogique
Centraliser le rendu des **trois Ã©tats** principaux dâ€™un Ã©cran connectÃ© (*loading / empty / error*) avec un **bouton Retry**, et **rÃ©utiliser** ce motif facilement.

---

## 1) Rappel â€” `UiState` gÃ©nÃ©rique
> MÃªme base que dans 5.4.1â€“5.4.3.

```kotlin
sealed interface UiState<out T> {
  object Loading : UiState<Nothing>
  data class Success<T>(val data: T) : UiState<T>
  data class Error(val message: String, val retry: () -> Unit) : UiState<Nothing>
}
````

---

## 2) Vues rÃ©utilisables : Loading / Empty / Error

```kotlin
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp

@Composable
fun LoadingView(modifier: Modifier = Modifier) {
  Box(modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
    CircularProgressIndicator()
  }
}

@Composable
fun EmptyView(
  title: String,
  hint: String? = null,
  onRetry: (() -> Unit)? = null,
  modifier: Modifier = Modifier
) {
  Column(
    modifier.fillMaxSize().padding(24.dp),
    verticalArrangement = Arrangement.spacedBy(12.dp, Alignment.CenterVertically),
    horizontalAlignment = Alignment.CenterHorizontally
  ) {
    Text(title, style = MaterialTheme.typography.titleMedium)
    if (hint != null) Text(hint, style = MaterialTheme.typography.bodyMedium)
    if (onRetry != null) OutlinedButton(onClick = onRetry) { Text("Recharger") }
  }
}

@Composable
fun ErrorView(
  message: String,
  onRetry: () -> Unit,
  modifier: Modifier = Modifier
) {
  Column(
    modifier.fillMaxSize().padding(24.dp),
    verticalArrangement = Arrangement.spacedBy(12.dp, Alignment.CenterVertically),
    horizontalAlignment = Alignment.CenterHorizontally
  ) {
    Text("Une erreur est survenue", style = MaterialTheme.typography.titleMedium)
    Text(message, style = MaterialTheme.typography.bodyMedium)
    Button(onClick = onRetry) { Text("RÃ©essayer") }
  }
}
```

---

## 3) **StateContainer** gÃ©nÃ©rique (rÃ©utilisable partout)

> DÃ©termine automatiquement *empty* pour les **listes** (`Collection<*>`).

```kotlin
import androidx.compose.runtime.Composable

@Composable
fun <T> StateContainer(
  state: UiState<T>,
  emptyTitle: String = "Aucune donnÃ©e",
  emptyHint: String? = "Ajoutez un Ã©lÃ©ment ou rÃ©essayez.",
  // Lâ€™UI finale Ã  afficher quand câ€™est un succÃ¨s non-vide
  success: @Composable (T) -> Unit
) {
  when (state) {
    is UiState.Loading -> LoadingView()
    is UiState.Error   -> ErrorView(message = state.message, onRetry = state.retry)
    is UiState.Success -> {
      val data = state.data
      val isEmptyList = (data is Collection<*>) && data.isEmpty()
      if (isEmptyList) {
        EmptyView(
          title = emptyTitle,
          hint = emptyHint,
          onRetry = state.retry // dispo via fermeture si vous la stockez ailleurs
        )
      } else {
        success(data)
      }
    }
  }
}
```

> ðŸ’¡ Si votre `UiState.Success` ne transporte **pas** de `retry`, vous pouvez aussi passer un `onRetry: (() -> Unit)?` Ã  `StateContainer` et le propager Ã  `EmptyView`.

---

## 4) Exemple dâ€™usage avec la liste `/todos`

> RÃ©utilise la `TodosList` du **chapitre 5.4.3**.

```kotlin
import androidx.compose.runtime.Composable
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.Card
import androidx.compose.material3.Text
import androidx.compose.ui.text.style.TextOverflow

@Composable
fun TodosList(items: List<Todo>, modifier: Modifier = Modifier) {
  LazyColumn(
    modifier = modifier.fillMaxSize().padding(12.dp),
    verticalArrangement = Arrangement.spacedBy(8.dp)
  ) {
    items(items, key = { it.id ?: it.hashCode() }) { todo ->
      Card { Text(todo.title, maxLines = 1, overflow = TextOverflow.Ellipsis, modifier = Modifier.padding(12.dp)) }
    }
  }
}

@Composable
fun TodosScreenWithContainer(state: UiState<List<Todo>>) {
  StateContainer(
    state = state,
    emptyTitle = "Aucune tÃ¢che",
    emptyHint  = "CrÃ©ez votre premiÃ¨re TODO ou appuyez sur Recharger."
  ) { data ->
    TodosList(data)
  }
}
```

---

## 5) Variante avec **Snackbar** (optionnelle)

> Affiche un **snackbar** quand lâ€™Ã©tat devient `Error`, en plus de lâ€™Ã©cran dâ€™erreur.

```kotlin
import androidx.compose.material3.*
import androidx.compose.runtime.*
import android.content.res.Configuration

@Composable
fun TodosRoute(vm: TodosViewModel = androidx.lifecycle.viewmodel.compose.viewModel()) {
  val snackbarHost = remember { SnackbarHostState() }
  val state = vm.state

  LaunchedEffect(state) {
    if (state is UiState.Error) {
      snackbarHost.showSnackbar(state.message)
    }
  }

  Scaffold(snackbarHost = { SnackbarHost(snackbarHost) }) { padding ->
    Box(Modifier.padding(padding)) {
      when (state) {
        is UiState.Loading -> LoadingView()
        is UiState.Error   -> ErrorView(message = state.message, onRetry = { vm.load() })
        is UiState.Success -> {
          if (state.data.isEmpty())
            EmptyView("Aucune tÃ¢che", "Essayez de recharger.", onRetry = { vm.load() })
          else
            TodosList(state.data)
        }
      }
    }
  }
}
```

---

## 6) Previews

```kotlin
import androidx.compose.ui.tooling.preview.Preview

private val sample = listOf(
  Todo(id = 1, userId = 10, title = "Lire la doc Retrofit", completed = false),
  Todo(id = 2, userId = 10, title = "Brancher /todos", completed = true),
)

@Preview(showBackground = true, widthDp = 360)
@Composable
fun Preview_Loading() { LoadingView() }

@Preview(showBackground = true, widthDp = 360)
@Composable
fun Preview_Empty() { EmptyView("Aucune donnÃ©e", "Ajoutez un Ã©lÃ©ment ou rechargez.", onRetry = {}) }

@Preview(showBackground = true, widthDp = 360)
@Composable
fun Preview_Error() { ErrorView("Timeout / Offline", onRetry = {}) }

@Preview(showBackground = true, widthDp = 360)
@Composable
fun Preview_Success() { TodosScreenWithContainer(UiState.Success(sample)) }
```

---

## âœ… Check-list

* [ ] **Loading** visible pendant la requÃªte.
* [ ] **Empty** clair et actionnable (message + bouton).
* [ ] **Error** explicite + **Retry** qui relance la charge.
* [ ] **Container** rÃ©utilisable (autres Ã©crans/lists).
* [ ] **Previews** pour chaque Ã©tat (pas de rÃ©seau).

---

## ðŸ©¹ DÃ©pannage

* **Retry ne fait rien** â†’ vÃ©rifier que le `retry` appelle bien `viewModel.load()`.
* **Empty jamais affichÃ©** â†’ votre `Success` ne transporte pas une **liste** vide ? VÃ©rifiez `isEmpty()`.
* **Snackbar invisible** â†’ assurez-vous dâ€™avoir un `Scaffold` avec `SnackbarHost` et un `LaunchedEffect` sur lâ€™Ã©tat.

---

## ðŸ§ª Exercices

1. Factorisez `StateContainer` dans un module `ui/common`. RÃ©utilisez-le sur un **2áµ‰ Ã©cran**.
2. Ajoutez une **icÃ´ne** (Material) diffÃ©rente pour *Empty* et *Error*.
3. Rendez `EmptyView` **slot-based** (paramÃ¨tres `title`, `hint`, et **slot** `actions`).
