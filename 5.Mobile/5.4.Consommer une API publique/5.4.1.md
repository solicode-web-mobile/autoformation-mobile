---
title: 1. HTTP & JSON
layout: home
nav_order: 1
parent: 5.4. Consommer une API
permalink: /android-api/http-json/
code: 5.4.1
competence: C5
autoformation: "C5.4"
ua: "5.4.U1"
duree_h: 1.5
objectif: "Tester une API REST et d√©duire un sch√©ma JSON pour mapper des data class Kotlin."
notions_nouvelles: ["HTTP", "GET/POST/PATCH/DELETE", "Idempotence", "Headers", "Codes 2xx/4xx/5xx", "JSON Schema", "curl"]
fil_rouge: "App Mobile Compose + API Blog Laravel"
livrable_chapitre: "Fiche endpoints + todo.schema.json + 5 commandes curl (GET/POST/PATCH/DELETE)"
alimentation_prototype: "Contrat d‚ÄôAPI clair et testable"
alimentation_miniprojet: "Base DTO/validation c√¥t√© serveur"
---


# üìò Chapitre 5.4.1 - Rappels HTTP & sch√©ma JSON

## üìí Glossaire minute
- **HTTP** : protocole client ‚Üî serveur (m√©thodes, URL, en-t√™tes, corps).
- **Endpoint** : URL d‚Äôune ressource (ex. `/todos`, `/todos/42`).
- **M√©thodes** : `GET` (lire), `POST` (cr√©er), `PATCH` (modifier partiellement), `DELETE` (supprimer).
- **En-t√™tes** : `Accept`, `Content-Type`, `Authorization`‚Ä¶
- **Body** : contenu JSON envoy√©/re√ßu.
- **Idempotence** : r√©p√©ter l‚Äôop√©ration donne le **m√™me** r√©sultat (`GET`, `DELETE`, `PATCH` cibl√©). `POST` ne l‚Äôest pas.

---

## üéØ Objectif p√©dagogique
Savoir lire une doc d‚ÄôAPI, **tester** ses endpoints, reconna√Ætre les **codes HTTP** et **d√©duire un sch√©ma JSON** pour cr√©er des `data class` Kotlin mapp√©es par Moshi/Gson.

---

## üîé Codes HTTP usuels
- **200 OK** : lecture/modification r√©ussie  
- **201 Created** : cr√©ation r√©ussie (souvent retourne la ressource avec `id`)  
- **204 No Content** : succ√®s **sans** corps (ex. `DELETE`)  
- **400 Bad Request** : donn√©es invalides (validation)  
- **401/403** : non authentifi√© / non autoris√©  
- **404 Not Found** : ressource absente  
- **429 Too Many Requests** : d√©bit limit√©  
- **500+** : erreur serveur

> **PATCH vs PUT** : `PUT` remplace souvent **l‚Äôobjet entier** ; `PATCH` modifie **uniquement** les champs fournis.

---

## üß™ Ressource d‚Äôexemple ‚Äî `Todo`
```json
{
  "id": 1,
  "userId": 10,
  "title": "Acheter du lait",
  "completed": false
}
````

**Contraintes (informelles)**

* `id`: integer (c√¥t√© serveur)
* `userId`: integer ‚â• 1 (**requis**)
* `title`: string 1..120 (**requis**)
* `completed`: boolean (d√©faut `false`)

---

## üõ† Tester les endpoints (avec `curl`)

> Remplacer `https://api.exemple.com` par l‚ÄôAPI choisie.

### 1) GET ‚Äî liste

```bash
curl -i -H "Accept: application/json" \
  "https://api.exemple.com/todos"
```

‚úîÔ∏è `200 OK` + `[]` ou `[ { ... }, ... ]`

### 2) GET ‚Äî d√©tail

```bash
curl -i -H "Accept: application/json" \
  "https://api.exemple.com/todos/1"
```

‚úîÔ∏è `200 OK` + un objet ‚Ä¢ ‚ùå `404 Not Found` si inexistant

### 3) POST ‚Äî cr√©er

```bash
curl -i -X POST "https://api.exemple.com/todos" \
  -H "Content-Type: application/json" \
  -d '{
    "userId": 10,
    "title": "Lire la doc Retrofit",
    "completed": false
  }'
```

‚úîÔ∏è `201 Created` + objet **cr√©√©** (avec `id`)

### 4) PATCH ‚Äî modifier partiellement

```bash
curl -i -X PATCH "https://api.exemple.com/todos/1" \
  -H "Content-Type: application/json" \
  -d '{ "completed": true }'
```

‚úîÔ∏è `200 OK` + objet **mis √† jour**

### 5) DELETE ‚Äî supprimer

```bash
curl -i -X DELETE "https://api.exemple.com/todos/1"
```

‚úîÔ∏è `204 No Content` (pas de corps)

---

## üßæ Fiche ¬´ contrat ¬ª des endpoints (√† placer dans `docs/api/endpoints.md`)

```md
# Endpoints Todos

## GET /todos[?userId={id}&completed={bool}]
- 200 ‚Üí `[Todo]`
- 500 ‚Üí erreur serveur

## GET /todos/{id}
- 200 ‚Üí `Todo`
- 404 ‚Üí Not Found

## POST /todos
- Body JSON : `{ userId:int, title:string, completed?:boolean }`
- 201 ‚Üí `Todo`
- 400 ‚Üí Bad Request (validation)

## PATCH /todos/{id}
- Body JSON (partiel), ex. `{ completed:true }` ou `{ title:"..." }`
- 200 ‚Üí `Todo`
- 400/404

## DELETE /todos/{id}
- 204 ‚Üí No Content
- 404 ‚Üí Not Found
```

---

## üß± Sch√©ma JSON (brouillon) ‚Äî `docs/api/todo.schema.json`

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Todo",
  "type": "object",
  "required": ["userId", "title"],
  "properties": {
    "id": { "type": "integer" },
    "userId": { "type": "integer", "minimum": 1 },
    "title": { "type": "string", "minLength": 1, "maxLength": 120 },
    "completed": { "type": "boolean", "default": false }
  },
  "additionalProperties": false
}
```

---

## üì¶ Data class Kotlin (mapping Moshi/Gson)

```kotlin
data class Todo(
  val id: Int? = null,          // serveur
  val userId: Int,
  val title: String,
  val completed: Boolean = false
)
```

> Si l‚ÄôAPI emploie des noms `snake_case` (`user_id`), utiliser `@Json(name = "user_id")` (Moshi) ou configurer le field naming (Gson).

---

## ‚úÖ Check-list

* [ ] Endpoints test√©s (GET liste/d√©tail, POST, PATCH, DELETE)
* [ ] Codes `200/201/204/400/404` **compris**
* [ ] Sch√©ma JSON r√©dig√© et versionn√© dans `docs/api/`
* [ ] `data class` Kotlin align√©e (nullable si optionnel)

---

## üß™ Exercices rapides

1. Ajouter deux **query params** utiles √† `GET /todos` : `userId` et `completed`.
2. √âcrire 3 commandes `curl` (GET liste, POST, PATCH) et les coller dans `docs/api/endpoints.md`.
3. Rendre `title` **optionnel** c√¥t√© Kotlin, tester le cas `400 Bad Request` (title manquant) et noter le message d‚Äôerreur.

