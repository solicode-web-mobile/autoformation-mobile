---
title: 6. Erreurs r√©seau
layout: home
nav_order: 6
parent: 5.4. Consommer une API
permalink: /android-api-retrofit/errors/
code: 5.4.6
competence: C5
autoformation: "C5.4"
ua: "5.4.U3"
duree_h: 1.5
objectif: "Mapper exceptions ‚Üí messages actionnables (Retry/Undo) sans bloquer l‚ÄôUI."
notions_nouvelles: ["Timeout", "Offline", "HttpException", "NetError", "Outcome", "withTimeout", "ConnectivityObserver", "Snackbar"]
fil_rouge: "App Mobile Compose + API Blog Laravel"
livrable_chapitre: "Mapper NetError + safeApiCall + banni√®re offline + strings.xml + Snackbar Retry"
alimentation_prototype: "Erreurs r√©seau compr√©hensibles et actionnables"
alimentation_miniprojet: "R√©silience (Retry/backoff) int√©gr√©e"
---


# üìò Chapitre 5.4.6 ‚Äî Gestion d‚Äôerreurs r√©seau ## üìí Glossaire minute
- **Timeout** : d√©lai d√©pass√© lors d‚Äôune requ√™te (connexion/lecture/√©criture).
- **Offline** : aucune connectivit√© (mode avion, Wi-Fi coup√©, DNS/routeur indisponible).
- **Snackbar** : message non bloquant avec action (ex. **R√©essayer**).
- **Toast** : notification courte non interactive (feedback ponctuel).
- **Parsing d‚Äôerreur** : extraction d‚Äôun message depuis le corps d‚Äôerreur JSON.

---

## üéØ Objectif p√©dagogique
Savoir **identifier** le type d‚Äôerreur r√©seau (offline, timeout, HTTP‚Ä¶), le **mapper** vers un message **clair et actionnable**, et **proposer une relance** (Retry / Undo) via **Snackbar** ‚Äî sans bloquer l‚ÄôUI.

---

## 1) Typologie d‚Äôerreurs & mod√®le de domaine

```kotlin
sealed class NetError {
  object Offline : NetError()
  object Timeout : NetError()
  data class Http(val code: Int, val body: String?) : NetError()
  data class Unknown(val cause: Throwable) : NetError()
}
````

**Mapping des exceptions ‚Üí `NetError`**

```kotlin
import java.io.IOException
import java.net.ConnectException
import java.net.SocketTimeoutException
import java.net.UnknownHostException
import retrofit2.HttpException

fun Throwable.toNetError(): NetError = when (this) {
  is UnknownHostException,                // DNS/aucun r√©seau
  is ConnectException -> NetError.Offline
  is SocketTimeoutException -> NetError.Timeout
  is HttpException -> NetError.Http(code(), response()?.errorBody()?.string())
  is IOException -> NetError.Offline      // autres I/O assimil√©s √† offline
  else -> NetError.Unknown(this)
}
```

---

## 2) `Outcome` riche (succ√®s/√©chec) et `safeApiCall`

```kotlin
sealed class Outcome<out T> {
  data class Success<T>(val data: T) : Outcome<T>()
  data class Failure(val error: NetError) : Outcome<Nothing>()
}

suspend fun <T> safeApiCall(block: suspend () -> T): Outcome<T> = try {
  Outcome.Success(block())
} catch (t: Throwable) {
  Outcome.Failure(t.toNetError())
}
```

> Si vous utilisez `Retrofit Response<T>`, adaptez :
>
> ```kotlin
> suspend fun <T> safeCallResponse(block: suspend () -> retrofit2.Response<T>): Outcome<T> = try {
>   val res = block()
>   if (res.isSuccessful) Outcome.Success(requireNotNull(res.body()))
>   else Outcome.Failure(NetError.Http(res.code(), res.errorBody()?.string()))
> } catch (t: Throwable) { Outcome.Failure(t.toNetError()) }
> ```

---

## 3) Messages **clairs et actionnables**

**`strings.xml`**

```xml
<resources>
  <string name="err_offline">Hors ligne ‚Äî v√©rifiez votre connexion.</string>
  <string name="err_timeout">Le serveur met trop de temps √† r√©pondre.</string>
  <string name="err_http_generic">Erreur serveur (%1$d).</string>
  <string name="err_unknown">Erreur inconnue.</string>

  <string name="act_retry">R√©essayer</string>
  <string name="act_dismiss">Fermer</string>
</resources>
```

**Mapper l‚Äôerreur vers un message utilisateur**

```kotlin
import android.content.Context

fun NetError.toUserMessage(ctx: Context): String = when (this) {
  NetError.Offline -> ctx.getString(R.string.err_offline)
  NetError.Timeout -> ctx.getString(R.string.err_timeout)
  is NetError.Http -> ctx.getString(R.string.err_http_generic, code)
  is NetError.Unknown -> ctx.getString(R.string.err_unknown)
}
```

---

## 4) Repository : exemples avec **timeouts** & parsing d‚Äôerreurs

> Les **timeouts** sont d√©j√† configur√©s dans `OkHttpClient` (chap. 5.4.2).
> Ici, on ajoute un `withTimeout` applicatif si besoin (ex. 10 s).

```kotlin
import kotlinx.coroutines.withTimeout

class TodoRepository(private val api: ApiService) {

  suspend fun list(userId: Int? = null): Outcome<List<Todo>> = safeCallResponse {
    withTimeout(10_000) { api.getTodos(userId, null) }
  }

  suspend fun create(dto: TodoCreate): Outcome<Todo> = safeCallResponse {
    withTimeout(10_000) { api.createTodo(dto) }
  }

  suspend fun patch(id: Int, patch: TodoPatch): Outcome<Todo> = safeCallResponse {
    withTimeout(10_000) { api.patchTodo(id, patch) }
  }

  suspend fun delete(id: Int): Outcome<Unit> = safeCallResponse {
    withTimeout(10_000) { api.deleteTodo(id) }
  }
}
```

---

## 5) ViewModel : **UiState.Error** + **Retry** + Snackbar

```kotlin
import androidx.compose.runtime.*
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.launch

sealed interface UiState<out T> {
  object Loading : UiState<Nothing>
  data class Success<T>(val data: T) : UiState<T>
  data class Error(val message: String, val retry: () -> Unit) : UiState<Nothing>
}

class TodosErrorVM(
  private val repo: TodoRepository = TodoRepository(NetworkModule.api)
) : ViewModel() {

  var state by mutableStateOf<UiState<List<Todo>>>(UiState.Loading)
    private set

  fun load() {
    state = UiState.Loading
    viewModelScope.launch {
      when (val out = repo.list()) {
        is Outcome.Success -> state = UiState.Success(out.data)
        is Outcome.Failure -> state = UiState.Error(
          message = out.error.toUserMessage(appContext), // fournissez un context via DI/holder
          retry = ::load
        )
      }
    }
  }
}
```

> üí° Fournir `appContext` via une **injection** (Hilt) ou un **provider** pour √©viter de stocker un `Context` dans le VM.

---

## 6) UI : **Scaffold + Snackbar** (avec action **R√©essayer**)

```kotlin
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.platform.LocalContext

@Composable
fun TodosErrorRoute(vm: TodosErrorVM = androidx.lifecycle.viewmodel.compose.viewModel()) {
  val ctx = LocalContext.current
  val host = remember { SnackbarHostState() }
  val s = vm.state

  LaunchedEffect(s) {
    if (s is UiState.Error) {
      val res = host.showSnackbar(
        message = s.message,
        actionLabel = ctx.getString(R.string.act_retry),
        withDismissAction = true
      )
      if (res == SnackbarResult.ActionPerformed) s.retry()
    }
  }

  Scaffold(snackbarHost = { SnackbarHost(host) }) { padding ->
    // Rendu de l‚Äô√©cran (Loading/Empty/Error/Success)
    // R√©utilisez vos vues du chap. 5.4.4
  }
}
```

**Toast ponctuel (feedback bref)**

```kotlin
import android.widget.Toast
import androidx.compose.ui.platform.LocalContext

@Composable
fun ShowToastOnce(message: String) {
  val ctx = LocalContext.current
  LaunchedEffect(message) {
    Toast.makeText(ctx, message, Toast.LENGTH_SHORT).show()
  }
}
```

---

## 7) D√©tecter l‚Äô**offline** proactivement (banni√®re)

> Observer la connectivit√© via `ConnectivityManager` (API 24+) et exposer un `StateFlow<Boolean>`.

```kotlin
import android.content.Context
import android.net.ConnectivityManager
import android.net.Network
import android.net.NetworkCapabilities
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.flow.distinctUntilChanged

class ConnectivityObserver(private val context: Context) {
  val isOnline = callbackFlow<Boolean> {
    val cm = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
    fun current(): Boolean {
      val n = cm.activeNetwork ?: return false
      val caps = cm.getNetworkCapabilities(n) ?: return false
      return caps.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
    }
    trySend(current())
    val cb = object : ConnectivityManager.NetworkCallback() {
      override fun onAvailable(network: Network) { trySend(true) }
      override fun onLost(network: Network) { trySend(current()) }
    }
    cm.registerDefaultNetworkCallback(cb)
    awaitClose { cm.unregisterNetworkCallback(cb) }
  }.distinctUntilChanged()
}
```

**Banni√®re Compose**

```kotlin
@Composable
fun OfflineBanner(online: Boolean) {
  if (!online) {
    Surface(color = MaterialTheme.colorScheme.errorContainer) {
      Text(
        "Hors ligne ‚Äî certaines actions sont indisponibles.",
        modifier = Modifier.padding(12.dp),
        color = MaterialTheme.colorScheme.onErrorContainer
      )
    }
  }
}
```

---

## 8) Bonnes pratiques de **messages**

* **Concrets** : ‚ÄúHors ligne ‚Äî v√©rifiez votre connexion‚Äù (√©viter jargon technique).
* **Actionnables** : proposer **R√©essayer**, **Ouvrir les param√®tres Wi-Fi**, **Annuler**.
* **Brefs** : une ligne si possible (snackbar tronque le long texte).
* **Localis√©s** : via `strings.xml`.

---

## ‚úÖ Check-list

* [ ] Exceptions mapp√©es ‚Üí `NetError` (`Offline`, `Timeout`, `Http`, `Unknown`).
* [ ] `Outcome`/`safeApiCall` centralis√©s ; **pas** de `try/catch` dispers√©s.
* [ ] **Snackbar** avec **action R√©essayer** sur `UiState.Error`.
* [ ] **Toast** pour feedbacks brefs (non interactifs).
* [ ] **Banni√®re offline** observant la connectivit√©.
* [ ] Messages **clairs**, **localis√©s**, **courts**.

---

## ü©π D√©pannage

* **Timeouts r√©currents** ‚Üí allonger `OkHttp` timeouts ET/OU r√©duire payload; tester l‚ÄôAPI via Postman.
* **`UnknownHostException`** ‚Üí DNS/routeur : v√©rifier Wi-Fi/4G, proxy, VPN.
* **Message vide** ‚Üí ne pas oublier `errorBody()?.string()` dans `HttpException`.
* **Boucle de retry** ‚Üí ne **relancez pas automatiquement** sans backoff ; laissez l‚Äôutilisateur d√©cider.
* **Crash contexte** ‚Üí ne stockez pas `Context` dans le ViewModel (injectez un `ResourcesProvider`).

---

## üß™ Exercices

1. Ajouter un **exponential backoff** (1s, 2s, 4s) pour 3 tentatives uniquement sur **timeout**.
2. Afficher un **bouton ‚ÄúParam√®tres Wi-Fi‚Äù** dans la snackbar quand `Offline` (utiliser `Intent(Settings.Panel.ACTION_INTERNET_CONNECTIVITY)`).
3. Parser un **message d‚Äôerreur JSON** (`{"error":"Title is required"}`) et l‚Äôafficher au lieu du message g√©n√©rique.

