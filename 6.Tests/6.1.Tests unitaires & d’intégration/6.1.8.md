---
title: 8. Storage::fake()
layout: home
nav_order: 8
parent: 6.1.Tests unitaires & d’intégration
permalink: /tests-laravel/storage/
code: 6.1.8
competence: C6
autoformation: "C6.1"
ua: "6.1.U3"
duree_h: 1.5
objectif: "Tester end-to-end l’upload d’images : validation, stockage, remplacement et multiple."
notions_nouvelles: ["Storage::fake", "UploadedFile::fake", "assertExists", "assertMissing", "dimensions", "max Ko"]
fil_rouge: "Gestion médias (avatars/galerie) du blog Laravel"
livrable_chapitre: "Tests upload OK/erreurs, remplacement (delete ancien) et upload multiple"
alimentation_prototype: "Médias fiables et régressions évitées"
alimentation_miniprojet: "Flux d’upload sécurisé et vérifié"
---

# 📘 Chapitre 6.1.8 — **Storage::fake()**, `UploadedFile::fake()` : upload d’images testé proprement

## 📒 Glossaire minute
- **`Storage::fake('disk')`** : remplace un **disk** (ex. `public`, `s3`) par un FS **virtuel** isolé pour le test.
- **`UploadedFile::fake()->image()`** : génère un **faux fichier image** (dimensions, taille) pour un POST.
- **`assertExists / assertMissing / assertDirectoryEmpty`** : assertions sur le contenu du **disk fake**.
- **Disk** : cible de stockage définie dans `config/filesystems.php` (`public`, `local`, `s3`…).

---

## 🎯 Objectif
Valider un flux d’upload **de bout en bout** :
1) **Validation** des fichiers (type, taille, dimensions),  
2) **Stockage** sur le **bon disk/chemin**,  
3) **Persistance** du chemin en base,  
4) **Remplacement** (suppression de l’ancien), **upload multiple**.

---

## ✅ Pré-requis
- `.env.testing` simple (ex. `FILESYSTEM_DISK=public`).
- Route/contrôleur minimal, p. ex. `POST /profile/avatar`.

---

## 1) Contrôleur d’exemple — upload d’avatar

```php
<?php // app/Http/Controllers/ProfileAvatarController.php
namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;

class ProfileAvatarController extends Controller
{
    public function store(Request $request)
    {
        $data = $request->validate([
            'avatar' => [
                'required', 'image', 'mimes:jpg,jpeg,png',
                'max:2048', // Ko
                'dimensions:min_width=200,min_height=200'
            ],
        ]);

        $user = $request->user();

        // Supprimer l’ancien fichier si présent
        if ($user->avatar_path) {
            Storage::disk('public')->delete($user->avatar_path);
        }

        // Stocker le nouveau
        $path = $data['avatar']->store('avatars', 'public'); // ex: avatars/abc123.jpg

        $user->update(['avatar_path' => $path]);

        return response()->json(['path' => $path], 201);
    }
}
````

> Astuce : utilisez `storeAs('avatars', $name, 'public')` si vous devez **imposer** un nom.

---

## 2) Test **Pest** — upload réussi (Storage + DB)

```php
<?php // tests/Feature/Upload/AvatarUploadTest.php

use App\Models\User;
use Illuminate\Http\UploadedFile;
use Illuminate\Support\Facades\Storage;
use Illuminate\Foundation\Testing\RefreshDatabase;

uses(RefreshDatabase::class);

it('uploade et enregistre un avatar dans le disk public', function () {
    Storage::fake('public');
    $user = User::factory()->create();

    $file = UploadedFile::fake()->image('avatar.jpg', 600, 600)->size(500); // 500 Ko

    $resp = $this->actingAs($user)->postJson('/profile/avatar', ['avatar' => $file]);

    $resp->assertCreated()->assertJsonStructure(['path']);
    $path = $resp->json('path');

    Storage::disk('public')->assertExists($path);
    $this->assertDatabaseHas('users', ['id' => $user->id, 'avatar_path' => $path]);
});
```

---

## 3) Test **PHPUnit** — remplacement (delete ancien + assertMissing)

```php
<?php // tests/Feature/Upload/AvatarReplaceTest.php

use Tests\TestCase;
use App\Models\User;
use Illuminate\Http\UploadedFile;
use Illuminate\Support\Facades\Storage;
use Illuminate\Foundation\Testing\RefreshDatabase;

class AvatarReplaceTest extends TestCase
{
    use RefreshDatabase;

    public function test_remplace_et_supprime_l_ancien_avatar(): void
    {
        Storage::fake('public');
        $user = User::factory()->create();

        // 1er upload
        $first = UploadedFile::fake()->image('a1.png', 300, 300);
        $this->actingAs($user)->postJson('/profile/avatar', ['avatar' => $first])->assertCreated();
        $oldPath = $user->fresh()->avatar_path;
        Storage::disk('public')->assertExists($oldPath);

        // 2e upload
        $second = UploadedFile::fake()->image('a2.png', 300, 300);
        $this->actingAs($user)->postJson('/profile/avatar', ['avatar' => $second])->assertCreated();
        $newPath = $user->fresh()->avatar_path;

        Storage::disk('public')->assertMissing($oldPath);
        Storage::disk('public')->assertExists($newPath);
        $this->assertNotEquals($oldPath, $newPath);
    }
}
```

---

## 4) **Validation** (type/poids/dimensions) : cas d’erreurs

```php
<?php // tests/Feature/Upload/AvatarValidationTest.php

use Tests\TestCase;
use App\Models\User;
use Illuminate\Http\UploadedFile;
use Illuminate\Support\Facades\Storage;
use Illuminate\Foundation\Testing\RefreshDatabase;

class AvatarValidationTest extends TestCase
{
    use RefreshDatabase;

    public function test_refuse_un_fichier_non_image(): void
    {
        Storage::fake('public');
        $user = User::factory()->create();
        $pdf = UploadedFile::fake()->create('doc.pdf', 100, 'application/pdf');

        $this->actingAs($user)->post('/profile/avatar', ['avatar' => $pdf])
             ->assertStatus(302) // route web -> redirection + erreurs
             ->assertSessionHasErrors(['avatar']);

        Storage::disk('public')->assertDirectoryEmpty('avatars');
    }

    public function test_refuse_image_trop_pesante_ou_trop_petite(): void
    {
        Storage::fake('public');
        $user = User::factory()->create();

        $heavy = UploadedFile::fake()->image('big.jpg', 3000, 3000)->size(4096); // 4 Mo
        $small = UploadedFile::fake()->image('small.jpg', 100, 100)->size(50);

        $this->actingAs($user)->postJson('/profile/avatar', ['avatar' => $heavy])->assertStatus(422);
        $this->actingAs($user)->postJson('/profile/avatar', ['avatar' => $small])->assertStatus(422);
    }
}
```

---

## 5) Upload **multiple** (galerie)

### Contrôleur (exemple)

```php
public function storeMany(Request $request)
{
    $data = $request->validate([
        'photos'   => ['required', 'array', 'min:1'],
        'photos.*' => ['image', 'mimes:jpg,jpeg,png', 'max:4096'],
    ]);

    $paths = [];
    foreach ($data['photos'] as $photo) {
        $paths[] = $photo->store('gallery', 'public');
    }

    return response()->json(['paths' => $paths], 201);
}
```

### Test

```php
<?php // tests/Feature/Upload/GalleryUploadTest.php

use Illuminate\Support\Facades\Storage;
use Illuminate\Http\UploadedFile;
use Illuminate\Foundation\Testing\RefreshDatabase;

uses(RefreshDatabase::class);

it('uploade plusieurs images', function () {
    Storage::fake('public');

    $files = [
        UploadedFile::fake()->image('p1.jpg', 800, 600),
        UploadedFile::fake()->image('p2.jpg', 1024, 768),
    ];

    $resp = $this->postJson('/gallery', ['photos' => $files])
                 ->assertCreated()
                 ->assertJsonCount(2, 'paths');

    foreach ($resp->json('paths') as $p) {
        Storage::disk('public')->assertExists($p);
    }
});
```

---

## 6) Disks personnalisés (ex. S3) — fakes & headers

```php
Storage::fake('s3');

// ... action qui stocke sur 's3'
$path = 'uploads/img.jpg';
Storage::disk('s3')->put($path, 'dummy');

Storage::disk('s3')->assertExists($path);
Storage::disk('s3')->assertMissing('uploads/ghost.jpg');
```

> Même avec S3, `fake('s3')` reste local et **très rapide**.
> Si vous exigez `Accept: application/json` sur des routes API, n’oubliez pas `->postJson()`/`->withHeaders(['Accept' => 'application/json'])`.

---

## 7) Cheatsheet

```php
// Fakes
Storage::fake('public');
$file = UploadedFile::fake()->image('x.jpg', 800, 600)->size(700);

// Upload simple
$this->postJson('/upload', ['file' => $file])->assertCreated();

// Assertions
Storage::disk('public')->assertExists('dir/name.jpg');
Storage::disk('public')->assertMissing('dir/old.jpg');
Storage::disk('public')->assertDirectoryEmpty('dir');

// Nom imposé
$file->storeAs('avatars', 'fixed-name.jpg', 'public');

// Validation erreurs
$this->post('/upload', ['file' => UploadedFile::fake()->create('evil.exe', 10)])
     ->assertStatus(302)->assertSessionHasErrors(['file']);
```

---

## ✅ Check-list (DoD)

* [ ] `Storage::fake()` activé dans **chaque test** d’upload.
* [ ] `UploadedFile::fake()->image()` utilisé avec **taille/dimensions** pertinentes.
* [ ] Assertions **Storage** (`assertExists/Missing/DirectoryEmpty`) et **DB** (chemin persistant).
* [ ] Cas **remplacement** couvert (suppression ancien fichier).
* [ ] Cas **multiple** couvert (tableau d’images).

---

## 🩹 Dépannage

* **“Le fichier n’existe pas”** → avez-vous bien lu le **chemin renvoyé** par `store()` (relatif) ? Utilisez le même disk dans l’assertion.
* **Validation incohérente** → attention : `max` est en **Ko** ; `dimensions` vérifie **pixels**.
* **Chemins vides en DB** → persistez le **chemin retourné** par `store()` (pas le nom d’origine).
* **Mélange web/API** → pour JSON, utilisez `postJson()` (sinon 302 + erreurs de session).
* **Tests non isolés** → toujours `Storage::fake()` (sinon fichiers écrits réellement sur votre machine).

---

## 🧪 Exercices

1. Ajouter `storeAs` pour enregistrer l’avatar sous `user_{id}.jpg` et tester que le **chemin est déterministe**.
2. Écrire un test qui refuse **GIF** et **> 2 Mo**, et qui vérifie `assertDirectoryEmpty('avatars')`.
3. Créer une action **DELETE** qui supprime l’avatar courant et tester `assertMissing()` + mise à jour DB (`avatar_path = null`).

