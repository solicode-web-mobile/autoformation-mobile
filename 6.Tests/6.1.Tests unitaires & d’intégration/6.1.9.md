---
title: 9. Mocks lÃ©gers via le container
permalink: /tests-laravel/container-mocks-stubs/
layout: home
nav_order: 9
parent: 6.1.Tests unitaires & dâ€™intÃ©gration
---

# ğŸ“˜ Chapitre 6.1.9 â€” Espionnage / mocks lÃ©gers via le **container**

> Remplacer une dÃ©pendance (service) par un **stub**, un **mock** ou un **spy** au niveau du **container IoC** pour tester sans effet externe.

## ğŸ“’ Glossaire minute
- **Stub** : implÃ©mentation **minimale** qui renvoie une rÃ©ponse dÃ©terministe (pas dâ€™assertions).
- **Mock** : double avec **attentes** (ex. â€œappelÃ© 1x avec tels argumentsâ€).
- **Spy** : **enregistre** les appels pour vÃ©rification **aprÃ¨s coup**.
- **Binding** : enregistrement dâ€™une implÃ©mentation dans le **container** (`bind/instance/swap`).

---

## ğŸ¯ Objectif
1) **Isoler** votre SUT en remplaÃ§ant une dÃ©pendance via le **container**.  
2) Choisir entre **stub**, **mock**, **spy** selon le besoin de vÃ©rification.  
3) Ã‰crire des tests **lisibles** sans toucher au code de prod (inversion de dÃ©pendances).

---

## 1) Exemple de domaine
On teste un `CheckoutService` qui dÃ©pend dâ€™un **paiement**.

```php
<?php // app/Payments/PaymentGateway.php
namespace App\Payments;

interface PaymentGateway {
    public function charge(int $amountCents, string $currency, array $meta = []): string; // retourne payment_id
}
````

```php
<?php // app/Payments/StripePaymentGateway.php
namespace App\Payments;

class StripePaymentGateway implements PaymentGateway {
    public function charge(int $amountCents, string $currency, array $meta = []): string {
        // appel rÃ©seau vers Stripe (omise)
        return 'ch_fake_123';
    }
}
```

```php
<?php // app/Services/CheckoutService.php
namespace App\Services;

use App\Payments\PaymentGateway;

class CheckoutService {
    public function __construct(private PaymentGateway $gateway) {}
    public function checkout(int $amount, string $currency): string {
        return $this->gateway->charge($amount, $currency, ['source' => 'web']);
    }
}
```

Dans un provider de prod :

```php
// app/Providers/AppServiceProvider.php
$this->app->bind(\App\Payments\PaymentGateway::class, \App\Payments\StripePaymentGateway::class);
```

---

## 2) **Stub minimal** (implÃ©mentation â€œmaisonâ€ pour test)

```php
<?php // tests/Doubles/FakePaymentGateway.php
namespace Tests\Doubles;

use App\Payments\PaymentGateway;

class FakePaymentGateway implements PaymentGateway {
    public array $calls = []; // pour inspection
    public function __construct(private ?\Throwable $toThrow = null, private string $returnId = 'test_1') {}
    public function charge(int $amountCents, string $currency, array $meta = []): string {
        $this->calls[] = compact('amountCents','currency','meta');
        if ($this->toThrow) { throw $this->toThrow; }
        return $this->returnId;
    }
}
```

### Test (Pest) â€” binding via **instance**

```php
<?php // tests/Unit/CheckoutServiceTest.php

use App\Services\CheckoutService;
use App\Payments\PaymentGateway;
use Tests\Doubles\FakePaymentGateway;

it('utilise le gateway et retourne un payment_id', function () {
    $fake = new FakePaymentGateway(returnId: 'pay_42');
    app()->instance(PaymentGateway::class, $fake); // override binding

    $svc = app(CheckoutService::class);
    $id = $svc->checkout(1999, 'EUR');

    expect($id)->toBe('pay_42');
    expect($fake->calls)->toHaveCount(1)
        ->and($fake->calls[0]['amountCents'])->toBe(1999)
        ->and($fake->calls[0]['currency'])->toBe('EUR');
});
```

> Avantages : **simple**, pas de DSL de mocking, lisible.
> InconvÃ©nients : nÃ©cessite une petite classe **Fake** (souvent utile et rÃ©utilisable).

---

## 3) **Mock** (attentes directes) avec **Mockery** / helper `mock()`

```php
<?php // tests/Unit/CheckoutServiceMockTest.php

use App\Services\CheckoutService;
use App\Payments\PaymentGateway;

it('charge avec les bons paramÃ¨tres (Mockery)', function () {
    $mock = mock(PaymentGateway::class, function ($m) {
        $m->shouldReceive('charge')
          ->once()
          ->withArgs(function (int $amount, string $currency, array $meta) {
              return $amount === 1999 && $currency === 'EUR' && ($meta['source'] ?? null) === 'web';
          })
          ->andReturn('pay_007');
    });

    app()->instance(PaymentGateway::class, $mock);

    $svc = app(CheckoutService::class);
    expect($svc->checkout(1999, 'EUR'))->toBe('pay_007');
});
```

> `mock()` est un helper Laravel (sugar pour Mockery).
> Les **attentes** sont vÃ©rifiÃ©es **automatiquement** en fin de test.

---

## 4) **Spy** (enregistrer puis vÃ©rifier)

```php
<?php // tests/Unit/CheckoutServiceSpyTest.php

use App\Services\CheckoutService;
use App\Payments\PaymentGateway;
use Mockery;

it('enregistre les appels (spy)', function () {
    $spy = Mockery::spy(PaymentGateway::class);
    $spy->shouldReceive('charge')->andReturn('pay_spy'); // pas dâ€™attente de quantitÃ© ici

    app()->instance(PaymentGateway::class, $spy);

    app(CheckoutService::class)->checkout(500, 'EUR');

    $spy->shouldHaveReceived('charge')
        ->withArgs(fn ($a,$c,$m) => $a === 500 && $c === 'EUR' && ($m['source'] ?? null) === 'web')
        ->once();
});
```

> Le **spy** est utile quand vous voulez **dâ€™abord appeler**, **puis** vÃ©rifier avec souplesse.

---

## 5) Variantes de **binding** pratique

```php
// 1) Fournir une instance directement (le plus courant en test)
app()->instance(PaymentGateway::class, $fakeOrMock);

// 2) Fournir une factory (closure) â€” sera Ã©valuÃ©e Ã  la rÃ©solution
app()->bind(PaymentGateway::class, fn () => new FakePaymentGateway());

// 3) swap â€œone-linerâ€
app()->swap(PaymentGateway::class, fn () => new FakePaymentGateway());

// 4) Partager une mÃªme instance
app()->singleton(PaymentGateway::class, fn () => new FakePaymentGateway());
```

> En test, prÃ©fÃ©rez **`instance()`** pour une **instance contrÃ´lÃ©e** par le test.

---

## 6) IntÃ©gration **Feature** (route â†’ service â†’ gateway)

```php
<?php // tests/Feature/CheckoutFlowTest.php

use Tests\Doubles\FakePaymentGateway;
use App\Payments\PaymentGateway;
use Illuminate\Foundation\Testing\RefreshDatabase;

uses(RefreshDatabase::class);

it('retourne 201 et le payment_id', function () {
    $fake = new FakePaymentGateway(returnId: 'ok_1');
    app()->instance(PaymentGateway::class, $fake);

    $resp = $this->postJson('/api/checkout', ['amount' => 1999, 'currency' => 'EUR']);

    $resp->assertCreated()->assertJsonPath('payment_id', 'ok_1');
    expect($fake->calls)->toHaveCount(1);
});
```

---

## 7) Cheatsheet

```php
// STUB (classe Fake simple)
$fake = new FakeService(); app()->instance(Contract::class, $fake);

// MOCK (attentes fermes)
$mock = mock(Contract::class, fn ($m) =>
    $m->shouldReceive('foo')->once()->with('x')->andReturn('y')
);
app()->instance(Contract::class, $mock);

// SPY (vÃ©rifier aprÃ¨s)
$spy = \Mockery::spy(Contract::class);
$spy->shouldReceive('foo')->andReturn('y');
app()->instance(Contract::class, $spy);
// ... action ...
$spy->shouldHaveReceived('foo')->with('x')->once();
```

---

## âœ… Check-list (DoD)

* [ ] DÃ©pendances **injectÃ©es** par **interface/contrat** (facile Ã  remplacer).
* [ ] Test remplace la dÃ©pendance via `app()->instance()` (ou `bind`).
* [ ] Cas **stub** (retour dÃ©terministe) + **mock** (attentes) + **spy** (vÃ©rification a posteriori).
* [ ] Assertions couvrent **arguments**, **compteur dâ€™appels** et **valeur de retour**.

---

## ğŸ©¹ DÃ©pannage

* **â€œClass â€¦ is not instantiableâ€** â†’ liez lâ€™interface au fake : `app()->instance(Contract::class, $fake)`.
* **Attentes Mockery non vÃ©rifiÃ©es** â†’ le test nâ€™a pas fini (exception levÃ©e avant) ou la mÃ©thode nâ€™a pas Ã©tÃ© appelÃ©e.
* **Ã‰tat partagÃ© entre tests** â†’ ne mettez pas un `singleton` global; prÃ©fÃ©rez `instance()` **par test**.
* **Couche rÃ©seau appelÃ©e quand mÃªme** â†’ assurez-vous que votre SUT **type-hinte** lâ€™**interface** et pas la classe concrÃ¨te.

---

## ğŸ§ª Exercices

1. CrÃ©ez `SmsGateway` (contrat) + `FakeSmsGateway` (enregistre les messages). Testez que `UserService::send2FA()` lâ€™appelle avec le bon numÃ©ro.
2. Convertissez un test basÃ© sur `Http::fake()` en version **container** en introduisant un `WeatherClient` **contrat** + fake.
3. Ã‰crivez un test **spy** qui vÃ©rifie que `InvoiceService::pay()` appelle `PaymentGateway::charge()` **une seule fois** mÃªme en cas de double-clic (idempotence cÃ´tÃ© service).

