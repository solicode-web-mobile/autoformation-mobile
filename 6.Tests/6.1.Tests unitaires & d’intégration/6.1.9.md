---
title: 9. Mocks légers via le container
permalink: /tests-laravel/container-mocks-stubs/
layout: home
nav_order: 9
parent: 6.1.Tests unitaires & d’intégration
---

# 📘 Chapitre 6.1.9 — Espionnage / mocks légers via le **container**

> Remplacer une dépendance (service) par un **stub**, un **mock** ou un **spy** au niveau du **container IoC** pour tester sans effet externe.

## 📒 Glossaire minute
- **Stub** : implémentation **minimale** qui renvoie une réponse déterministe (pas d’assertions).
- **Mock** : double avec **attentes** (ex. “appelé 1x avec tels arguments”).
- **Spy** : **enregistre** les appels pour vérification **après coup**.
- **Binding** : enregistrement d’une implémentation dans le **container** (`bind/instance/swap`).

---

## 🎯 Objectif
1) **Isoler** votre SUT en remplaçant une dépendance via le **container**.  
2) Choisir entre **stub**, **mock**, **spy** selon le besoin de vérification.  
3) Écrire des tests **lisibles** sans toucher au code de prod (inversion de dépendances).

---

## 1) Exemple de domaine
On teste un `CheckoutService` qui dépend d’un **paiement**.

```php
<?php // app/Payments/PaymentGateway.php
namespace App\Payments;

interface PaymentGateway {
    public function charge(int $amountCents, string $currency, array $meta = []): string; // retourne payment_id
}
````

```php
<?php // app/Payments/StripePaymentGateway.php
namespace App\Payments;

class StripePaymentGateway implements PaymentGateway {
    public function charge(int $amountCents, string $currency, array $meta = []): string {
        // appel réseau vers Stripe (omise)
        return 'ch_fake_123';
    }
}
```

```php
<?php // app/Services/CheckoutService.php
namespace App\Services;

use App\Payments\PaymentGateway;

class CheckoutService {
    public function __construct(private PaymentGateway $gateway) {}
    public function checkout(int $amount, string $currency): string {
        return $this->gateway->charge($amount, $currency, ['source' => 'web']);
    }
}
```

Dans un provider de prod :

```php
// app/Providers/AppServiceProvider.php
$this->app->bind(\App\Payments\PaymentGateway::class, \App\Payments\StripePaymentGateway::class);
```

---

## 2) **Stub minimal** (implémentation “maison” pour test)

```php
<?php // tests/Doubles/FakePaymentGateway.php
namespace Tests\Doubles;

use App\Payments\PaymentGateway;

class FakePaymentGateway implements PaymentGateway {
    public array $calls = []; // pour inspection
    public function __construct(private ?\Throwable $toThrow = null, private string $returnId = 'test_1') {}
    public function charge(int $amountCents, string $currency, array $meta = []): string {
        $this->calls[] = compact('amountCents','currency','meta');
        if ($this->toThrow) { throw $this->toThrow; }
        return $this->returnId;
    }
}
```

### Test (Pest) — binding via **instance**

```php
<?php // tests/Unit/CheckoutServiceTest.php

use App\Services\CheckoutService;
use App\Payments\PaymentGateway;
use Tests\Doubles\FakePaymentGateway;

it('utilise le gateway et retourne un payment_id', function () {
    $fake = new FakePaymentGateway(returnId: 'pay_42');
    app()->instance(PaymentGateway::class, $fake); // override binding

    $svc = app(CheckoutService::class);
    $id = $svc->checkout(1999, 'EUR');

    expect($id)->toBe('pay_42');
    expect($fake->calls)->toHaveCount(1)
        ->and($fake->calls[0]['amountCents'])->toBe(1999)
        ->and($fake->calls[0]['currency'])->toBe('EUR');
});
```

> Avantages : **simple**, pas de DSL de mocking, lisible.
> Inconvénients : nécessite une petite classe **Fake** (souvent utile et réutilisable).

---

## 3) **Mock** (attentes directes) avec **Mockery** / helper `mock()`

```php
<?php // tests/Unit/CheckoutServiceMockTest.php

use App\Services\CheckoutService;
use App\Payments\PaymentGateway;

it('charge avec les bons paramètres (Mockery)', function () {
    $mock = mock(PaymentGateway::class, function ($m) {
        $m->shouldReceive('charge')
          ->once()
          ->withArgs(function (int $amount, string $currency, array $meta) {
              return $amount === 1999 && $currency === 'EUR' && ($meta['source'] ?? null) === 'web';
          })
          ->andReturn('pay_007');
    });

    app()->instance(PaymentGateway::class, $mock);

    $svc = app(CheckoutService::class);
    expect($svc->checkout(1999, 'EUR'))->toBe('pay_007');
});
```

> `mock()` est un helper Laravel (sugar pour Mockery).
> Les **attentes** sont vérifiées **automatiquement** en fin de test.

---

## 4) **Spy** (enregistrer puis vérifier)

```php
<?php // tests/Unit/CheckoutServiceSpyTest.php

use App\Services\CheckoutService;
use App\Payments\PaymentGateway;
use Mockery;

it('enregistre les appels (spy)', function () {
    $spy = Mockery::spy(PaymentGateway::class);
    $spy->shouldReceive('charge')->andReturn('pay_spy'); // pas d’attente de quantité ici

    app()->instance(PaymentGateway::class, $spy);

    app(CheckoutService::class)->checkout(500, 'EUR');

    $spy->shouldHaveReceived('charge')
        ->withArgs(fn ($a,$c,$m) => $a === 500 && $c === 'EUR' && ($m['source'] ?? null) === 'web')
        ->once();
});
```

> Le **spy** est utile quand vous voulez **d’abord appeler**, **puis** vérifier avec souplesse.

---

## 5) Variantes de **binding** pratique

```php
// 1) Fournir une instance directement (le plus courant en test)
app()->instance(PaymentGateway::class, $fakeOrMock);

// 2) Fournir une factory (closure) — sera évaluée à la résolution
app()->bind(PaymentGateway::class, fn () => new FakePaymentGateway());

// 3) swap “one-liner”
app()->swap(PaymentGateway::class, fn () => new FakePaymentGateway());

// 4) Partager une même instance
app()->singleton(PaymentGateway::class, fn () => new FakePaymentGateway());
```

> En test, préférez **`instance()`** pour une **instance contrôlée** par le test.

---

## 6) Intégration **Feature** (route → service → gateway)

```php
<?php // tests/Feature/CheckoutFlowTest.php

use Tests\Doubles\FakePaymentGateway;
use App\Payments\PaymentGateway;
use Illuminate\Foundation\Testing\RefreshDatabase;

uses(RefreshDatabase::class);

it('retourne 201 et le payment_id', function () {
    $fake = new FakePaymentGateway(returnId: 'ok_1');
    app()->instance(PaymentGateway::class, $fake);

    $resp = $this->postJson('/api/checkout', ['amount' => 1999, 'currency' => 'EUR']);

    $resp->assertCreated()->assertJsonPath('payment_id', 'ok_1');
    expect($fake->calls)->toHaveCount(1);
});
```

---

## 7) Cheatsheet

```php
// STUB (classe Fake simple)
$fake = new FakeService(); app()->instance(Contract::class, $fake);

// MOCK (attentes fermes)
$mock = mock(Contract::class, fn ($m) =>
    $m->shouldReceive('foo')->once()->with('x')->andReturn('y')
);
app()->instance(Contract::class, $mock);

// SPY (vérifier après)
$spy = \Mockery::spy(Contract::class);
$spy->shouldReceive('foo')->andReturn('y');
app()->instance(Contract::class, $spy);
// ... action ...
$spy->shouldHaveReceived('foo')->with('x')->once();
```

---

## ✅ Check-list (DoD)

* [ ] Dépendances **injectées** par **interface/contrat** (facile à remplacer).
* [ ] Test remplace la dépendance via `app()->instance()` (ou `bind`).
* [ ] Cas **stub** (retour déterministe) + **mock** (attentes) + **spy** (vérification a posteriori).
* [ ] Assertions couvrent **arguments**, **compteur d’appels** et **valeur de retour**.

---

## 🩹 Dépannage

* **“Class … is not instantiable”** → liez l’interface au fake : `app()->instance(Contract::class, $fake)`.
* **Attentes Mockery non vérifiées** → le test n’a pas fini (exception levée avant) ou la méthode n’a pas été appelée.
* **État partagé entre tests** → ne mettez pas un `singleton` global; préférez `instance()` **par test**.
* **Couche réseau appelée quand même** → assurez-vous que votre SUT **type-hinte** l’**interface** et pas la classe concrète.

---

## 🧪 Exercices

1. Créez `SmsGateway` (contrat) + `FakeSmsGateway` (enregistre les messages). Testez que `UserService::send2FA()` l’appelle avec le bon numéro.
2. Convertissez un test basé sur `Http::fake()` en version **container** en introduisant un `WeatherClient` **contrat** + fake.
3. Écrivez un test **spy** qui vérifie que `InvoiceService::pay()` appelle `PaymentGateway::charge()` **une seule fois** même en cas de double-clic (idempotence côté service).

