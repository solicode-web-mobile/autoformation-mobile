---
title: 7. Fakes du framework
permalink: /tests-laravel/fakes-mail-notification-event/
layout: home
nav_order: 7
parent: 6.1.Tests unitaires & d’intégration
---

# 📘 Chapitre 6.1.7 — Fakes du framework

## 📒 Glossaire minute
- **Fake** : remplace un service réel (Mail/Notification/Event) par un **double** qui **enregistre** les actions au lieu d’exécuter l’effet (envoi mail, push, diffusion d’événement).
- **Assertion** : vérification qu’un **mailable/notification/événement** a été (ou non) déclenché.
- **On-demand** (notifications) : notification envoyée **sans modèle** utilisateur, via `Notification::route(...)`.

---

## 🎯 Objectif
Savoir **isoler** vos tests des effets extérieurs et **prouver** que votre code a tenté d’envoyer :
1) un **mail** (`Mail::fake()` + `Mail::assertSent/Queued`),  
2) une **notification** (`Notification::fake()` + `Notification::assertSentTo`),  
3) un **événement** (`Event::fake()` + `Event::assertDispatched`).  

---

## ✅ Pré-requis
- `RefreshDatabase` (chap. 6.1.4).  
- Un flux métier minimal qui **envoie** un mail/notification/événement (ex. inscription utilisateur, commande expédiée).

---

## 1) **Mail::fake()** — tester l’envoi d’e-mails

### Exemple (Pest) — mailable envoyé à l’inscription
```php
<?php // tests/Feature/Mail/WelcomeMailTest.php

use Illuminate\Support\Facades\Mail;
use Illuminate\Foundation\Testing\RefreshDatabase;
use App\Mail\WelcomeMail;
use App\Models\User;

uses(RefreshDatabase::class);

it('envoie un mail de bienvenue à la création du compte', function () {
    Mail::fake(); // 1) remplacer le transport réel

    // 2) Act — votre code métier
    $user = User::factory()->create(); // suppose un observer/job qui envoie WelcomeMail

    // 3) Assert — le mailable a bien été envoyé AU bon destinataire
    Mail::assertSent(WelcomeMail::class, function (WelcomeMail $mail) use ($user) {
        return $mail->hasTo($user->email);
    });

    // Rien d’autre n’a été envoyé ?
    Mail::assertNotSent(\App\Mail\OtherMail::class);
});
````

### Variantes utiles

```php
Mail::assertSent(WelcomeMail::class, 1);               // exactement 1 envoi
Mail::assertNothingSent();                             // aucun mail
Mail::assertQueued(WelcomeMail::class);                // si vous utilisez ->queue()
Mail::assertNotQueued(WelcomeMail::class);
```

> 💡 Avec `assertSent/Queued`, vous pouvez **inspecter** le mailable (sujet, variables de vue, pièces jointes) dans la closure.

---

## 2) **Notification::fake()** — tester les notifications

### Exemple (PHPUnit) — notification de réinitialisation de mot de passe

```php
<?php // tests/Feature/Notification/ResetPasswordTest.php

use Tests\TestCase;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Support\Facades\Notification;
use App\Models\User;
use App\Notifications\ResetPasswordNotification;

class ResetPasswordTest extends TestCase
{
    use RefreshDatabase;

    public function test_envoie_notification_reset_password(): void
    {
        Notification::fake();

        $user = User::factory()->create();
        // Act — déclencher votre logic (ex: POST /forgot-password)
        $this->post('/forgot-password', ['email' => $user->email])->assertStatus(302);

        Notification::assertSentTo(
            $user,
            ResetPasswordNotification::class,
            function (ResetPasswordNotification $n, array $channels) {
                return in_array('mail', $channels)
                    && !empty($n->token); // exemple d’inspection
            }
        );

        Notification::assertNotSentTo($user, \App\Notifications\OtherNotification::class);
    }
}
```

### On-demand & nothing sent

```php
Notification::route('mail', 'client@example.com')->notify(new \App\Notifications\InvoicePaid());
Notification::assertSentOnDemand(\App\Notifications\InvoicePaid::class, function ($n, $channels, $notifiable) {
    return $notifiable->routes['mail'] === 'client@example.com';
});

Notification::assertNothingSent(); // aucune notification envoyée
```

---

## 3) **Event::fake()** — tester la diffusion d’événements

### Exemple (Pest) — événement métier `OrderShipped` dispatché

```php
<?php // tests/Feature/Event/OrderShippedTest.php

use Illuminate\Support\Facades\Event;
use Illuminate\Foundation\Testing\RefreshDatabase;
use App\Events\OrderShipped;
use App\Models\Order;

uses(RefreshDatabase::class);

it('diffuse l’événement OrderShipped lors de l’expédition', function () {
    Event::fake(); // remplace le dispatcher

    $order = Order::factory()->create(['status' => 'paid']);

    // Act — votre service de shipment
    app(\App\Services\ShippingService::class)->ship($order);

    // Assert — l’événement a été dispatché avec les bonnes données
    Event::assertDispatched(OrderShipped::class, function (OrderShipped $e) use ($order) {
        return $e->order->is($order);
    });

    Event::assertNotDispatched(\App\Events\OrderCancelled::class);
});
```

### Fakes sélectifs (utile quand certains listeners doivent rester actifs)

```php
Event::fake([OrderShipped::class]);      // ne fake QUE ces événements
Event::fakeExcept([OrderShipped::class]); // fake tout SAUF ceux-ci
Event::assertNothingDispatched();        // aucun événement
// Bonus : vérifier le wiring d’un listener
Event::assertListening(OrderShipped::class, \App\Listeners\SendShipmentEmail::class);
```

---

## 4) Modèles courants (patrons de test)

### a) *Arrange* minimal + *Act* via action HTTP

```php
Mail::fake();
Notification::fake();
Event::fake();

$response = $this->actingAs($user)->post('/orders/checkout', $payload);

$response->assertRedirect(route('orders.show', $order));
// … puis assertions Mail/Notification/Event
```

### b) Assertions de **quantité**

```php
Mail::assertSent(WelcomeMail::class, 1);
Notification::assertSentTo($user, ResetPasswordNotification::class, 1);
Event::assertDispatched(OrderShipped::class, 1);
```

### c) Assertions **négatives** (sécurité)

```php
Mail::assertNotSent(BadNewsMail::class);
Notification::assertNothingSent();
Event::assertNotDispatched(InternalEvent::class);
```

---

## 5) Cheatsheet

```php
// MAIL
Mail::fake();
Mail::assertSent(Mailable::class, fn ($m) => $m->hasTo('user@example.com'));
Mail::assertQueued(Mailable::class);
Mail::assertNothingSent();

// NOTIFICATION
Notification::fake();
Notification::assertSentTo($user, NotificationClass::class, fn ($n, $ch) => in_array('mail', $ch));
Notification::assertSentOnDemand(NotificationClass::class);
Notification::assertNothingSent();

// EVENT
Event::fake();                    // ou Event::fake([Only::class]) / fakeExcept([...])
Event::assertDispatched(EventClass::class, fn ($e) => $e->id === 123);
Event::assertNotDispatched(EventClass::class);
Event::assertNothingDispatched();
Event::assertListening(EventClass::class, ListenerClass::class);
```

---

## ✅ Check-list (DoD)

* [ ] Les **fakes** sont activés **avant** l’action testée.
* [ ] Au moins **1 test mail** avec `assertSent` ou `assertQueued`.
* [ ] Au moins **1 test notification** avec `assertSentTo` (ou `assertSentOnDemand`).
* [ ] Au moins **1 test événement** avec `assertDispatched`.
* [ ] Les assertions **inspectent** les données (destinataire, canaux, payload).

---

## 🩹 Dépannage

* **L’assertion échoue “rien envoyé”** → avez-vous bien appelé `Mail::fake()`/`Notification::fake()`/`Event::fake()` **avant** l’action ?
* **`assertQueued` ne passe pas** → votre code utilise `.send()` (synchrone). Utilisez `.queue()` ou testez `assertSent`.
* **Listeners nécessaires ignorés** → utilisez `Event::fakeExcept([...])` pour laisser passer certains listeners.
* **Dépend de la file/queue** → forcer `QUEUE_CONNECTION=sync` dans `.env.testing` pour simplifier.
* **Tests fragiles au contenu HTML de mail** → préférez vérifier le **destinataire/sujet/données** plutôt que l’HTML rendu.

---

## 🧪 Exercices

1. À la création d’un **Article**, envoyer `ArticlePublished` (event) → tester `Event::assertDispatched` et le **listener** enregistré.
2. Implémentez `InvoicePaidNotification` aux canaux `mail` et `database` → testez `Notification::assertSentTo($user, ..., fn($n,$ch)=>in_array('database',$ch))`.
3. Ajoutez une route `POST /invite` qui envoie `InviteUserMail` en **queue** → testez `Mail::assertQueued` + **quantité** exacte.

