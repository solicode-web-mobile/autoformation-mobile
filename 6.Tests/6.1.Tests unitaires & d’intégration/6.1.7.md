---
title: 7. Fakes du framework
permalink: /tests-laravel/fakes-mail-notification-event/
layout: home
nav_order: 7
parent: 6.1.Tests unitaires & dâ€™intÃ©gration
---

# ğŸ“˜ Chapitre 6.1.7 â€” Fakes du framework

## ğŸ“’ Glossaire minute
- **Fake** : remplace un service rÃ©el (Mail/Notification/Event) par un **double** qui **enregistre** les actions au lieu dâ€™exÃ©cuter lâ€™effet (envoi mail, push, diffusion dâ€™Ã©vÃ©nement).
- **Assertion** : vÃ©rification quâ€™un **mailable/notification/Ã©vÃ©nement** a Ã©tÃ© (ou non) dÃ©clenchÃ©.
- **On-demand** (notifications) : notification envoyÃ©e **sans modÃ¨le** utilisateur, via `Notification::route(...)`.

---

## ğŸ¯ Objectif
Savoir **isoler** vos tests des effets extÃ©rieurs et **prouver** que votre code a tentÃ© dâ€™envoyer :
1) un **mail** (`Mail::fake()` + `Mail::assertSent/Queued`),  
2) une **notification** (`Notification::fake()` + `Notification::assertSentTo`),  
3) un **Ã©vÃ©nement** (`Event::fake()` + `Event::assertDispatched`).  

---

## âœ… PrÃ©-requis
- `RefreshDatabase` (chap. 6.1.4).  
- Un flux mÃ©tier minimal qui **envoie** un mail/notification/Ã©vÃ©nement (ex. inscription utilisateur, commande expÃ©diÃ©e).

---

## 1) **Mail::fake()** â€” tester lâ€™envoi dâ€™e-mails

### Exemple (Pest) â€” mailable envoyÃ© Ã  lâ€™inscription
```php
<?php // tests/Feature/Mail/WelcomeMailTest.php

use Illuminate\Support\Facades\Mail;
use Illuminate\Foundation\Testing\RefreshDatabase;
use App\Mail\WelcomeMail;
use App\Models\User;

uses(RefreshDatabase::class);

it('envoie un mail de bienvenue Ã  la crÃ©ation du compte', function () {
    Mail::fake(); // 1) remplacer le transport rÃ©el

    // 2) Act â€” votre code mÃ©tier
    $user = User::factory()->create(); // suppose un observer/job qui envoie WelcomeMail

    // 3) Assert â€” le mailable a bien Ã©tÃ© envoyÃ© AU bon destinataire
    Mail::assertSent(WelcomeMail::class, function (WelcomeMail $mail) use ($user) {
        return $mail->hasTo($user->email);
    });

    // Rien dâ€™autre nâ€™a Ã©tÃ© envoyÃ© ?
    Mail::assertNotSent(\App\Mail\OtherMail::class);
});
````

### Variantes utiles

```php
Mail::assertSent(WelcomeMail::class, 1);               // exactement 1 envoi
Mail::assertNothingSent();                             // aucun mail
Mail::assertQueued(WelcomeMail::class);                // si vous utilisez ->queue()
Mail::assertNotQueued(WelcomeMail::class);
```

> ğŸ’¡ Avec `assertSent/Queued`, vous pouvez **inspecter** le mailable (sujet, variables de vue, piÃ¨ces jointes) dans la closure.

---

## 2) **Notification::fake()** â€” tester les notifications

### Exemple (PHPUnit) â€” notification de rÃ©initialisation de mot de passe

```php
<?php // tests/Feature/Notification/ResetPasswordTest.php

use Tests\TestCase;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Support\Facades\Notification;
use App\Models\User;
use App\Notifications\ResetPasswordNotification;

class ResetPasswordTest extends TestCase
{
    use RefreshDatabase;

    public function test_envoie_notification_reset_password(): void
    {
        Notification::fake();

        $user = User::factory()->create();
        // Act â€” dÃ©clencher votre logic (ex: POST /forgot-password)
        $this->post('/forgot-password', ['email' => $user->email])->assertStatus(302);

        Notification::assertSentTo(
            $user,
            ResetPasswordNotification::class,
            function (ResetPasswordNotification $n, array $channels) {
                return in_array('mail', $channels)
                    && !empty($n->token); // exemple dâ€™inspection
            }
        );

        Notification::assertNotSentTo($user, \App\Notifications\OtherNotification::class);
    }
}
```

### On-demand & nothing sent

```php
Notification::route('mail', 'client@example.com')->notify(new \App\Notifications\InvoicePaid());
Notification::assertSentOnDemand(\App\Notifications\InvoicePaid::class, function ($n, $channels, $notifiable) {
    return $notifiable->routes['mail'] === 'client@example.com';
});

Notification::assertNothingSent(); // aucune notification envoyÃ©e
```

---

## 3) **Event::fake()** â€” tester la diffusion dâ€™Ã©vÃ©nements

### Exemple (Pest) â€” Ã©vÃ©nement mÃ©tier `OrderShipped` dispatchÃ©

```php
<?php // tests/Feature/Event/OrderShippedTest.php

use Illuminate\Support\Facades\Event;
use Illuminate\Foundation\Testing\RefreshDatabase;
use App\Events\OrderShipped;
use App\Models\Order;

uses(RefreshDatabase::class);

it('diffuse lâ€™Ã©vÃ©nement OrderShipped lors de lâ€™expÃ©dition', function () {
    Event::fake(); // remplace le dispatcher

    $order = Order::factory()->create(['status' => 'paid']);

    // Act â€” votre service de shipment
    app(\App\Services\ShippingService::class)->ship($order);

    // Assert â€” lâ€™Ã©vÃ©nement a Ã©tÃ© dispatchÃ© avec les bonnes donnÃ©es
    Event::assertDispatched(OrderShipped::class, function (OrderShipped $e) use ($order) {
        return $e->order->is($order);
    });

    Event::assertNotDispatched(\App\Events\OrderCancelled::class);
});
```

### Fakes sÃ©lectifs (utile quand certains listeners doivent rester actifs)

```php
Event::fake([OrderShipped::class]);      // ne fake QUE ces Ã©vÃ©nements
Event::fakeExcept([OrderShipped::class]); // fake tout SAUF ceux-ci
Event::assertNothingDispatched();        // aucun Ã©vÃ©nement
// Bonus : vÃ©rifier le wiring dâ€™un listener
Event::assertListening(OrderShipped::class, \App\Listeners\SendShipmentEmail::class);
```

---

## 4) ModÃ¨les courants (patrons de test)

### a) *Arrange* minimal + *Act* via action HTTP

```php
Mail::fake();
Notification::fake();
Event::fake();

$response = $this->actingAs($user)->post('/orders/checkout', $payload);

$response->assertRedirect(route('orders.show', $order));
// â€¦ puis assertions Mail/Notification/Event
```

### b) Assertions de **quantitÃ©**

```php
Mail::assertSent(WelcomeMail::class, 1);
Notification::assertSentTo($user, ResetPasswordNotification::class, 1);
Event::assertDispatched(OrderShipped::class, 1);
```

### c) Assertions **nÃ©gatives** (sÃ©curitÃ©)

```php
Mail::assertNotSent(BadNewsMail::class);
Notification::assertNothingSent();
Event::assertNotDispatched(InternalEvent::class);
```

---

## 5) Cheatsheet

```php
// MAIL
Mail::fake();
Mail::assertSent(Mailable::class, fn ($m) => $m->hasTo('user@example.com'));
Mail::assertQueued(Mailable::class);
Mail::assertNothingSent();

// NOTIFICATION
Notification::fake();
Notification::assertSentTo($user, NotificationClass::class, fn ($n, $ch) => in_array('mail', $ch));
Notification::assertSentOnDemand(NotificationClass::class);
Notification::assertNothingSent();

// EVENT
Event::fake();                    // ou Event::fake([Only::class]) / fakeExcept([...])
Event::assertDispatched(EventClass::class, fn ($e) => $e->id === 123);
Event::assertNotDispatched(EventClass::class);
Event::assertNothingDispatched();
Event::assertListening(EventClass::class, ListenerClass::class);
```

---

## âœ… Check-list (DoD)

* [ ] Les **fakes** sont activÃ©s **avant** lâ€™action testÃ©e.
* [ ] Au moins **1 test mail** avec `assertSent` ou `assertQueued`.
* [ ] Au moins **1 test notification** avec `assertSentTo` (ou `assertSentOnDemand`).
* [ ] Au moins **1 test Ã©vÃ©nement** avec `assertDispatched`.
* [ ] Les assertions **inspectent** les donnÃ©es (destinataire, canaux, payload).

---

## ğŸ©¹ DÃ©pannage

* **Lâ€™assertion Ã©choue â€œrien envoyÃ©â€** â†’ avez-vous bien appelÃ© `Mail::fake()`/`Notification::fake()`/`Event::fake()` **avant** lâ€™action ?
* **`assertQueued` ne passe pas** â†’ votre code utilise `.send()` (synchrone). Utilisez `.queue()` ou testez `assertSent`.
* **Listeners nÃ©cessaires ignorÃ©s** â†’ utilisez `Event::fakeExcept([...])` pour laisser passer certains listeners.
* **DÃ©pend de la file/queue** â†’ forcer `QUEUE_CONNECTION=sync` dans `.env.testing` pour simplifier.
* **Tests fragiles au contenu HTML de mail** â†’ prÃ©fÃ©rez vÃ©rifier le **destinataire/sujet/donnÃ©es** plutÃ´t que lâ€™HTML rendu.

---

## ğŸ§ª Exercices

1. Ã€ la crÃ©ation dâ€™un **Article**, envoyer `ArticlePublished` (event) â†’ tester `Event::assertDispatched` et le **listener** enregistrÃ©.
2. ImplÃ©mentez `InvoicePaidNotification` aux canaux `mail` et `database` â†’ testez `Notification::assertSentTo($user, ..., fn($n,$ch)=>in_array('database',$ch))`.
3. Ajoutez une route `POST /invite` qui envoie `InviteUserMail` en **queue** â†’ testez `Mail::assertQueued` + **quantitÃ©** exacte.

