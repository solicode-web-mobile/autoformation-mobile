---
title: 3. Hooks & utilitaires
permalink: /tests-laravel/hooks-datasets-helpers/
layout: home
nav_order: 3
parent: 6.1.Tests unitaires & d’intégration
---

# 📘 Chapitre 6.1.3 — Hooks & utilitaires, datasets Pest, helpers de tests

## 📒 Glossaire minute
- **Hook** : code exécuté **avant/après** chaque test (ou toute la suite) pour préparer/vider l’état.
- **Fixture** : objets/données **préparés** pour un test (ex. un `User` connecté).
- **Dataset (Pest)** : **table de cas** injectée dans un test paramétré via `->with(...)`.
- **Helper** : fonction/trait utilitaire pour **factoriser** du code de test.
- **RefreshDatabase** : réinitialise la DB à **chaque test** (migrations/transactions).

---

## 🎯 Objectif
Réduire la **duplication**, accélérer l’écriture des tests et rendre la suite **lisible & robuste** en :
1) utilisant des **hooks** (`beforeEach`, `setUp`) pour les fixtures récurrentes,  
2) couvrant plusieurs **cas** avec des **datasets** Pest,  
3) centralisant des **helpers** communs (auth, JSON, assertions).

---

## 1) Hooks — préparer l’état automatiquement

### ✅ Pest : `beforeEach` / `afterEach` / `beforeAll` / `afterAll`
```php
<?php // tests/Feature/Article/IndexTest.php

use App\Models\User;
use App\Models\Article;
use Illuminate\Foundation\Testing\RefreshDatabase;

uses(RefreshDatabase::class); // ou globalement dans tests/Pest.php

beforeEach(function () {
    // Fixtures communes à CHAQUE test de ce fichier
    $this->user = User::factory()->create();
    $this->articles = Article::factory()->count(3)->create(['user_id' => $this->user->id]);
});

it('liste les articles (auth requis)', function () {
    $resp = $this->actingAs($this->user)->get('/articles');
    $resp->assertOk()->assertViewHas('articles', fn ($c) => count($c) === 3);
});
````

> `beforeAll`/`afterAll` existent mais **à utiliser avec prudence** (partage d’état → flakiness).
> Préférez `beforeEach` + `RefreshDatabase` pour des tests **isolés**.

### ✅ PHPUnit : `setUp()` / `tearDown()`

```php
<?php // tests/Feature/Article/IndexTest.php

use Tests\TestCase;
use App\Models\User;
use App\Models\Article;
use Illuminate\Foundation\Testing\RefreshDatabase;

class IndexTest extends TestCase
{
    use RefreshDatabase;

    protected User $user;

    protected function setUp(): void
    {
        parent::setUp();
        $this->user = User::factory()->create();
        Article::factory()->count(3)->create(['user_id' => $this->user->id]);
    }

    public function test_liste_les_articles_auth_requis(): void
    {
        $resp = $this->actingAs($this->user)->get('/articles');
        $resp->assertOk()->assertViewHas('articles');
    }
}
```

### 🔧 Hooks utiles Laravel (rappels)

* `RefreshDatabase` (transactions/migrations automatiques)
* `DatabaseMigrations` (migrations avant/après chaque test)
* `WithFaker` (`$this->faker`)
* `withoutExceptionHandling()` pour déboguer une stacktrace complète
* Temps : `travelTo('2025-01-01')`, `travel(5)->days()` pour figer/avancer l’horloge

---

## 2) Datasets Pest — paramétrer un test avec plusieurs cas

### a) Dataset **simple** (valeurs)

```php
<?php // tests/Unit/PasswordRulesTest.php

dataset('passwords', [
    ['Abcdef12', true],
    ['short1', false],
    ['NOLOWER12', false],
]);

test('valide la robustesse du mot de passe', function (string $pwd, bool $ok) {
    // Arrange
    $isStrong = fn (string $p) =>
        strlen($p) >= 8
        && preg_match('/[a-z]/', $p)
        && preg_match('/[A-Z]/', $p)
        && preg_match('/\d/', $p);

    // Act
    $res = $isStrong($pwd);

    // Assert
    expect($res)->toBe($ok);
})->with('passwords');
```

### b) Dataset **nommé** & **lazy** (objets via closures)

```php
<?php // tests/Feature/Article/StoreTest.php

use App\Models\User;

dataset('roles', [
    'author' => fn () => User::factory()->create(['role' => 'author']),
    'editor' => fn () => User::factory()->create(['role' => 'editor']),
]);

it('autorise la création pour certains rôles', function (callable $makeUser) {
    // Arrange
    $user = $makeUser();

    // Act
    $resp = $this->actingAs($user)->postJson('/api/articles', [
        'title' => 'Nouveau',
        'body'  => 'Contenu',
    ]);

    // Assert (exemple : seuls "author" & "editor" autorisés)
    if (in_array($user->role, ['author', 'editor'])) {
        $resp->assertCreated()->assertJsonPath('title', 'Nouveau');
    } else {
        $resp->assertForbidden();
    }
})->with('roles');
```

> **Astuce** : préférez des **closures** dans le dataset pour **créer à la demande** (évite de polluer la DB si un cas est filtré).

---

## 3) Helpers de tests — centraliser le code commun

### a) Helpers globaux Pest (dans `tests/Pest.php`)

```php
<?php // tests/Pest.php

use Illuminate\Foundation\Testing\RefreshDatabase;

uses(Tests\TestCase::class)->in('Feature', 'Unit');
uses(RefreshDatabase::class)->in('Feature');

// Helper : requête JSON authentifiée
function apiAs($user, string $method, string $uri, array $data = []) {
    return test()->actingAs($user)->json($method, $uri, $data, ['Accept' => 'application/json']);
}
```

### b) Fichier de **helpers personnalisés**

Créez `tests/Support/Helpers.php` puis chargez-le via Composer.

```php
<?php // tests/Support/Helpers.php

use Illuminate\Testing\Fluent\AssertableJson;

function assertPaginated(AssertableJson $json, int $count): void
{
    $json->has('data', $count)
         ->hasAll(['meta.current_page', 'meta.per_page', 'meta.total'])
         ->etc();
}
```

**`composer.json` (autoload-dev)**

```json
{
  "autoload-dev": {
    "psr-4": { "Tests\\": "tests/" },
    "files": ["tests/Support/Helpers.php"]
  }
}
```

Puis :

```bash
composer dump-autoload
```

### c) Trait d’assertions personnalisées

```php
<?php // tests/Support/AssertsJsonPagination.php
namespace Tests\Support;

use Illuminate\Testing\Fluent\AssertableJson;

trait AssertsJsonPagination {
    protected function assertIndexJson($response, int $expectedCount): void
    {
        $response->assertOk()->assertJson(
            fn (AssertableJson $json) => assertPaginated($json, $expectedCount)
        );
    }
}
```

Utilisation :

```php
<?php // tests/Feature/Article/IndexTest.php
use Tests\Support\AssertsJsonPagination;

uses(AssertsJsonPagination::class);

it('pagine les articles', function () {
    \App\Models\Article::factory()->count(5)->create();
    $resp = $this->getJson('/api/articles');
    $this->assertIndexJson($resp, 5);
});
```

---

## 4) Exemples rapides (mix hooks + datasets + helpers)

### a) Filtrage index avec dataset de **query params**

```php
<?php // tests/Feature/Article/FilterTest.php

dataset('filters', [
    'par auteur' => ['?author=1', 2],
    'par tag'    => ['?tag=php', 1],
    'sans filtre'=> ['', 3],
]);

beforeEach(function () {
    // 3 articles : 2 auteur#1, 1 tag=php
    \App\Models\Article::factory()->count(2)->create(['user_id' => 1]);
    \App\Models\Article::factory()->create(['tags' => ['php']]);
});

it('filtre correctement la liste', function (string $qs, int $count) {
    $resp = $this->getJson('/api/articles'.$qs);
    $resp->assertOk()->assertJson(fn($j) => $j.has('data', $count));
})->with('filters');
```

### b) Store avec helper `apiAs()`

```php
<?php // tests/Feature/Article/StoreTest.php

use App\Models\User;

it('crée un article (JSON)', function () {
    $user = User::factory()->create(['role' => 'author']);

    $resp = apiAs($user, 'POST', '/api/articles', [
        'title' => 'Hello',
        'body'  => 'World'
    ]);

    $resp->assertCreated()->assertJsonFragment(['title' => 'Hello']);
});
```

---

## ✅ Check-list (DoD)

* [ ] Fixtures **communes** extraites en `beforeEach`/`setUp`.
* [ ] `uses(RefreshDatabase::class)` appliqué (fichier ou global).
* [ ] Au moins **1 test paramétré** avec **dataset** Pest.
* [ ] **Helpers** centralisés (Pest.php, `tests/Support/*`, traits).
* [ ] Plus de **duplication** dans les tests (auth, JSON, pagination…).

---

## 🩹 Dépannage

* **“Call to undefined function apiAs()”** → déclarer dans `tests/Pest.php` ou ajouter `tests/Support/Helpers.php` à `autoload-dev.files` puis `composer dump-autoload`.
* **État qui fuit entre tests** → vérifier `RefreshDatabase`/transactions et éviter les **variables statiques** globales.
* **Dataset coûteux** → générer les fixtures **dans la closure** du dataset (lazy) plutôt qu’en `beforeEach`.
* **Conflit namespace** → helpers globaux **sans** namespace, ou importer correctement les traits/helpers.

---

